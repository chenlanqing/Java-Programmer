Redis为什么需要持久化？Redis一旦宕机，内存中的数据将全部丢失，Redis实现数据持久化，有助于故障恢复；

Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照

## 1、AOF-Append Only File

### 1.1、AOF 是什么

以日志的形式记录每个操作，将 Redis 执行过的所有`写指令`记录下来(`读操作不记录`)，只许追加但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作；

默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：

**为什么是先执行命令，再把数据写入日志呢？**

由于Redis在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作；

**后写日志主要有两个风险可能会发生：**
- 数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。
- 可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行

### 1.2、写回策略

AOF相关的配置信息
```
appendonly					是否开启aof持久化，默认为 no
appendfilename				aof持久化名称，默认是："appendonly.aof"			
appendfsync 				持久化的时间，有三种模式
		always ：同步持久化，写指令执行完毕立马将 aof_buf缓冲区中的内容刷写到 AOF 文件，性能较差但数据完整性比较好
		everysec ：写指令执行完，日志只会写到 AOF 文件缓冲区，每隔一秒就把缓冲区内容同步到磁盘
		no ：操作系统控制，写执行执行完毕，把日志写到 AOF 文件内存缓冲区，由操作系统决定何时刷写到磁盘；
no-appendfsync-on-rewrite	重写时是否可以运用 Appendfsync，用默认no即可，保证数据安全性。
auto-aof-rewrite-min-size	设置重写的基准值，aof重写的最小值，默认是64M
auto-aof-rewrite-percentage	设置重写的基准值，上次重写的比例，默认100
```
其中关于写回策略有三种：配置项 appendfsync 的三个可选值。
- **always，同步写回**：每个写命令执行完，立马同步地将日志写回磁盘；
- **everysec，每秒写回**：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- **no，操作系统控制的写回**：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。其中的原因:
- “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
- 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；
- “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失

**对比着三种策略：**

配置项 | 写回时机 | 优点 | 缺点
------|---------|------|-----
always|同步写回|可靠性高，数据基本不丢失|每个命令都落盘，性能影响较大
everysec|每秒写回|性能适中|宕机时丢失1秒数据
no | 操作系统控制的写回|性能好|宕机时丢失数据比较多

**如何选择：**
- 想要获得高性能，就选择 No 策略；
- 如果想要得到高可靠性保证，就选择 Always 策略；
- 如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略

### 1.3、Rewrite：重写机制

随着接收的写命令越来越多，AOF 文件会越来越大，AOF 文件过大会带来相应的性能问题：
- 文件系统本身对文件大小有限制，无法保存过大的文件；
- 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
- 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用；

**什么是重写**：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。AOF文件中通常会有一些冗余命令，比如：过期数据的命令、无效的命令（重复设置、删除）、多个命令可合并为一个命令（批处理命令）；在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令

**重写原理**：和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降；<br/>
重写的过程总结为 **一个拷贝，两处日志**
- **“一个拷贝”** 就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。
- **“两处日志“**：
	- 因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复；
	- 第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。

**触发：**
- 自动触发：Redis 会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次 rewrite 后大小的一倍且文件大于64M时触发；配置：`auto-aof-rewrite-min-size 64M`
	```
	no-appendfsync-on-rewrite no
	auto-aof-rewrite-percentage 100
	auto-aof-rewrite-min-size 64mb
	```
- 手动触发：可以使用命令 `bgrewriteaof`；fork一个子进程做具体的工作

**总结：** Redis 会将重写过程中的接收到的「写」指令操作同时记录到旧的 AOF 缓冲区和 AOF 重写缓冲区，这样重写日志也保存最新的操作。等到拷贝数据的所有操作记录重写完成后，重写缓冲区记录的最新操作也会写到新的 AOF 文件中；每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于遍历数据生成重写记录；使用两个日志保证在重写过程中，新写入的数据不会丢失，并且保持数据一致性

### 1.4、AOF流程

#### 1.4.1、启动

- 启动：设置 appendonly yes，将有数据的aof文件拷贝一份备份到对应目录；
- 恢复：重启redis时然后重新加载；

#### 1.4.2、文件检查

备份被写坏的文件，运行 `redis-check-aof --fix` 进行修复；重启redis将重新加载；

#### 1.4.3、AOF原理

AOF需要记录Redis的每个写命令，步骤为：命令追加（append）、文件写入（write）和文件同步（sync）

**命令追加**：开启AOF持久化功能后，服务器每执行一个写命令，都会把该命令以协议格式先追加到`aof_buf缓存区`的末尾，而不是直接写入文件，避免每次有命令都直接写入硬盘，减少硬盘IO次数；

**文件写入(write)和文件同步(sync)**

对于何时把`aof_buf缓冲区`的内容写入保存在AOF文件中，Redis提供了多种策略
- `appendfsync always`：将`aof_buf缓冲区`的所有内容写入并同步到AOF文件，每个写命令同步写入磁盘；
- `appendfsync everysec`：将`aof_buf缓存区`的内容写入AOF文件，每秒同步一次，该操作由一个线程专门负责；
- `appendfsync no`：将`aof_buf缓存区`的内容写入AOF文件，什么时候同步由操作系统来决定；

`appendfsync`选项的默认配置为`everysec`，即每秒执行一次同步；

写入的数据，操作系统并不一定会马上同步到磁盘，所以Redis才提供了`appendfsync`的选项配置。
- 当该选项时为always时，数据安全性是最高的，但是会对磁盘进行大量的写入，Redis处理命令的速度会受到磁盘性能的限制；
- `appendfsync everysec`选项则兼顾了数据安全和写入性能，以每秒一次的频率同步AOF文件，即便出现系统崩溃，最多只会丢失一秒内产生的数据；
- 如果是`appendfsync no`选项，Redis不会对AOF文件执行同步操作，而是有操作系统决定何时同步，不会对Redis的性能带来影响，但假如系统崩溃，可能会丢失不定数量的数据

### 1.5、优势与劣势

**2.5.1、优势：**

- 使用AOF Redis更持久：可以使用不同的fsync策略：完全不使用fsync，每秒使用fsync，每次查询时使用fsync。使用fsync的默认策略，每秒写操作的性能仍然很好(fsync是使用后台线程执行的，当没有fsync执行时，主线程会努力执行写操作)，但是只会损失一秒的写操作。
- AOF日志只是一个附加日志，所以如果出现断电，也不会有查找或损坏问题。即使日志以半写的命令结束，出于某种原因(磁盘已满或其他原因)，redis-check-aof工具也可以轻松修复它。
- 当AOF变得太大时，Redis能够在后台自动重写它。重写是完全安全、复述、继续追加到旧文件，产生一个全新的最小集合操作需要创建当前数据集，而一旦准备复述，开关的两个和第二个文件附加到新的一个开始。
- AOF以一种易于理解和解析的格式，包含所有操作的一个接一个的日志。您甚至可以轻松导出AOF文件。例如，即使您使用FLUSHALL命令清除了所有的错误，如果在此期间没有重写日志，您仍然可以保存您的数据集，只需停止服务器，删除最新的命令，并重新启动Redis。

**2.5.2、劣势：**

- 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。Aof 运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同
- 根据精确的fsync策略，AOF可能比RDB慢。一般来说，将fsync设置为每秒一次，性能仍然非常高，禁用fsync后，即使在高负载情况下，其速度也应该与RDB一样快。即使在写负载很大的情况下，RDB仍然能够提供关于最大延迟的更多保证。
- 在特定的命令中(例如，有一个涉及到阻塞命令，如`BRPOPLPUSH`)，导致生成的AOF在重新加载时不能完全复制相同的数据集；

## 2、RDB（Redis Datbase）

### 2.1、什么是RDB

RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是内存快照，它恢复时是将快照文件直接读到内存里；其保存的默认文件名是 `dump.rdb`

RDB采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作，所以采用RDB方法做故障恢复时只需要直接把RDB文件读入内存即可，实现快速恢复；

**给哪些内存数据做快照**

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照；全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大；

其原理是有两个核心函数：rdbSave（生成RDB文件） 和 rdbLoad（从文件加载到内存）

**主要原理：**

Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。

RDB的缺点：最后一次持久化后的数据可能丢失；

> Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据

### 2.2、关于 fork

Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。copy-on-write技术，在fork出子进程后，与父进程共享内存空间，两者只是虚拟空间不同，但是其对应的物理空间是同一个

fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了

Redis 会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作；当主线程执行写指令修改数据的时候；如果此时，主线程接收到了新写或修改操作，那么，主线程会使用写时复制机制，这个数据就会复制一份副本。具体来说，写时复制就是指，主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射；bgsave 子进程读取副本数据写到 RDB 文件；

### 2.3、配置

快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：
```conf
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

### 2.4、触发RDB快照

- 配置文件中默认的快照配置
- Redis 提供了两个命令来生成 RDB 快照文件，分别是：命令 `save` 或者 `bgsave`：
	- `save`：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用；
	- `bgsave`：该触发方式会调用 glibc 的函数fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候，这是Redis RDB 的默认配置

RDB 使用bgsave做快照的时候是可以修改的；那Redis是怎么解决在bgsave做快照的时候允许数据修改呢？这里主要是利用 bgsave的子线程实现的，具体操作如下：
- 如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响；
- 如果主线程执行写操作，则数据会复制一份副本，主线程在这个数据副本上进行修改；同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件；

**自动触发场景：**
- 根据我们的 `save m n` 配置规则自动触发；
- `从节点`全量复制时，`主节点`发送rdb文件给`从节点`完成复制操作，主节点会触发 bgsave；
- 执行 `debug reload` 时；
- 执行 shutdown 时，如果没有开启aof，也会触发。
- 执行 flushall 命令，也会产生 `dump.rdb` 文件，但里面是空的

### 2.5、如何恢复

将备份文件移动到 redis 安装目录并启动服务即可

config get dir 获取当前rdb文件存放的目录；

### 2.6、优势与劣势

- 优势：
	- 适合大规模的数据恢复，对数据完整性和一致性要求不高的；RDB 采用二进制 + 数据压缩的方式写磁盘，文件体积小，数据恢复速度快；
	- 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速
- 劣势：
	- 在一定时间间隔做一次，如果redis意外宕机，就会丢失最后一次快照后的所有修改。fork 的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑；
	- RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。
	- RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。

### 2.7、停止RBD保存

动态停止RDB保存规则的方法：`config set save ""`

## 3、关于持久化方案选择

- RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储；
- AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些 命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大；
- 只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。
- 同时开启RDB和AOF：

	在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。

	*RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？*

	作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

Redis4.0开始支持RDB和AOF的混合持久化（可以通过配置项 aof-use-rdb-preamble 开启）：简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作；这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。
- 如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据
- 如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，如果AOF文件破损，那么用redis-check-aof fix命令修复
- 如果没有AOF文件，会去加载RDB文件
- 如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复；

> Redis 支持同时开启开启两种持久化方式，可以综合使用 AOF 和 RDB 两种持久化机 制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备， 在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复；在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升

## 4、性能建议

- 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留`save 900 1`这条规则。
- 如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
- 如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以.能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构

## 5、Redis从持久化中恢复数据

启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据

## 参考资料

- [Redis持久化](https://redis.io/topics/persistence)
- [面试之Redis持久化](https://mp.weixin.qq.com/s/vfooUVhLSrpDLYdm3GDhRg)