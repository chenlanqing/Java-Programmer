# 一、数据库锁机制

- 在并发访问中，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念

- 并发控制：确保及时纠正由并发操作导致的错误的一种机制；
	- 数据库管理系统(DBMS)中的并发控制的任务是：确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性；
	- 封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段

- 锁：将数据访问顺序化，以保证数据库数据的一致性；在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足
	- 锁的分类(Oracle)：
		- 按操作划分：可分为DML锁、DDL锁
		- 按锁的粒度划分：可分为表级锁、行级锁、页级锁（mysql）
		- 按锁级别划分：可分为共享锁、排他锁
		- 按加锁方式划分：可分为自动锁、显示锁
		- 按使用方式划分：可分为乐观锁、悲观锁
	- DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))；DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）

减少并发操作的锁冲突：把复杂的sql语句，拆分成多条简单的SQL语句

# 二、MySQL中的锁

## 1、行级锁

是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁
- 行级锁能大大减少数据库操作的冲突；
- 其加锁粒度最小，但加锁的开销也最大
- 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高
- 行级锁分为共享锁 和 排他锁

## 2、表级锁

是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持；
- 最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）
- 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低

## 3、页级锁

MySQL中锁定粒度介于行级锁和表级锁中间的一种锁；开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般	

## 4、MySQL常用存储引擎的锁机制

- MyISAM和MEMORY采用表级锁(table-level locking)：
- BDB采用页面锁(page-level locking)或表级锁，默认为页面锁：
- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁：
	- InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
	- 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁
	- 行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大

## 5、行级锁与死锁

行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住
- MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待在InnoDB中，锁是逐步获得的，就造成了死锁的可能
- 在MySQL中，行级锁并不是直接锁记录，而是锁索引；索引分为主键索引和非主键索引两种.如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking

- 当两个事务同时执行，一个锁住了主键索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁
- 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务

## 6、避免死锁

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

## 7、MySQL中的共享锁与排他锁

属于行级锁

- 共享锁(Share Lock)：又称读锁，是读取操作创建的锁
	- 其他用户可以并发读取数据，但任何事务都不能对数据进行修改(获取数据上的排他锁)，直到已释放所有共享锁；如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁
	- 使用：
		`SELECT ... LOCK IN SHARE MODE;`
		在查询语句后面增加`LOCK IN SHARE MODE`，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞；

- 排他锁(eXclusive Lock)：又称写锁
	- 如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁.获准排他锁的事务既能读数据，又能修改数据；
	- 用法：`SELECT ... FOR UPDATE;`在查询语句后面增加 FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞

## 8、意向锁：InnoDB还有两个表锁

- InnoDB还有两个表锁：
	- 意向共享锁(IS)：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
	- 意向排他锁(IX)：表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁

- 意向锁是InnoDB自动加的，不需要用户干预
	对于 `insert，update，delete`，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的 select 语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁
	- 共享锁：`SELECT ... LOCK IN SHARE MODE`；
	- 排他锁：`SELECT ... FOR UPDATE`；

## 9、隐式和显示锁定

InnoDB采用的是两阶段锁定协议。在事务的执行过程中，随时可以执行锁定，锁只有在执行commit或rollback的时候才释放，并且所有的锁是在同一时刻释放。

InnoDB会根据隔离级别在需要的时候自动加锁；

InnoDB也支持通过特定的语句进行显示锁定：
- select ... lock in share mode;
- select ... for update;

## 10、行锁的算法

主要分为：`Record Lock`、`Gap Locks`和`Next-Key Locks`。
- `Gap Locks`（间隙锁）会锁住两个索引之间的区间，比如`select * from User where id>3 and id<5 for update`，就会在区间（3，5）之间加上`Gap Locks`
- `Next-Key Locks`是`Gap Locks+Record Locks`形成闭区间锁`select * from User where id>=3 and id=<5 for update`，就会在区间[3,5]之间加上Next-Key Locks，锁定记录本身；

# 三、乐观锁与悲观锁

## 1、悲观锁

- 定义：在关系数据库管理系统里，悲观并发控制(又名"悲观锁"，Pessimistic Concurrency Control，缩写"PCC")是一种并发控制的方法；
	- 它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作
	- 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中

- 它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态，悲观锁的实现，往往依靠数据库提供的锁机制 

- 在数据库中，悲观锁的流程如下：
	- 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）
	- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
	- 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
	- 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

- MySQL InnoDB中使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。`set autocommit=0;`

- 优点与不足
	- 悲观并发控制实际上是"先取锁再访问"保守策略，为数据处理的安全提供了保证
	- 效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；
	- 另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；
	- 还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

## 2、乐观锁

- 定义：
	在关系数据库管理系统里，乐观并发控制。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚

- 相对于悲观锁而言，乐观锁假设认为数据源一般情况下不会造成数据冲突，所以在数据进行提交更新的时候，才正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做

- 数据版本：
	在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
	* 数据版本：为数据增加一个版本标识.当读取数据时，将版本标识一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新时，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

- 数据版本的实现方式：
	- 使用版本号
	- 使用时间戳

- CAS：乐观锁技术，Java5之后的`J.U.C`包就是建立在[CAS](../Java/Java基础/Java并发与多线程.md#2cascompare-and-swap-比较与交换)之上的
	
- 优点与不足：乐观并发控制相信事务之间的数据竞争的概率是比较小的，因此尽可能之间做下去，直到提交的采取锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能遇到不可预期的结果.

## 3、悲观锁与乐观锁适用场景

### 3.1、悲观锁

比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量；

### 3.2、乐观锁

比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量.

乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；有时乐观锁可能与加锁操作合作

# 四、MySQL加锁分析

## 1、MVCC：多版本并发控制

### 1.1、MVCC概述

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存

可以认为MVCC是行级锁的一个变种；不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制；

REPETABLE READ隔离级别，MVCC的操作过程：
```
select
	InnoDB会根据以下两个条件检查每行记录：
	a.InnoDB只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于或等于当前事务系统版本号），这样可以确保事务读取的行，要么是在事务开始已经存在的，要么是事务自身插入或者修改过的；
	b.行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除；
	只有符合上述两个条件的记录，才能作为查询结果；
insert
	InnoDB为新插入的每一行保存当前系统版本号作为行版本号；
delete
	InnoDB为删除的每一行保存当前系统版本号作为行删除标识；
update
	InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号作为原来的行作为删除标识；
```
保存这两个额外的系统版本号，使得大多读操作都可以不用加锁；

MVCC只在`Read committed`、`Repeatable read`两个隔离级别下工作，其他两个级别都和MVCC不兼容；因为`Read uncommitted`总是读取最新的数据行，而不是符合当前事务版本的数据行；

`Read committed`和`Repeatable read`在MVCC实现层面上的区别：
- `Read committed`，每一个语句执行前都会重新计算出一个新的视图；
- 在实现`Repeatable read`隔离级别，只需要在事务开始的时候创建一致性视图，也叫做快照，之后的查询里都共用这个一致性视图，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读；

### 1.2、mysql当前读与快照读

在MVCC并发控制中，读操作可以分成两类：`快照读 (snapshot read)`与`当前读 (current read)`。
- 快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。快照读的前提是隔离级别不是串行化级别，串行化级别下的快照读会退化成当前读
- 当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录

MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现

在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：
- 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)：`select * from table where ?;`；
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
	- `select * from table where ? lock in share mode;`
	- `select * from table where ? for update;`
	- `insert into table values (…);`
	- `update table set ? where ?;`
	- `delete from table where ?;`

	所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)

 	一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读

### 1.3、MVCC解决的问题

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照，MVCC可以为数据库解决以下问题：
- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题；

### 1.4、MVCC的实现原理

MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的：3个隐式字段、undo日志、Read View 来实现的

**隐式字段：**每行记录除了我们自定义的字段外，还有数据库隐式定义的`DB_TRX_ID`、`DB_ROLL_PTR`、`DB_ROW_ID`等字段
- `DB_TRX_ID`：6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID；
- `DB_ROLL_PTR`：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）；
- `DB_ROW_ID`6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引；
- 实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了；

`DB_ROW_ID`是数据库默认为该行记录生成的唯一隐式主键，`DB_TRX_ID`是当前操作该记录的事务ID,而`DB_ROLL_PTR`是一个回滚指针，用于配合undo日志，指向上一个旧版本；

**undo日志：**
- `insert undo log`：代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- `update undo log`：事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除；

**Read View(读视图)：** Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

Read View 主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据

Read View 遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本


### 1.5、

# 参考文章

* [深入理解悲观锁与乐观锁](http：//www.hollischuang.com/archives/934)