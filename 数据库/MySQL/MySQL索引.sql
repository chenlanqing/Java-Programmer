/**
 * MySQL索引: http://blog.jobbole.com/98899/
 * 理解MySQL索引: http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html
 * MySQL 索引的数据结构: http://www.codeceo.com/article/mysql-index-struct.html
 */
1.索引:帮助MySQL高效获取数据的数据结构.索引是数据结构.
	1.1.可以理解为:排好序的快速查找数据结,主要影响 where 子句和 order by 子句.
	1.2.如何理解索引是数据结构:数据本身之外,数据库还维护着一个满足特定查找算法的数据结构,这些结构以
		某种方式指向数据,这样可以在这些数据的基础之上实现高级查找算法,这种数据结构就是索引.
	1.3.索引的优点:
		(1).创建唯一性索引,保证数据表中每一行数据的唯一性;
		(2).大大加快数据的检索速度,降低数据库的IO成本,这是创建索引的最主要的原因;
		(3).加快数据库表之间的连接,特别是在实现数据的参考完整性方面有意义;
		(4).在使用分组和排序字句进行数据检索时,同样可以显著减少系统的查询中分组和排序的时间
	1.4.索引的缺点:
		(1).创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加;
		(2).索引需要占用物理空间,除了数据表占用数据空间之外,每个表还需要占用一定的物理空间;
		(3).索引虽然提高了查询速度,同时却降低了更新表的速度,对数据进行增删改的时候,除保存数据外,
			索引也需要维护,降低数据维护的速度;
		(4).索引只是提高效率的一个因素,如果你的mysql有大量数据表,需要花时间建立索引.
2.索引分类:
	(1).普通索引(它没有任何限制.) ,如单值索引-一个索引只包含一个列
	(2).唯一性索引(索引列的值必须唯一,但允许有空值.) 
	(3).主键索引(一种特殊的唯一索引,不允许有空值.一般是在建表的时候同时创建主键索引.) 
	(4).组合索引 
	(5).聚集索引 按照每张表的主键构造一颗B+树,并且叶节点中存放着整张表的行记录数据,因此也让聚集索引的叶节点成为数据页. 
	(6).非聚集索引(辅助索引)(页节点不存放一整行记录).
3.索引的语法:
	(1).create [unique] index 索引名称 on 表名(列名,列名)
		unique 表示唯一索引
	(2).alter 表名 add [unique] index [indexName] on 列名
	(3).drop index [indexName] on 表名
	(4).show index from 表名
4.索引的结构:
	(1).B-Tree 索引
	(2).Hash索引
	(3).全文索引
	(4).R-Tree索引
5.哪些情况需要创建索引
	(1).经常出现在关键字 order by,group by, distinct 后面的字段;
	(2).在 union 等集合操作的结果集上建立索引;
	(3).为经常用作查询选择的字段建立索引;
	(4).在经常考虑用作表连接的属性上建立索引;
	(5).考虑使用索引覆盖,对数据很少被更新的表,如果用户经常只查询其中的几个字段,
		可以考虑在这几个字段上建立索引,从而将表的扫描改变为索引的扫描
	(6).主键自动为唯一索引;查询中与其他表关联的字段,外键关系建立索引
6.哪些情况不需要创建索引:
	(1).频繁更新的字段不适合创建索引
	(2).where 条件中用不到的字段不需要创建索引;
	(3).表记录太少时,不适合创建索引
	(4).数据重复且分布平均的字段,如果一个字段的值只有 true 和false 且每个值的分布概率大约为50%,
		对该字段创建索引效率一般没有太大提高.
7.索引失效:
	(1).如果条件中有or,即使其中有条件带索引,也不会使用(尽量少用or); 
	(2).Like 查询是以 %开头,例如SELECT * FROM mytable WHEREt Name like’%admin’,会导致全文搜索
	(3).如果列类型是字符串,那一定要在条件中使用引号引起来,否则不会使用索引;
	(4).应尽量避免在 where 子句中使用!=或<>操作符
	(5).in 和 not in 也要慎用，否则会导致全表扫描
	(6).如果第一个筛选条件是范围查询,MySQL 不再使用剩下的索引;
8.索引建立的原则:MySQL中,只有 InnoDB 的表是按照主键方式创建的索引组织表,而 MyISAM 还是按堆表方式组织的
	(1).使用区分度高的列作为索引:
		区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，区分度越高，
		索引树的分叉也就越多，一次性找到的概率也就越高;
	(2).尽量使用字段长度小的列作为索引
	(3).使用数据类型简单的列(int 型,固定长度)
	(4).尽量避免选用 NOT NULL 的列,在MySQL中,含有空值的列很难进行查询优化,因为它们使得索引、索引的统计信息以及比较
		运算更加复杂.你应该用0、一个特殊的值或者一个空串代替空值
	(5).尽量的扩展索引,不要新建索引.
		比如表中已经有a的索引,现在要加(a,b)的索引,那么只需要修改原来的索引即可.这样也可避免索引重复
	(6).选择合适的索引数据类型:
		越小的数据类型通常更好:越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间,处理起来更快
		简单的数据类型更好:整型数据比起字符,处理开销更小,因为字符串的比较更复杂
	(7).选择合适的标识符:
		①.整型:通常是作为标识符的最好选择,因为可以更快的处理,而且可以设置为 AUTO_INCREMENT
		②.字符串:尽量避免使用字符串作为标识符,它们消耗更好的空间,处理起来也较慢.而且,通常来说,字符串都是随机的,
			所以它们在索引中的位置也是随机的,这会导致页面分裂、随机访问磁盘,聚簇索引分裂(对于使用聚簇索引的存储引擎)
9.索引的结构及底层实现
	-- http://blog.codinglabs.org/articles/theory-of-mysql-index.html
	大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构
	9.1.索引的类型:	索引是在存储引擎中实现的而不是在服务器层中实现的.
		所以,每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型;
		9.1.1.B-Tree 索引:利用 B-Tree 索引进行全关键字、关键字范围和关键字前缀查询,保证按索引的最左边前缀来进行查询:
			(1)匹配全值(Match the full value):对索引中的所有列都指定具体的值。
			(2)匹配最左前缀(Match a leftmost prefix):你可以利用索引查找last name为Allen的人,仅仅使用索引中的第1列.
			(3)匹配列前缀(Match a column prefix):你可以利用索引查找last name以J开始的人,这仅仅使用索引中的第1列。
			(4)匹配值的范围查询(Match a range of values)：
				可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
			(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：
				可以利用索引查找last name为Allen，而first name以字母K开始的人。
			(6)仅对索引进行查询(Index-only queries):如果查询的列都位于索引中，则不需要读取元组的值。
		9.1.2.Hash 索引:建立在哈希表的基础上,它只对使用了索引中的每一列的精确查找有用
			在mysql中，只有memory存储引擎支持显式的哈希索引,是Memory表的默认索引类型
			Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。
			Hash 索引无法被用来避免数据的排序操作。
			Hash 索引不能利用部分索引键查询。
			Hash 索引在任何时候都不能避免表扫描。
			Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
		9.1.4.空间索引(R-树)索引:
			MyISAM支持空间索引,主要用于GIS中空间数据的存储，但是MySQL的空间索引支持并不好，现在多使用PostgreSQL
		9.1.5.全文索引(Full-text)索引:
			文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作
	9.2.B-树(B树): -- http://blog.jobbole.com/111757/
		9.2.1.数据库索引为什么使用树结构存储?
			(1).树的查询效率高;
			(2).二叉查找树的查找速度和比较次数都是最小的,但不得不考虑的问题是:磁盘IO
				因为数据库索引是存储在磁盘上的,当数据量比较大的时候,索引大小就可能有几个G甚至更多.
				当利用索引查询的时候,不能把整个索引全部加在到内存中,能做的只有逐一加在每一个磁盘页,
				这里的磁盘页对应的索引数的节点.
			(3).如果使用二叉查找树,磁盘的IO由树的高度决定,为了较少磁盘IO次数,需要把原来"瘦高"的树变成"矮胖".
		9.2.2.B树是一种多路平衡查找树,它的每一个节点最多包含k 个孩子,k 称为 B树的阶.k的大小取决于磁盘页的大小
			一个m阶的B树具有以下特征:
			(1).根节点至少有两个子女
			(2).每个中间节点都包含 k-1个元素和k个孩子,其中m/2 <= k <= m;
			(3).每个叶子节点都包含 k-1个元素,其中m/2 <= k <= m;
			(4).所有叶子结点都位于同一层;
			(5).每个节点中的元素从小到大排列,节点当中k-1元素正好是k个孩子包含的元素的值域划分
			例子: "附件/3阶B树.jpg"
		9.2.3.B树的查询:B 树的查询比较次数其实不比二叉搜索树少,尤其是当单一节点中的元素数量很多时.
			开始相比于磁盘IO的速度,内存中比较耗时几乎可以忽略.所以只要树的高度足够低,IO次数足够少,
			就可以提交查询速度.只要不超过磁盘页的大小即可.
		6.2.4.B树的插入:
			B 树自平衡
		9.2.5.B树的删除:

		9.2.6.B树主要应用于文件系统以及部分数据库索引,如非关系型数据库 MongoDB.	
	9.3.B+树:基于B-树的一种变体.
		9.3.1.一个m阶的B+树具有如下几个特征：
			(1).有k个子树的中间节点包含有k个元素(B树中是k-1个元素)每个元素不保存数据,只用来索引,
				所有数据都保存在叶子节点.
			(2).所有的叶子结点中包含了全部元素的信息,及指向含这些元素记录的指针,且叶子结点本身依
				关键字的大小自小而大顺序链接.
			(3).所有的中间节点元素都同时存在于子节点,在子节点元素中是最大(或最小)元素.
			例子:"附件/3阶B+树.jpg"
		9.3.2.在图片(3阶B+树.jpg)中,根节点元素 8 是子节点2,5,8的最大元素,也是叶子节点6,8的最大元素.
			==> 根节点的最大元素等同于整个B+树的最大元素,无论插入删除多少元素,始终保持最大元素在根节点中.
		9.3.3.由于父节点的所有元素都出现在子节点,因此所有叶子节点包含了全量的元素信息,并且每一个叶子节点
			都带有指向下一个节点的指针,形成了一个有序链表.
		9.3.4.卫星数据:B+树还有一个在索引外的特点,却是至关重要的特点,卫星数据的位置.
			(1).所谓卫星数据:指的是索引元素所指向的数据记录,比如数据库中的某一行.
				在B-树种无论中间节点还是叶子节点都带有卫星数据.
				而B+树只有叶子节点有卫星数据,其余中间节点仅仅是索引,没有任何数据关联.
				==> 
					在数据库的聚集索引(Clustered Index)中,叶子节点直接包含卫星数据.
					在非聚集索引(NonClustered Index)中,叶子节点带有指向卫星数据的指针
		9.3.5.B+树的查询好处:
			(1).单行范围:B+树会自顶向下查找节点,最终找到匹配到的叶子节点.
				①.首先B+树的中间节点没有卫星数据,所以同样的大小的磁盘页可以容纳更多的节点元素.
					在数据量相同的情况下B+树结构比B-树更"矮胖",因此查询时IO次数也更少
				②.其次,B+树查询必须最终查找到叶子节点,而B-树只要找到匹配元素即可,无论是叶子节点还是中间节点.
					因此B-树的查找性能不稳定(最好的情况时只查找根节点,最坏情况时查找到叶子节点).
					B+树的每一次查找都是稳定的.
			(2).范围查询:B-树只能依靠繁琐的中序遍历.而B+树只需要在链表上遍历即可.
		9.3.6.B+树相对于B-树的优势:
			(1).单一节点存储更多的元素,使得查询的IO次数更少
			(2).所有查询都要查找到叶子节点,查询性能稳定
			(3).所有叶子节点形成有序链表,便于范围查询
		9.3.7.大部分关系型数据库,比如Mysql都是用B+树作为索引的
	9.4.各引擎支持的索引:MyISAM,InnoDB,Memonry 三个常用MySQL引擎类型比较
		|索引 			|MyISAM 索引 |InnoDB 索引 |Memonry 索引|
		|------------------------------------------------------|
		|B-tree索引 	|支持		 |支持		  |支持        |
		|Hash索引   	|不支持		 |不支持	  |支持        |
		|R-tree索引 	|支持		 |不支持	  |不支持      |
		|Full-text索引 	|不支持		 |暂不支持	  |不支持      |
		+------------------------------------------------------+
10.MySQL 创建索引时在 MySQL5.5 以下的版本中会锁表
	在 5.5.以上的版本中虽然不会锁表,但是会引起主从延迟
























*******************************************************************************************************		
	1.3.索引的类型:
		索引是在存储引擎中实现的而不是在服务器层中实现的.
		所以,每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型;
		1.3.1.B-树索引:利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询,保证按索引的最左边前缀来进行查询:
			(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。
			(2)匹配最左前缀(Match a leftmost prefix)：
				你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。
			(3)匹配列前缀(Match a column prefix)：
				例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。
			(4)匹配值的范围查询(Match a range of values)：
				可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
			(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：
				可以利用索引查找last name为Allen，而first name以字母K开始的人。
			(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。
		1.3.2.Hash 索引:建立在哈希表的基础上,它只对使用了索引中的每一列的精确查找有用
			在mysql中，只有memory存储引擎支持显式的哈希索引,是Memory表的默认索引类型
			Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。
			Hash 索引无法被用来避免数据的排序操作。
			Hash 索引不能利用部分索引键查询。
			Hash 索引在任何时候都不能避免表扫描。
			Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
		1.3.4.空间索引（R-树）索引:
			MyISAM支持空间索引,主要用于GIS中空间数据的存储，但是MySQL的空间索引支持并不好，现在多使用PostgreSQL
		1.3.5.全文索引(Full-text)索引:
			文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作
2.索引的使用:
	以如下表作为表格
	字段名		数据类型	约束		INDEX
	ID			int(10)		NOT NULL	pk
	UserID		int(10)		NOT NULL	
	Mobile		varchar(15)	NOT NULL	
	ArriveDate	DateTime	NOT NULL	
	AddDate		DateTime	NOT NULL	
	UpdateTime	timetamp	NOT NULL	
	2.1.在查询中使用索引:
		select ArriveDate from TestSQL where UserID = 10;
		(1).如果没有索引,数据库就会根据主键（ID）扫描全表，每拿到一条数据库记录就与where条件比对，
			如果符合条件则将这条记录返回，重复直到全表扫描完毕
		(2).使用UserID作为索引:
			这时候数据库引擎会根据UserID到索引上找到ID，然后根据ID去查询对应记录，从而取出ArriveDate数据
		一次查询同一张表，MySQL每次只会使用一个索引。
	2.2.索引在范围查询的使用:范围查询主要是指查询字段值在某个范围内的记录,表现在 where 条件中为>,<,between 等关键字
		在范围查询中,索引的使用是遵循最左（leftmost）原则
	2.3.排序使用索引
		(1).在排序中以下情况无法使用索引:
			Order by 的字段并不是索引
			使用了两种排序方向，但是索引都是使用升序排列的
			不符合最左（Left most）的条件
			联合查询的情况下，如果第一个筛选条件是范围查询，MySQL不再使用剩下的索引
	2.4.join 中使用索引:
		(1).join操作时，大表小表的概念，主要是按照两张表分别执行对应查询条件，哪个开销更小，哪个就是小表
			小表决定了查询的次数,大表决定了每次查询所需要的时间;
		(2).join操作虽然在SQL层面很方便，而且在线上大流量的情况下，一旦SQL的join操作导致查询缓慢，较难即使优化。
			另外在服务化的系统中，容易导致业务领域不清晰，所以在互联网大流量的应用中是不推荐使用join操作的
	2.5.如果一个表中有多个索引,可以强制指定某个索引:
		select * from preson force index(IX_USERID);注意该索引肯定会被用上的
4.索引使用的原则:
	(1).最左前缀匹配原则(leftmost):
		mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，=和in可以乱序
	(2).索引列不能参与计算:
	(3).查询数据库记录时，查询到的条目数尽量小，当通过索引获取到的数据库记录> 数据库总揭露的1/3时,
		SQL 将有可能直接全表扫描，索引就失去了应有的作用











































