/**
 * MySQL索引: http://blog.jobbole.com/98899/
 * 理解MySQL索引: http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html
 * MySQL 索引的数据结构: http://www.codeceo.com/article/mysql-index-struct.html
 */
InnoDB数据表的数据行级锁定实际发生在它们的索引上
1.MySQL索引原理:索引(Index)是帮助MySQL高效获取数据的数据结构,即索引是数据结构
	1.1.索引的目的在于提高查询效率
	1.2.索引的原理:

	1.3.索引的类型:
		索引是在存储引擎中实现的而不是在服务器层中实现的.
		所以,每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型;
		1.3.1.B-树索引:利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询,保证按索引的最左边前缀来进行查询:
			(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。
			(2)匹配最左前缀(Match a leftmost prefix)：
				你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。
			(3)匹配列前缀(Match a column prefix)：
				例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。
			(4)匹配值的范围查询(Match a range of values)：
				可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
			(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：
				可以利用索引查找last name为Allen，而first name以字母K开始的人。
			(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。
		1.3.2.Hash 索引:建立在哈希表的基础上,它只对使用了索引中的每一列的精确查找有用
			在mysql中，只有memory存储引擎支持显式的哈希索引,是Memory表的默认索引类型
			Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。
			Hash 索引无法被用来避免数据的排序操作。
			Hash 索引不能利用部分索引键查询。
			Hash 索引在任何时候都不能避免表扫描。
			Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
		1.3.4.空间索引（R-树）索引:
			MyISAM支持空间索引,主要用于GIS中空间数据的存储，但是MySQL的空间索引支持并不好，现在多使用PostgreSQL
		1.3.5.全文索引(Full-text)索引:
			文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作
2.索引的使用:
	以如下表作为表格
	字段名		数据类型	约束		INDEX
	ID			int(10)		NOT NULL	pk
	UserID		int(10)		NOT NULL	
	Mobile		varchar(15)	NOT NULL	
	ArriveDate	DateTime	NOT NULL	
	AddDate		DateTime	NOT NULL	
	UpdateTime	timetamp	NOT NULL	
	2.1.在查询中使用索引:
		select ArriveDate from TestSQL where UserID = 10;
		(1).如果没有索引,数据库就会根据主键（ID）扫描全表，每拿到一条数据库记录就与where条件比对，
			如果符合条件则将这条记录返回，重复直到全表扫描完毕
		(2).使用UserID作为索引:
			这时候数据库引擎会根据UserID到索引上找到ID，然后根据ID去查询对应记录，从而取出ArriveDate数据
		一次查询同一张表，MySQL每次只会使用一个索引。
	2.2.索引在范围查询的使用:范围查询主要是指查询字段值在某个范围内的记录,表现在 where 条件中为>,<,between 等关键字
		在范围查询中,索引的使用是遵循最左（leftmost）原则
	2.3.排序使用索引
		(1).在排序中以下情况无法使用索引:
			Order by 的字段并不是索引
			使用了两种排序方向，但是索引都是使用升序排列的
			不符合最左（Left most）的条件
			联合查询的情况下，如果第一个筛选条件是范围查询，MySQL不再使用剩下的索引
	2.4.join 中使用索引:
		(1).join操作时，大表小表的概念，主要是按照两张表分别执行对应查询条件，哪个开销更小，哪个就是小表
			小表决定了查询的次数,大表决定了每次查询所需要的时间;
		(2).join操作虽然在SQL层面很方便，而且在线上大流量的情况下，一旦SQL的join操作导致查询缓慢，较难即使优化。
			另外在服务化的系统中，容易导致业务领域不清晰，所以在互联网大流量的应用中是不推荐使用join操作的
	2.5.如果一个表中有多个索引,可以强制指定某个索引:
		select * from preson force index(IX_USERID);注意该索引肯定会被用上的
3.索引建立的原则:
	MySQL中，只有InnoDB的表是按照主键方式创建的索引组织表，而MyISAM还是按堆表方式组织的
	(1).使用区分度高的列作为索引:
		区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，区分度越高，
		索引树的分叉也就越多，一次性找到的概率也就越高;
	(2).尽量使用字段长度小的列作为索引
	(3).使用数据类型简单的列（int 型，固定长度）
	(4).尽量避免选用NOT NULL的列
		在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。
		你应该用0、一个特殊的值或者一个空串代替空值
	(5).尽量的扩展索引，不要新建索引.
		比如表中已经有a的索引,现在要加(a,b)的索引,那么只需要修改原来的索引即可.这样也可避免索引重复
	(6).选择合适的索引数据类型:
		越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快
		简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂
	(7).选择合适的标识符:
		①.整型:通常是作为标识符的最好选择，因为可以更快的处理，而且可以设置为 AUTO_INCREMENT
		②.字符串:尽量避免使用字符串作为标识符，它们消耗更好的空间，处理起来也较慢。而且，通常来说，字符串都是随机的，
		所以它们在索引中的位置也是随机的，这会导致页面分裂、随机访问磁盘，聚簇索引分裂（对于使用聚簇索引的存储引擎）
4.索引使用的原则:
	(1).最左前缀匹配原则(leftmost):
		mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，=和in可以乱序
	(2).索引列不能参与计算:
	(3).查询数据库记录时，查询到的条目数尽量小，当通过索引获取到的数据库记录> 数据库总揭露的1/3时,
		SQL 将有可能直接全表扫描，索引就失去了应有的作用
5.explain:显示了mysql如何使用索引来处理select语句以及连接表.可以帮助选择更好的索引和写出更优化的查询语句
	5.1.用法:在select语句前加上explain就可以了
		explain select * from people
	5.2.执行结果分析:
		+----+-------------+--------+------+---------------+------+---------+------+------+-------+
		| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra |
		+----+-------------+--------+------+---------------+------+---------+------+------+-------+
		|  1 | SIMPLE      | person | ALL  | NULL          | NULL | NULL    | NULL |    4 |       |
		+----+-------------+--------+------+---------------+------+---------+------+------+-------+
	5.3.字段语义:
		(1).table:显示这一行的数据是关于哪张表的
		(2).type:这是重要的列,显示连接使用了何种类型.从最好到最差的连接类型为 const、eq_reg、ref、range、indexhe和all
		(3).possible_keys：显示可能应用在这张表中的索引.如果为空,没有可能的索引.可以为相关的域从where语句中选择一个合适的语句
		(4).key:实际使用的索引.如果为 null，则没有使用索引。很少的情况下，mysql会选择优化不足的索引.这种情况下,可以在
			select 语句中使用use index(indexname)来强制使用一个索引或者用ignore index（indexname）来强制mysql忽略索引
		(5).key_len:使用的索引的长度。在不损失精确性的情况下，长度越短越好.
		(6).ref:显示索引的哪一列被使用了，如果可能的话，是一个常数;
		(7).rows：mysql认为必须检查的用来返回请求数据的行数
		(8).xtra：关于mysql如何解析查询的额外信息;
	5.4.extra列返回的描述的意义:
		distinct:一旦mysql找到了与行相联合匹配的行，就不再搜索了
		not exists: mysql优化了left join，一旦它找到了匹配left join标准的行，就不再搜索了
		range checked for each record(index map:):没有找到理想的索引，因此对于从前面表中来的每一个行组合，
			mysql检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
		using filesort: 看到这个的时候，查询就需要优化了。mysql需要进行额外的步骤来发现如何对返回的行排序。
			它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
		using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都
			是同一个索引的部分的时候
		using temporary 看到这个的时候，查询需要优化了。这里，mysql需要创建一个临时表来存储结果，这通常发生在对
			不同的列集进行order by上，而不是group by上
		where used 使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且
			连接类型all或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）
		system 表只有一行：system表。这是const连接类型的特殊情况
		const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，
			因为mysql先读这个值然后把它当做常数来对待
		eq_ref:在连接中，mysql在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主
			键或惟一键的全部时使用
		ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。
			对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好
		range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况
		index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比all更好，因为索引一般小于表数据）
		all:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免
6.B-Tree 索引:
	6.1.限制:
		(1) 查询必须从索引的最左边的列开始.关于这点已经提了很多遍了;
		(2) 不能跳过某一索引列;
		(3) 存储引擎不能使用索引中范围条件右边的列;
	6.2.B-Tree 描述:
		(1).首先定义一条数据记录为一个二元组[key, data],key为记录的键值,
			对于不同数据记录,key是互不相同的;data为数据记录除key外的数据;
		(2).B-Tree是满足下列条件的数据结构:
			①.d为大于1的一个正整数，称为B-Tree的度;
			②.h为一个正整数，称为B-Tree的高度;
			③.每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d;
			④.每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为 null 
			⑤.所有叶节点具有相同的深度，等于树高h;
			⑥.key和指针互相间隔，节点两端是指针;
			⑦.一个节点中的key从左到右非递减排列;
			⑧.所有节点组成树结构,每个指针要么为 null，要么指向另外一个节点
	6.3.B-Tree中按key检索数据的算法:
		首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，
		直到找到节点或找到 null 指针，前者查找成功，后者查找失败
7.











































