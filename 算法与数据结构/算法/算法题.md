<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [1、10000个数排序取前十，十万个数排序取中位数,一万个数排序取某页](#110000%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E5%89%8D%E5%8D%81%E5%8D%81%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%80%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E6%9F%90%E9%A1%B5)
- [2、队列反转实现(递归或非递归实现)](#2%E9%98%9F%E5%88%97%E5%8F%8D%E8%BD%AC%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E6%88%96%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
- [3、模拟微信群m人 抢 n份  x元 红包](#3%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E7%BE%A4m%E4%BA%BA-%E6%8A%A2-n%E4%BB%BD--x%E5%85%83-%E7%BA%A2%E5%8C%85)
- [4、大数的乘法](#4%E5%A4%A7%E6%95%B0%E7%9A%84%E4%B9%98%E6%B3%95)
- [5、一致性Hash算法](#5%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95)
- [6、如何充分利用多核CPU，计算很大的List中所有整数的和](#6%E5%A6%82%E4%BD%95%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E5%A4%9A%E6%A0%B8cpu%E8%AE%A1%E7%AE%97%E5%BE%88%E5%A4%A7%E7%9A%84list%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C)
  - [6.1、CyclicBarrier实现方式](#61cyclicbarrier%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
  - [6.3、Fork/Join框架实现](#63forkjoin%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1、10000个数排序取前十，十万个数排序取中位数,一万个数排序取某页

## 2、队列反转实现(递归或非递归实现)

## 3、模拟微信群m人 抢 n份  x元 红包
    https://www.zhihu.com/question/22625187
    https://www.jianshu.com/p/026ceece4d80
    https://mp.weixin.qq.com/s/AIE33sdT2QI6UL8cs1kJCQ

## 4、大数的乘法

## 5、一致性Hash算法

## 6、如何充分利用多核CPU，计算很大的List中所有整数的和

* [Fork/Join实现并行计算](https://juejin.im/post/59be875e5188257e6b6d91c1)
* [CyclicBarrier实现求和](http://flysnow.iteye.com/blog/711162)

### 6.1、CyclicBarrier实现方式

它是一个同步辅助类，它允许一组线程（任务）互相等待，直到到达某个公共屏障点（common barrier point）

处理步骤：

- 分割List，根据采用的线程（任务）数平均分配，即list.size()/threadCounts
- 定义一个记录“很大List”中所有整数和的变量sum，采用一个线程（任务）处理一个分割后的子List，计算子List中所有整数和（subSum），然后把和（subSum）累加到sum上
- 等待所有线程（任务）完成后输出总和(sum)的值

如图所示：

![image](https://github.com/chenlanqing/learningNote/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/image/CyclicBarrier%E5%AE%9E%E7%8E%B0%E5%A4%A7List%E6%95%B4%E6%95%B0%E7%B4%AF%E5%8A%A0.png)

```java
@Slf4j
public class CyclicBarrierCountListSum {
    /**
     * 存放整数的和
     */
    private long sum;
    /**
     * 同步器
     */
    private CyclicBarrier barrier;
    /**
     * 整数集合List
     */
    private List<Integer> list;
    /**
     * 使用的线程数
     */
    private int threadCounts;
    public CyclicBarrierCountListSum(List<Integer> list, int threadCounts) {
        this.list = list;
        this.threadCounts = threadCounts;
    }
    /**
     * 获取List中所有整数的和
     * @return
     */
    public long getIntegerSum() {
        ExecutorService exec = Executors.newFixedThreadPool(threadCounts);
        // 平均分割List
        int len = list.size() / threadCounts;
        // List中的数量没有线程数多（很少存在）
        if (len == 0) {
            // 采用一个线程处理任务
            threadCounts = list.size();
            len = list.size() / threadCounts;
        }
        barrier = new CyclicBarrier(threadCounts + 1);
        for (int i = 0; i < threadCounts; i++) {
            if (i == threadCounts - 1) {
                // 最后一个线程承担剩下的所有元素的计算
                exec.execute(new SubIntegerTask(list.subList(i * len, list.size())));
            } else {
                exec.execute(new SubIntegerTask(list.subList(i * len, len * (i + 1) > list.size() ? list.size() : len * (i + 1))));
            }
        }
        try {
            // 使该线程在障栅处等待，直到所有的线程都到达障栅处
            barrier.await();
        } catch (InterruptedException e) {
            log.info("{}:Interrupted", Thread.currentThread().getName());
        } catch (BrokenBarrierException e) {
            log.info("{}:BrokenBarrier", Thread.currentThread().getName());
        }
        exec.shutdown();
        return sum;
    }
    /**
     * 分割计算List整数和的线程任务
     */
    public class SubIntegerTask implements Runnable {
        private List<Integer> subList;
        public SubIntegerTask(List<Integer> subList) {
            this.subList = subList;
        }
        @Override
        public void run() {
            long subSum = 0L;
            for (Integer i : subList) {
                subSum += i;
            }
            synchronized (CyclicBarrierCountListSum.this) {
                sum += subSum;
            }
            try {
                // 使该线程在障栅处等待，直到所有的线程都到达障栅处
                barrier.await();
            } catch (InterruptedException e) {
                log.info("{}:Interrupted", Thread.currentThread().getName());
            } catch (BrokenBarrierException e) {
                log.info("{}:BrokenBarrier", Thread.currentThread().getName());
            }
            log.info("分配给线程：{} 那一部分List整数和为 subSum={}", Thread.currentThread().getName(), subSum);
        }
    }
}
```

### 6.3、Fork/Join框架实现
```java
public class ForkJoinLargeSum {
    public static void main(String[] args) throws Exception {
        int[] array = IntStream.rangeClosed(0, 100).toArray();
        ForkJoinPool pool = new ForkJoinPool();
        Task task = new Task(0, array.length, 100, array);
        Future<Integer> future = pool.submit(task);
        System.out.println(future.get());

        pool.shutdown();
    }
    static class Task extends RecursiveTask<Integer> {
        public static final int DEFAULT_THRESHOLD = 1000;
        private int high, low;
        private int threshold;
        private int[] array;
        public Task(int low, int high, int threshold, int[] array) {
            this.high = high;
            this.low = low;
            this.threshold = threshold;
            this.array = array;
        }
        @Override
        protected Integer compute() {
            if (high - low <= threshold) {
                int sum = 0;
                for (int i = low; i < high; i++) {
                    sum += array[i];
                }
                return sum;
            } else {
                int middle = (high - low) / 2 + low;
                Task leftTask = new Task(low, middle, threshold, array);
                Task rightTask = new Task(middle, high, threshold, array);
                leftTask.fork();
                rightTask.fork();
                return leftTask.join() + rightTask.join();
            }
        }
    }
}


```















