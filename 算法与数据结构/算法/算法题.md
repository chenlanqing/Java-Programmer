<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [1、10000个数排序取前十，十万个数排序取中位数，一万个数排序取某页](#110000%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E5%89%8D%E5%8D%81%E5%8D%81%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%80%E4%B8%87%E4%B8%AA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%8F%96%E6%9F%90%E9%A1%B5)
- [2、队列反转实现(递归或非递归实现)](#2%E9%98%9F%E5%88%97%E5%8F%8D%E8%BD%AC%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E6%88%96%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
- [3、模拟微信群m人 抢 n份  x元 红包](#3%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E7%BE%A4m%E4%BA%BA-%E6%8A%A2-n%E4%BB%BD--x%E5%85%83-%E7%BA%A2%E5%8C%85)
- [4、大数的乘法](#4%E5%A4%A7%E6%95%B0%E7%9A%84%E4%B9%98%E6%B3%95)
- [5、如何充分利用多核CPU，计算很大的List中所有整数的和](#5%E5%A6%82%E4%BD%95%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E5%A4%9A%E6%A0%B8cpu%E8%AE%A1%E7%AE%97%E5%BE%88%E5%A4%A7%E7%9A%84list%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C)
  - [5.1、CyclicBarrier实现方式](#51cyclicbarrier%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
  - [5.2、Fork/Join框架实现](#52forkjoin%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0)
- [6、八皇后问题：递归回溯](#6%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF)
- [7、最大公约数与最小公倍数](#7%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0)
  - [7.1、辗转相除法-欧几里德算法，求出两个正整数的最大公约数](#71%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95%E6%B1%82%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0)
  - [7.2、更相减损术（九章算术），也是求最大公约数的方法](#72%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF%E4%B9%9F%E6%98%AF%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 1、10000个数排序取前十，十万个数排序取中位数，一万个数排序取某页

# 2、队列反转实现(递归或非递归实现)

# 3、模拟微信群m人 抢 n份  x元 红包
    https：//www.zhihu.com/question/22625187
    https：//www.jianshu.com/p/026ceece4d80
    https：//mp.weixin.qq.com/s/AIE33sdT2QI6UL8cs1kJCQ

# 4、大数四则运算

## 4.1、大数的乘法

## 4.2、大数的加法

[大数的加法](https://mp.weixin.qq.com/s/Quw4olmTYEE4qLCupld91A)


# 5、如何充分利用多核CPU，计算很大的List中所有整数的和

* [Fork/Join实现并行计算](https：//juejin.im/post/59be875e5188257e6b6d91c1)
* [CyclicBarrier实现求和](http：//flysnow.iteye.com/blog/711162)

## 5.1、CyclicBarrier实现方式

它是一个同步辅助类，它允许一组线程（任务）互相等待，直到到达某个公共屏障点（common barrier point）

处理步骤：

- 分割List，根据采用的线程（任务）数平均分配，即list.size()/threadCounts
- 定义一个记录“很大List”中所有整数和的变量sum，采用一个线程（任务）处理一个分割后的子List，计算子List中所有整数和（subSum），然后把和（subSum）累加到sum上
- 等待所有线程（任务）完成后输出总和(sum)的值

如图所示：

![image](https：//github.com/chenlanqing/learningNote/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/image/CyclicBarrier%E5%AE%9E%E7%8E%B0%E5%A4%A7List%E6%95%B4%E6%95%B0%E7%B4%AF%E5%8A%A0.png)

```java
@Slf4j
public class CyclicBarrierCountListSum {
    /**
     * 存放整数的和
     */
    private long sum;
    /**
     * 同步器
     */
    private CyclicBarrier barrier;
    /**
     * 整数集合List
     */
    private List<Integer> list;
    /**
     * 使用的线程数
     */
    private int threadCounts;
    public CyclicBarrierCountListSum(List<Integer> list， int threadCounts) {
        this.list = list;
        this.threadCounts = threadCounts;
    }
    /**
     * 获取List中所有整数的和
     * @return
     */
    public long getIntegerSum() {
        ExecutorService exec = Executors.newFixedThreadPool(threadCounts);
        // 平均分割List
        int len = list.size() / threadCounts;
        // List中的数量没有线程数多（很少存在）
        if (len == 0) {
            // 采用一个线程处理任务
            threadCounts = list.size();
            len = list.size() / threadCounts;
        }
        barrier = new CyclicBarrier(threadCounts + 1);
        for (int i = 0; i < threadCounts; i++) {
            if (i == threadCounts - 1) {
                // 最后一个线程承担剩下的所有元素的计算
                exec.execute(new SubIntegerTask(list.subList(i * len， list.size())));
            } else {
                exec.execute(new SubIntegerTask(list.subList(i * len， len * (i + 1) > list.size() ? list.size() ： len * (i + 1))));
            }
        }
        try {
            // 使该线程在障栅处等待，直到所有的线程都到达障栅处
            barrier.await();
        } catch (InterruptedException e) {
            log.info("{}：Interrupted"， Thread.currentThread().getName());
        } catch (BrokenBarrierException e) {
            log.info("{}：BrokenBarrier"， Thread.currentThread().getName());
        }
        exec.shutdown();
        return sum;
    }
    /**
     * 分割计算List整数和的线程任务
     */
    public class SubIntegerTask implements Runnable {
        private List<Integer> subList;
        public SubIntegerTask(List<Integer> subList) {
            this.subList = subList;
        }
        @Override
        public void run() {
            long subSum = 0L;
            for (Integer i ： subList) {
                subSum += i;
            }
            synchronized (CyclicBarrierCountListSum.this) {
                sum += subSum;
            }
            try {
                // 使该线程在障栅处等待，直到所有的线程都到达障栅处
                barrier.await();
            } catch (InterruptedException e) {
                log.info("{}：Interrupted"， Thread.currentThread().getName());
            } catch (BrokenBarrierException e) {
                log.info("{}：BrokenBarrier"， Thread.currentThread().getName());
            }
            log.info("分配给线程：{} 那一部分List整数和为 subSum={}"， Thread.currentThread().getName()， subSum);
        }
    }
}
```

## 5.2、Fork/Join框架实现
```java
public class ForkJoinLargeSum {
    public static void main(String[] args) throws Exception {
        int[] array = IntStream.rangeClosed(0， 100).toArray();
        ForkJoinPool pool = new ForkJoinPool();
        Task task = new Task(0， array.length， 100， array);
        Future<Integer> future = pool.submit(task);
        System.out.println(future.get());

        pool.shutdown();
    }
    static class Task extends RecursiveTask<Integer> {
        public static final int DEFAULT_THRESHOLD = 1000;
        private int high， low;
        private int threshold;
        private int[] array;
        public Task(int low， int high， int threshold， int[] array) {
            this.high = high;
            this.low = low;
            this.threshold = threshold;
            this.array = array;
        }
        @Override
        protected Integer compute() {
            if (high - low <= threshold) {
                int sum = 0;
                for (int i = low; i < high; i++) {
                    sum += array[i];
                }
                return sum;
            } else {
                int middle = (high - low) / 2 + low;
                Task leftTask = new Task(low， middle， threshold， array);
                Task rightTask = new Task(middle， high， threshold， array);
                leftTask.fork();
                rightTask.fork();
                return leftTask.join() + rightTask.join();
            }
        }
    }
}


```

# 6、八皇后问题：递归回溯

https://mp.weixin.qq.com/s/puk7IAZkSe6FCkZnt0jnSA


# 7、最大公约数与最小公倍数

## 7.1、辗转相除法-欧几里德算法，求出两个正整数的最大公约数

- 1、欧几里德算法定理：两个正整数a和b(a>b)它们的最大公约数等于a除以b的余数c和b之间的最大公约数

- 2、思路：基于上述定理，可以使用递归的方法来把问题逐步简化：
    - 首先，我们先计算出a除以b的余数c，把问题转化成求出b和c的最大公约数；
    - 然后计算出b除以c的余数d，把问题转化成求出c和d的最大公约数；
    - 再然后计算出c除以d的余数e，把问题转化成求出d和e的最大公约数； ......

    逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止

- 3、代码一：
    ```java
    public static int getGreatestCommonDivisor(int a， int b){
        int result = 1;
        if (a > b) {
            result = gcd(a， b);
        } else {
            result = gcd(b， a);
        }
        return result;
    }
    public static int gcd(int a， int b){
        if (a % b == 0) {
            return b;
        } else {
            return gcd(b， a%b);
        }
    }
    ```
- 4、上述代码问题点：当两个整数比较大时，做 a%b 取模运算性能比较低

## 7.2、更相减损术（九章算术），也是求最大公约数的方法

- 1、定理：两个正整数a和b(a>b)，它们的最大公约数等于a-b的差值c和较小数b的最大公约数

- 2、思路：我们同样可以通过递归来简化问题.
    - 首先，我们先计算出a和b的差值c（假设a>b），把问题转化成求出b和c的最大公约数;
    - 然后计算出c和b的差值d（假设c>b），把问题转化成求出b和d的最大公约数;
    - 再然后计算出b和d的差值e（假设b>d），把问题转化成求出d和e的最大公约数;

    ......

    - 逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算
- 3、代码二：
    ```java
    public static int getGreatestCommonDivisor(int a， int b){
        if (a == b) {
            return b;
        } else if (a > b) {
            getGreatestCommonDivisor(a - b， b);
        } else {
            getGreatestCommonDivisor(b - a， a);
        }
    }
    ```
- 4、相对于欧几里得算法，更相减损术依靠求两数的差方式来递归，运算的次数肯定远大于欧几里德算法.

- 5、优化思路：在更相减损术基础上使用移位算法：

    对于给定的正整数a和b，不难得到如下的结论。其中gcb(a，b)的意思是a，b的最大公约数函数：
    - 当a和b均为偶数，```gcb(a，b) = 2*gcb(a/2， b/2) = 2*gcb(a>>1， b>>1)```
    - 当a为偶数，b为奇数，gcb(a，b) = gcb(a/2， b) = gcb(a>>1， b) 
    - 当a为奇数，b为偶数，gcb(a，b) = gcb(a， b/2) = gcb(a， b>>1) 
    - 当a和b均为奇数，利用更相减损术运算一次，gcb(a，b) = gcb(b， a-b)， 此时a-b必然是偶数，又可以继续进行移位运算.

    - 比如：计算10和25的最大公约数的步骤如下
        - 整数10通过移位，可以转换成求5和25的最大公约数;
        - 利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数;
        - 整数20通过移位，可以转换成求5和10的最大公约数，
        - 整数10通过移位，可以转换成求5和5的最大公约数
        - 利用更相减损法，因为两数相等，所以最大公约数是5

- 6、代码三：
    ```java
    public static int getData(int a， int b) {
        if (a == b) {
            return a;
        } else if (a < b) {
            return getData(b， a);
        } else {
            if ((a & 1) == 0 && (b & 1) == 0) {
                return getData(a >> 1， b >> 1) << 1;
            } else if ((a & 1) == 0 && (b & 1) != 0) {
                return getData(a >> 1， b);
            } else if ((a & 1) != 0 && (b & 1) == 0) {
                return getData(a， b >> 1);
            } else {
                return getData(b， a - b);
            }
        }
    }
    ```
## 7.3、最小公倍数

两个正整数a和b的乘积除以两个数的最大公约数--> 最小公倍数=两整数的乘积 / 最大公约数


# 8、给你5000万个int，求出前1000个最大的数，有2G内存









