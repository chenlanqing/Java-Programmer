<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一、一致性Hash算法](#%E4%B8%80%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95)
- [二、加密算法](#%E4%BA%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)
- [三、缓存淘汰算法](#%E4%B8%89%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [1、LRU-根据数据的历史访问记录来进行淘汰数据](#1lru-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B7%98%E6%B1%B0%E6%95%B0%E6%8D%AE)
- [四、A*寻路算法](#%E5%9B%9Ba%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95)
- [五、BitMap算法](#%E4%BA%94bitmap%E7%AE%97%E6%B3%95)
- [六、布隆算法](#%E5%85%AD%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 一、一致性Hash算法

# 二、加密算法

# 三、缓存淘汰算法

* [缓存淘汰算法](http://flychao88.iteye.com/blog/1977653)

## 1、LRU-根据数据的历史访问记录来进行淘汰数据

其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"

### 1.1、实现：最常见的实现是使用一个链表保存缓存数
- 新数据插入链表头部;
- 每当缓存命中(即缓存数据被访问),则将数据移动到链表头部;
- 当链表满的时候,将链表尾部的数据丢弃;

### 1.2、分析

- 命中率：当存在热点数据时,LRU的效率很好,但偶发性的\周期性的批量操作会导致LRU命中率急剧下降,缓存污染情况比较严重；
- 实现简单；
- 代价：命中时需要遍历链表,找到命中的数据索引,然后将数据移到头部；

### 1.3、源码实现

# 四、A*寻路算法


# 五、海量数据处理算法

# 五、BitMap算法

https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg

# 六、布隆算法

* [布隆算法](https://mp.weixin.qq.com/s/RmR5XmLeMvk35vgjwxANFQ)




# 参考资料
* [面试和算法心得](https://www.kancloud.cn/kancloud/the-art-of-programming/41619)




