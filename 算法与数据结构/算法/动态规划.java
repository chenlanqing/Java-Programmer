一.基本点:
1.动态规划:将原问题拆解成若干个子问题,同时保存子问题的答案,使得每个子问题只求解一次,最终获得原问题的答案;
 	是求解决策过程(decision process)最优化的数学方法;
 	把多阶段过程转化为一系列单阶段问题,利用各阶段之间的关系,逐个求解,创立了解决这类过程优化问题的新方法；
2.动态规划的本质是:递归问题。
3.基本思想:与分治算法类型,是将待求解的问题分解为若干个子问题(阶段),按顺序求解子阶段,前一子问题的解为后一子问题的
	求解.
	多数有重叠子问题这个特点,为减少重复计算,对每一个子问题只解一次,将其不同阶段的不同状态保存在一个二维数组中
4.与分治算法区别:
	适合于用动态规划法求解的问题,经分解后得到的子问题往往不是互相独立的.
	即下一个子阶段的求解是建立在上一个子阶段的解的基础上,进行进一步的求解.
5.适用情况:
	(1).最优化原理:如果问题的最优解所包含的子问题的解也是最优的,就称该问题具有最优子结构,即满足最优化原理;
	(2).无后效性:即某阶段状态一旦确定,就不受这个状态以后决策的影响.
		也就是说,某状态以后的过程不会影响以前的状态,只与当前状态有关.
	(3).有重叠子问题:即子问题之间是不独立的,一个子问题在下一阶段决策中可能被多次使用到;
		该性质并不是动态规划适用的必要条件,但是如果没有这条性质,动态规划算法同其他算法相比就不具备优势.
6.求解的基本步骤:动态规划所处理的问题是一个多阶段决策问题,动态规划的设计都有着一定的模式,一般要经历以下几个步骤
	初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
	(1).划分阶段:按照问题的时间或空间特征,把问题分为若干个阶段.
		在划分阶段时,注意划分后的阶段一定要是有序的或者是可排序的,否则问题就无法求解;
	(2).确定状态和状态变量:
		将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来.当然,状态的选择要满足无后效性;
	(3).确定决策并写出状态转移方程:
		因为决策和状态转移有着天然的联系,状态转移就是根据上一阶段的状态和决策来导出本阶段的状态.
		根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程.
	(4).寻找边界条件:
		给出的状态转移方程是一个递推式,需要一个递推的终止条件或边界条件.
	==> 实际应用中可以按以下几个简化的步骤进行设计：
    	A.分析最优解的性质，并刻画其结构特征。
    	B.递归的定义最优解。
    	C.以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    	D.根据计算最优值时得到的信息,构造问题的最优解
7.算法实现:最重要的就是确定动态规划三要素-问题的阶段、每个阶段的状态、从前一个阶段转化到后一个阶段之间的递推关系
	(1).推关系必须是从次小的问题开始到较大的问题之间的转化,从这个角度来说,动态规划往往可以用递归程序来实现.
		不过因为递推可以充分利用前面保存的子问题的解来减少重复计算,所以对于大规模问题来说,
		有递归不可比拟的优势,这也是动态规划算法的核心之处
	(2).确定了动态规划的这三要素,整个求解过程就可以用一个最优决策表来描述,最优决策表是一个二维表,
		其中行表示决策的阶段,列表示问题状态,表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值.

二.应用
1.斐波那契数列:
	/**
     * 基本算法：里面有很多重复运算，其最终的递归结果是一个递归树；<br/>
     * 比如计算 5：<br/>
     * 先计算 4、3；<br/>
     * 计算 4 的话需要计算3、2；计算 3 的话计算 2、1；<br/>
     * 计算 3 的话计算 2、1；。。。。<br/>
     * 如此重复计算：3 重复计算了两次，2 重复计算了三次，如果更大的输的话，重复计算的次数将会非常巨大。<br/>
     * 该算法的时间复杂度为指数级的 O(2^N)。
     */
    public static int bruteForce(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return bruteForce(n - 1) + bruteForce(n - 2);
    }
    /**
     * 记忆搜索（备忘录）：在基本算法的思路上将有计算过的数据存储起来，如果有重复计算的，就不递归调用；<br/>
     * 该算法的时间复杂度是：O(N)，空间复杂度是：O(N)-因为需要申请空间来存储计算过的数据
     */
    public static int memorySearch(int n, Map<Integer, Integer> memo) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        if (!memo.containsKey(n)) {
            memo.put(n, memorySearch(n - 1, memo) + memorySearch(n - 2, memo));
        }
        return memo.get(n);
    }

    /**
     * 动态规划法：其实跟记忆搜索类似，记忆搜索是自顶向下解决问题；而动态规划是自下而上解决问题；<br/>
     * 相比于 记忆搜索法，这里动态规划并未使用递归，减少了函数的调用栈空间；同时减少了数据的搜索过程；<br/>
     * 该算法的时间复杂度是：O(N)，空间复杂度是：O(N)-因为需要申请空间来存储计算过的数据
     */
    public static int dynamicProgramming(int n) {
        List<Integer> list = new ArrayList<>(n);
        list.add(0);
        list.add(1);
        for (int i = 2; i <= n; i++) {
            list.add(list.get(i - 1) + list.get(i - 2));
        }
        return list.get(n);
    }


























