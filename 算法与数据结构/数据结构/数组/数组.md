# 一、数组

数组就是 **存储在连续内存空间** 的数据项的集合，目的就是将多个 **具有相同数据类型** 的数据存储在一段连续的内存空间。这样就可以很容易的通过数组的 **首地址** 和 **偏移量（offset）** 计算数组中每一个元素的地址，数组的第一个元素的存储位置是整个数组的首地址（通常由数组的名称表示），默认起始地址的索引为 0，两个索引之间的差值为偏移量；

由 new 分配的数组中的元素将默认初始化为 0（对于数字类型），false（对于布尔值）或null（对于引用类型）。

## 1、数组的优点

- 数组支持随机访问元素。查找的时间复杂度为 。
- 数组具有更好的缓存局部性，可以在很大程度上提高访问速度。
- 数组可以使用一个变量名表示同一数据类型的多个数据项。

## 2、数组的缺点

- 数组一旦声明，就不能更改大小。因为声明时分配给数组的是连续的静态内存空间，要想更改大小，只能由编译器释放原来的内存空间，重新声明。
- 数组的插入和删除时间复杂度为 O(n)，因为数组中的元素被存储在连续的内存位置中，插入和删除的移位操作比较耗时

```java
int[] intArray = new int[10]; // 结合了声明和实例化
// 数组静态初始化
int[] intArray = new int[]{1,2,3,4,5,6,7,8,9,10};
int[] intArray = {1,2,3,4,5,6,7,8,9,10};
```

## 3、数组中间索引

比如二分查找中，定位数组的中间索引
```java
int mid = (l + r) / 2;// 这里,如果在极限情况下,可能出现int溢出

int mid = l + ((r - l) >>> 1);
```

# 二、数据题目

[Leetcode-数组](https://leetcode.com/tag/array/)

## 1、数组的逆置算法

- 1.1、整型数组的逆置算法：
	- 给定整形数组，实现数组的逆置；要求时间复杂度为 $O(N)$，空间复杂度为 O(1)。

		1，2，3，4，5，6，7 ==> 7，6，5，4，3，2，1

	- 实现1：时间复杂度 O(N)， 空间复杂度 O(1)
		```java
		public void swap(int[] array， int i， int j){
			int t = array[i];
			array[i] = array[j];
			array[j] = t;
		}
		public void inverse01(int[] array){
			if(array == null || array.length <= 1){
				return;
			}
			for(int i=0，j=array.length-1; i<j; i++，j--){
				swap(array, i, j);
			}
		}
		```
	- 实现2：省略上述的 j ，循环条件：`i<n/2`， 时间复杂度 O(N)， 空间复杂度 O(1)
		```java
		public void inverse02(int[] array){
			if(array == null || array.length <= 1){
				return;
			}
			int n = array.length;
			int half = n / 2;
			for(int i=0; i< half; i++){
				swap(array, i, n-1-i);
			}
		}
		```
- 1.2、合理利用泛型：时间复杂度 O(N)， 空间复杂度 O(1)
	```java
	public class InverseArray<T> {
		public void printArray(T[] array) {
			for(int i=0; i<array.length; i++){
				System.out.print(array[i]);
			}
			System.out.println();
		}
		public void swap(T[] array， int i， int j){
			T t = array[i];
			array[i] = array[j];
			array[j] = t;
		}
		public void inverse01(T[] array){
			if(array == null || array.length <= 1){
				return;
			}
			for(int i=0，j=array.length-1; i<j; i++，j--){
				swap(array， i， j);
			}
		}				
		public void inverse02(T[] array){
			if(array == null || array.length <= 1){
				return;
			}
			for(int i=0; i< array.length / 2; i++){
				swap(array， i， array.length-1-i);
			}
		}
	}
	```

## 2、旋转数组

### 2.1、描述

给定一个数组，长度为n，要求把后k个元素移动至前面，前n-k个元素移动至后面。比如，n=7，k=3

1，2，3，4，5，6，7 ==> 5，6，7，1，2，3，4
* 翻转前半部分：4 3 2 1 5 6 7；
* 翻转后半部分：4 3 2 1 7 6 5；
* 翻转整个数组：5 6 7 1 2 3 4；

### 2.2、分析

```
hello world ==> world hello
hello world ==> olleh dlrow ==> world hello
reverse(array，0，n-k-1);//反转前一半
reverse(array，n-k，n-1);//反转后一半
reverse(array，0，n-1);//反转整个数组
```
==> 边界考虑：k=0时，不予考虑；k有可能大于n，n=7，k=24，此时k=k%n=24%7=3

### 2.3、实现：时间复杂度 O(N)， 空间复杂度 O(1)

```java
public void swap(int[] array， int i， int j){
	int t = array[i];
	array[i] = array[j];
	array[j] = t;
}		
public void reverse(int[] array， int start， int end){
	if(array == null || array.length <= 1){
		return;
	}
	for(int i=start，j=end; i<j; i++，j--){
		swap(array， i， j);
	}
}		
public void rotate(int[] array， int k) {
	if(k == 0){
		return;
	}
	int n = array.length;
	if(k > n){
		k = k % n;
	}
	reverse(array， 0， n-1-k);
	reverse(array， n-k， n-1);
	reverse(array， 0， n-1);
}
```

### 2.4、扩展：旋转数组的最小数字

[find-minimum-in-rotated-sorted-array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组` [3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为 1

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```
**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**思路分析**：

最直观的解法是 **从头到尾遍历数组一次**，轻轻松松就能找出最小的元素，这种思路的时间复杂度显然是 **O(n)**。

一般的，O(n) 复杂度的优化我们都是往 **二分查找** 这个思路上去考虑的。

设置 `start`, `end` 指针分别指向 `numbers` 数组左右两端，取它们的中点 mid = (start + end ) / 2，然后将 **numbers[mid]** 与 **numbers[end]** 进行对比：

* 当 *numbers[mid] > numbers[end]*：此时，mid 在 **左排序数组** 中，而旋转点 x 一定在 [ mid + 1，end ] 闭区间内，所以接下来的操作是在 [ mid + 1，end ] 区间内寻找旋转点，相应的，改变 start 的值为 mid + 1
* 当 *numbers[mid] < numbers[end]*：mid 在 **右排序数组** 中，而旋转点 x 一定在 [ start，mid ] 闭区间内，所以接下来的操作是在 [ start，mid ] 区间内寻找旋转点，相应的，改变 end 的值为 mid ；
* 当 *numbers[mid] = numbers[end]*：遍历区间是否有序；

**代码实现：**
```java
// 直接遍历
public int minArray(int[] numbers) {
	int result = numbers[0];
	int len = numbers.length;
	for (int i = 0; i < len; i++) {
		if (numbers[i] < result) {
			result = numbers[i];
		}
	}
	return result;
}
```
在上面的基础上利用原数组的有序性，使用二分查找优化
```java
public int minArray(int[] numbers) {
	//设置 start, end 指针分别指向 numbers 数组左右两端
	int start = 0, end = numbers.length - 1;
	//循环判断处理，直到找到结果
	while (start < end) {
		// mid 为中点（这里向下取整，比如 （ 2 + 7 ）/ 2 = 4 )
		int mid = (start + end) / 2;
		//当 mid 点所在元素大于数组末端的元素时，这意味着 [start , mid] 是有序的数组
		if (numbers[mid] > numbers[end]){
			// 所以旋转点在 [ mid + 1, end ] 区间里面 ，更新 start 的位置为 mid + 1
			start = mid + 1;
		}else if (numbers[mid] < numbers[end]){
			// 当 mid 点所在元素小于数组开始端的元素时，这意味着 [mid , end] 是有序的数组
			// 所以旋转点在 [ start, mid ] 区间里面 ，更新 end 的位置为 mid 
			end = mid;
			//思考题🤔：为什么 start 是更新为 mid + 1，而 end 却是更新为 mid
		}else{
			//此时，出现了 numbers[mid] = numbers[end] 的情况，无法判断 
			//    [ start , mid ]  为有序数组区间
			//  还是  [ mid , end ]  为有序数组区间
			//  比如： [1, 0, 1, 1, 1] 和  [1, 1, 1, 0, 1]
			//  所以这里采取遍历的方式
			return findMin(numbers,start,end);
		}
	}
	return numbers[start];
}
public int findMin(int[] numbers,int start,int end){
	int result = numbers[start];
	for(int i = start;i <= end;i++){
		if (numbers[i] < result) {
			result = numbers[i];
		}
	}
	return result;
}
```

## 3、找出有序数组中和为 s 的两个数字

### 3.1、描述

已知一个升序数组array和一个数字s，数组不包含重复数字，在数组中查找两个数，使得它们的和正好为s；如果有多对数字的和等于s，则全部输出

array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11}， s=13

==> [4，9]， [5，8];

### 3.2、平方级算法

时间复杂度 O(N^2)， 空间复杂度 O(1)
```java
public void printResult(int a， int b) {
	System.out.println("[" + a + "，" + b + "]");
}		
public void sumCompare(int[] array， int s){
	int n  = array.length;
	for(int i = 0; i<n;i++){
		for(int j=i+1;j<n;j++){
			if( (array[i] + array[j]) == s){
				printResult(array[i]， array[j]);
				break;
			}
		}
	}
}
```

### 3.3、线性算法：充分利用提供的数组是升序数组

array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11}， s=13

- 分析：利用数组是升序的数组，使用头尾指针来实现
	```
	i = 0， j = array.length-1
	array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11} ==> i=0，	j=6， 1 + 11 = 12
	array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11} ==> i++，	j， 3 + 11 = 14
	array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11} ==> i，j--， 3 + 9 = 12
	array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11} ==> i++，j， 4 + 9 = 13
	array={1 ， 3 ， 4 ， 5 ， 8 ， 9 ， 11} ==> i++，j--， 5 + 8 = 13
	```
- 实现：时间复杂度 O(N)， 空间复杂度 O(1)
	```java
	public void sumCompare1(int[] array， int s) {
		int i = 0;
		int j = array.length - 1;
		while(i < j){
			int sum = array[i] + array[j];
			if(sum == s){
				printResult(array[i] ， array[j]);
				i++;
				j--;
			} else if(sum < s){
				i++;
			} else{
				j--;
			}
		}
	}
	```

### 3.4、二分查找法

时间复杂度 $O(N*logN)$， 空间复杂度 $O(1)$
```java
public void sumCompare2(int[] array， int s){
	int n = array.length;
	for(int i=0;i<n-1;i++){
		int another = s - array[i];
		if(Arrays.binarySearch(array， another) >= i+1){
			printResult(array[i] ， another);
		}
	}
}
```

## 4、和为 s 连续正整数序列

- 4.1、描述：输入一个正整数s，打印出所有和为s的连续正整数序列（至少含有两个数字）

	输入：21

	输出：1 2 3 4 5 6， 6 7 8， 10 11

	依然是双指针！不过，start指针从 1 开始，end指针从 2 开始
	```java
	end=2，start=1	1 + 2 = 3 < 21
	end++			1 + 2 + 3 = 6 < 21 
	end++			1 + 2 + 3 + 4 = 10 < 21
	end++			1 + 2 + 3 + 4 + 5 = 15 < 21
	end++			1 + 2 + 3 + 4 + 5 + 6 = 21 ==21
	end++，start++	2 + 3 + 4 + 5 + 6 + 7 = 27 > 21
	start++			3 + 4 + 5 + 6 + 7 = 25 > 21
	start++			4 + 5 + 6 + 7 = 22 > 21
	start++			5 + 6 + 7 = 18 < 21
	end++			5 + 6 + 7 + 8 = 26 > 21
	start++			6 + 7 + 8 =21 == 21
	...
	start = (s + 1) / 2，算法停止
	```

- 4.2、实现：时间复杂度 O(N)， 空间复杂度 O(1)
	```java
	public void printResult(int start， int end) {
		for(int k = start; k<=end; k++){
			System.out.print(k + " ");
		}
		System.out.println();
	}			
	public void sum(int s) {
		int start = 1，
			end = 2，
			sum = start + end，
			half = (s + 1) / 2;
		while(start < half){
			if(sum == s){
				printResult(start， end);
				sum -= start;
				start++;
				end++;
				sum += end;
			} else if(sum < s){
				end ++;
				sum += end;
			} else{
				sum -= start;
				start ++;
			}
		}
	}
	```

## 5、移除有序数组的重复元素

### 5.1、描述

给定升序数组array，删除重复元素，并返回新的长度len；使得前len个数字升序，并且不得含有重复数字；后面的数字是什么，无所谓

### 5.2、借助ArrayList解决问题

- 思路：
	- 新建list
	- 遍历数组，不断的把不重复的元素添加进list
	- 把list里边的元素拷贝进array
	- 返回list.size()
- 实现：时间复杂度 O(N)， 空间复杂度 O(N)
	```java
	public int remove(int[] nums){
		if(nums == null || nums.length == 0){
			return 0;
		}else if(nums.length == 1){
			return 1;
		}else{
			int i = 0;
			int end = nums.length - 1;
			ArrayList<Integer> list = new ArrayList<Integer>();
			while(i <= end){
				if(i == end){
					list.add(nums[i]);
					i++;
				}else{
					int j  = i + 1;
					if(nums[i] == nums[j]){
						while(j <= end && nums[i] == nums[j]){
							j++;
						}
					}
					list.add(nums[i]);
					i = j;
				}
			}
			for(i=0;i<list.size();i++){
				nums[i] = list.get(i);
			}
			return list.size();
		}
	}
	```
### 5.3、借助ArrayCopy解决问题

时间复杂度 O(N^2)， 空间复杂度 O(N)
```java
public int remove02(int[] nums){
	if(nums==null||nums.length==0){
		return 0;
	}else if(nums.length==1){
		return 1;
	}else{
		int end=nums.length-1;
		for(int i=0;i<=end;i++){
			if(i<end){
				int j=i+1;
				if(nums[i]==nums[j]){
					while(j<=end&&nums[i]==nums[j]){
						j++;
					}
				}
				System.arraycopy(nums， j， nums， i+1， end-j+1);						
				end-=j-i-1;
			}
		}
		return end+1;
	}
}
```
### 5.4、借助临时变量解决问题

时间复杂度 O(N)， 空间复杂度 O(1)
```java
public int remove03(int[] nums){
	if (nums == null || nums.length == 0) {
		return 0;
	} else if (nums.length == 1) {
		return 1;
	} else {
		int temp = nums[0];
		int len = 1;
		for (int i = 1; i < nums.length; i++) {
			if (temp != nums[i]) {
				temp = nums[i];
				nums[len] = nums[i];
				len++;
			}
		}
		return len;
	}
}
```
### 5.5、快慢指针

慢指针slow走在后面，快指针fast走在前面探路，找到一个不重复的元素就告诉slow并让slow前进一步。这样当fast指针遍历完整个数组nums后，`nums[0..slow]`就是不重复元素；时间复杂度O(N)，空间复杂度 O(1)
```java
public int removeDuplicates(int[] nums) {
	if (nums.length == 0) {
		return 0;
	}
	int slow = 0, fast = 0;
	while (fast < nums.length) {
		if (nums[fast] != nums[slow]) {
			slow++;
			// 维护 nums[0..slow] 无重复
			nums[slow] = nums[fast];
		}
		fast++;
	}
	// 数组长度为索引 + 1
	return slow + 1;
}
```

## 6、找出无序数组中和为s的两个数字

数组中无重复元素

### 6.1、暴力解法

```java
public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] == target - nums[i]) {
                return new int[] { i, j };
            }
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

### 6.2、Hash-用空间换时间

为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表；

通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)；

在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回
```java
// 找出一组
public static int[] twoSum(int[] nums, int target) {
	Map<Integer, Integer> map = new HashMap<>();
	for (int i = 0; i < nums.length; i++) {
		int complement = target - nums[i];
		if (map.containsKey(complement)) {
			return new int[]{map.get(complement), i};
		}
		map.put(nums[i], i);
	}
	throw new IllegalArgumentException("No two sum solution");
}
// 找出全部
public static List<int[]> allTwoSum(int[] nums, int target) {
	Map<Integer, Integer> map = new HashMap<>();
	List<int[]> result = new ArrayList<>();
	for (int i = 0; i < nums.length; i++) {
		int complement = target - nums[i];
		if (map.containsKey(complement)) {
			result.add(new int[]{map.get(complement), i});
		}
		map.put(nums[i], i);
	}
	return result;
}
```

## 7、寻找无序数组的第k大元素

https://mp.weixin.qq.com/s/1Y6yLuErGhDE0bA_M8mEjg

## 8、查找一个数组的中位数


## 9、螺旋遍历数组

给定一个二维数组，螺旋遍历
```
1  2  3  4  5
6  7  8  9  10
11 12 13 14 15
16 17 18 19 20
```
遍历二维矩阵结果：`1,2,3,4,5,    10,15,20,   19,18, 17,16,  11,6,    7,8,9,    14,13,12`

**思路：**

1、可以把二维数组的每一层拆解为 上下左右 4条变，按照顺时针遍历，对应的访问顺序是：上 -> 右 -> 下 -> 左，需要注意在每一层遍历的时候需要注意不能重复遍历

**实现：**
```java
public static List<Integer> iterate(int[][] matrix) {
	List<Integer> result = new ArrayList<>();
	if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
		return result;
	}
	// 矩阵的行数
	int m = matrix.length;
	// 矩阵的列数
	int n = matrix[0].length;
	int count = (Math.min(m, n) + 1) / 2;
	for (int i = 0; i < count; i++) {
		// 从左到右遍历：上边
		for (int j = i; j < n - i; j++) {
			result.add(matrix[i][j]);
		}
		// 从上到下遍历：右边
		for (int j = i + 1; j < m - i; j++) {
			result.add(matrix[j][(n - 1) - i]);
		}
		// 从右到左遍历：下边
		for (int j = i + 1; j < n - i; j++) {
			result.add(matrix[(m - 1) - i][(n - 1) - j]);
		}
		// 从下到上遍历：左边
		for (int j = i + 1; j < m - 1 - i; j++) {
			result.add(matrix[(m - 1) - j][i]);
		}
	}
	return result;
}
```

## 10、给定一个数组num和一个val值，移除所有等于val的元素

**要求：**

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素；

**思路：**

快慢指针：如果fast遇到需要去除的元素，则直接跳过，否则就告诉slow指针，并让slow前进一步

**实现：**
```java
public static int removeElement(int[] nums, int val) {
	int len = nums.length;
	int fast = 0, slow = 0;
	while (fast < len) {
		if (nums[fast] != val) {
			nums[slow] = nums[fast];
			slow++;
		}
		fast++;
	}
	return slow;
}
```

## 11、移动0

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序；
- 必须在原数组上操作，不能拷贝额外的数组。
- 尽量减少操作次数。

**思路：**

其实跟上面删除元素类似的；就相当于移除nums中的所有 0，然后再把后面的元素都赋值为 0 即可

**实现：**
```java
public static void moveZeros(int[] nums) {
	int len = nums.length;
	int fast = 0, slow = 0;
	while (fast < len) {
		if (nums[fast] != 0) {
			nums[slow] = nums[fast];
			slow++;
		}
		fast++;
	}
	for (; slow < len; slow++) {
		nums[slow] = 0;
	}
}
```

## 12、合并有序数组

### 12.1、问题描述

给到两个有序数组，将其合并为一个有序数组

合并前：
```
[1,2,4]
[1,3,4]
```
合并后：
```
[1, 1, 2, 3, 4, 4]
```

### 12.2、实现

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
	if (nums1 == null && nums2 == null) {
		return 0D;
	}
	if (nums1 == null || nums1.length == 0) {
		return findMedianSortedArrays(nums2);
	}
	if (nums2 == null || nums2.length == 0) {
		return findMedianSortedArrays(nums1);
	}

	int len1 = nums1.length;
	int len2 = nums2.length;
	int[] res = new int[len1 + len2];

	int idx1 = 0;
	int idx2 = 0;
	int i = 0;
	while (idx1 < len1 && idx2 < len2) {
		if (nums1[idx1] < nums2[idx2]) {
			res[i] = nums1[idx1];
			idx1++;
		} else {
			res[i] = nums2[idx2];
			idx2++;
		}
		i++;
	}
	while (idx1 < len1) {
		res[i] = nums1[idx1];
		idx1++;
		i++;
	}
	while (idx2 < len2) {
		res[i] = nums2[idx2];
		idx2++;
		i++;
	}
	return findMedianSortedArrays(res);
}
/**
	* [1,2,3,4,5] [1,2,3,4]
	*/
public double findMedianSortedArrays(int[] num) {
	int len = num.length;
	int mid = len / 2;
	if (len % 2 != 0) {
		return num[mid];
	} else {
		return (num[mid - 1] + num[mid]) / 2.0;
	}
}
```

### 12.3、扩展题

[median-of-two-sorted-arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

## 13、无序数组找出所有K，K比左边大，比右边小

https://mp.weixin.qq.com/s/5R6Tj4KbCuzTRRwtGL3IcA

### 13.1、问题描述

求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引，要求时间复杂度 O(N)；

```
输入：[2, 3, 1, 8, 9, 20, 12]
输出：3, 4
解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4
```

### 13.2、暴力解法

最简单的思路是：遍历数组，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件，这种解法是 O(N^2) ，不符合题目要求。
```java
for(int i = 0; i < n; i ++) {
	for(int j = 0; j < i; j ++) {
		//左侧是否都比它小
	}
	for(int k = j + 1; k < n; k ++) {
		//右侧是否都比它大
	}
	//若两条件均满足则记录下来
}
```

### 13.3、内循环优化解法

通过分析可以得到，对于每个元素，如果它比左侧最大的值要大，同时比右侧最小的值要小，就满足条件；

那如果有这样两个数组，
- `left_max[i]` 表示原数组 [0, i) 的最大值
- `right_min[i]` 表示原数组 (i, n) 的最小值

内循环就可以通过 `left_max[i] < nums[i] && nums[i] < right_min[i]` 来判断了

### 13.4、实现

```java
public static void find(int[] A) {
	int n = A.length;
	int[] left_max = new int[n];
	int[] right_min = new int[n];
	// 左边最大、右边最小
	for (int i = 0; i < n; i++) {
		left_max[i] = Integer.MIN_VALUE;
		right_min[i] = Integer.MAX_VALUE;
	}
	for (int i = 1; i < n; i++) {
		left_max[i] = Math.max(left_max[i - 1], A[i - 1]);
	}
	for (int i = n - 2; i >= 0; i--) {
		right_min[i] = Math.min(right_min[i + 1], A[i + 1]);
	}

	for (int i = 0; i < n; i++) {
		if (left_max[i] < A[i] && A[i] < right_min[i]) {
			System.out.println(i);
		}
	}
}
```

## 14、统计一个数字在排序数组中出现的次数

### 14.1、题目描述

统计一个数字在排序数组中出现的次数

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

### 14.2、思路

使用二分查找，找到最小的位置和最大的位置，两个索引相减；
- 找左边界的时候，如果mid值等于target，需要判断mid是否为0，或者说是mid-1索引位置的值小于target；
- 找右边界的时候，如果mid值等于target，需要判断mid是否为len-1，或者说是mid+1索引位置的值大于target；

### 14.3、代码实现

```java
public class FindTargetInSortedArray {
    public int search(int[] nums, int target) {
        // 寻找目标值在数组中的开始位置
        int firstIdx = findBeginPosition(nums, target);
        // 寻找目标值在数组中的结束位置
        int lastIdx = findEndPosition(nums, target);
        // 1、如果在数组中找不到目标值的开始位置，同时也找不到目标值的结束位置
        // 那说明目标值不存在，返回 0
        if (firstIdx == -1 && lastIdx == -1) {
            return 0;
        }
        // 2、如果在数组中只能找到目标值的开始位置和结束位置其中一个
        // 那说明目标值的个数只有一个，返回 1
        if (firstIdx == -1 || lastIdx == -1) {
            return 1;
        }
        // 3、如果在数组中可以找到目标值的开始位置，同时也可以找到目标值的结束位置
        // 那说明目标值的个数有多个，返回 lastIdx - firstIdx + 1;
        return lastIdx - firstIdx + 1;

    }
    // 寻找目标值在数组中的开始位置
    private int findBeginPosition(int[] nums, int target) {
        // left 指向当前区间的最左边位置，所以初始化为 0
        int left = 0;
        // right 指向当前区间的最右边位置，所以初始化为 nums.length - 1
        int right = nums.length - 1;
        // 循环进行二分查找，直到左端点位置超过了右端点
        // 或者在循环过程中找到了起始位置
        while (left <= right) {
            // 计算当前区间的中间位置，向下取整
            int mid = (left + right) / 2;
            // 如果中间位置的元素值等于目标值 target
            if (nums[mid] == target) {
                // 并且中间位置 mid 的左边没有元素，即中间位置 mid 为当前区间的起始位置
                // 或者中间位置 mid 的前一个元素小于目标值 target
                // 说明 mid 指向了 target 的起始位置
                if (mid == 0 || nums[mid - 1] < target) {
                    // mid 指向了 target 的起始位置，返回这个结果
                    return mid;
                }
                // 否则，说明 mid 的左边依然有元素值等于 target
                // 那么 mid 就不是 target 的起始位置，需要在 mid 的左边进行查找
                // 所以缩小范围为 left 到 mid - 1
                // 当前区间的左侧为 left，右侧 right = mid - 1
                right = mid - 1;
                // 如果中间位置的元素值大于目标值 target
                // 说明需要在 mid 的左边进行查找
            } else if (nums[mid] > target) {
                // 所以缩小范围为 left 到 mid - 1
                // 当前区间的左侧为 left，右侧 right = mid - 1
                right = mid - 1;
                // 如果中间位置的元素值小于目标值 target
                // 说明需要在 mid 的右边进行查找
            } else {
                // 所以缩小范围为 mid + 1 到 right
                // 当前区间的左侧为 left = mid + 1，右侧 right
                left = mid + 1;
            }
        }
        // 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1
        return -1;
    }
    // 寻找目标值在数组中的结束位置
    private int findEndPosition(int[] nums, int target) {
        // left 指向当前区间的最左边位置，所以初始化为 0
        int left = 0;
        // right 指向当前区间的最右边位置，所以初始化为 nums.length - 1
        int right = nums.length - 1;
        // 循环进行二分查找，直到左端点位置超过了右端点
        // 或者在循环过程中找到了结束位置
        while (left <= right) {
            // 计算当前区间的中间位置，向下取整
            int mid = (left + right) / 2;
            // 如果中间位置的元素值等于目标值 target
            if (nums[mid] == target) {
                // 并且中间位置 mid 的右边没有元素，即中间位置 mid 为当前区间的结束位置
                // 或者中间位置 mid 的后一个元素大于目标值 target
                // 说明 mid 指向了 target 的结束位置
                if (mid == nums.length - 1 || nums[mid + 1] > target) {
                    // mid 指向了 target 的结束位置，返回这个结果
                    return mid;
                }
                // 否则，说明 mid 的右边依然有元素值等于 target
                // 那么 mid 就不是 target 的结束位置，需要在 mid 的右边进行查找
                // 所以缩小范围为 mid + 1 到 right
                // 当前区间的左侧为 left = mid + 1 ，右侧为 right
                left = mid + 1;
                // 如果中间位置的元素值大于目标值 target
                // 说明需要在 mid 的左边进行查找
            } else if (nums[mid] > target) {
                // 所以缩小范围为 left 到 mid - 1
                // 当前区间的左侧为 left，右侧 right = mid - 1
                right = mid - 1;
                // 如果中间位置的元素值小于目标值 target
                // 说明需要在 mid 的右边进行查找
            } else {
                // 所以缩小范围为 mid + 1 到 right
                // 当前区间的左侧为 left = mid + 1，右侧 right
                left = mid + 1;

            }
        }
        // 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1
        return -1;
    }
}
```

## 15、寻找缺失的数字

### 15.1、描述

一个长度为 n - 1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0 ～ n - 1 之内。

在范围 `0 ～ n - 1` 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字

比如：
```
输入: [0,1,3]
输出: 2

输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```
限制：`1 <= 数组长度 <= 10000`

### 15.2、实现

```java
public int missingNumber(int[] nums) {
	// left 指向当前区间的最左边位置，所以初始化为 0
	int left = 0;
	// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1
	int right = nums.length - 1;
	// 循环进行二分查找，直到左端点位置超过了右端点
	while (left <= right) {
		// 计算当前区间的中间位置，向下取整
		int mid = (left + right) / 2;
		// 如果中间位置的元素值等于当前索引的值
		// 那么说明从 left 到 mid 的这些元素都在正确的位置上
		// 即从 left 到 mid 的这些数字都在数组中，没有发生缺失
		// 所以需要在 mid + 1 到 right 这个区间去查找缺失的数字
		if (nums[mid] == mid) {
			// 缩小范围为 mid + 1 到 right
			// 当前区间的左侧为 left = mid + 1，右侧 right
			left = mid + 1;
			// 否则，说明从 left 到 mid 的这些元素，有元素不在正确的位置上
			// 即从 left 到 mid 的这些数字有数字发生缺失
			// 所以需要在 left 到 mid - 1 这个区间去查找缺失的数字
		} else {

			// 所以缩小范围为 left 到 mid - 1
			// 当前区间的左侧为 left，右侧 right = mid - 1
			right = mid - 1;

		}
	}
	// 由于只有一个数字缺失，所以找到的时候，left 指向的那个数字就是，使得后面所有数字与索引不一一对应时的第一个数字
	return left;
}
```

# 三、二维数组

## 1、在二维数组中查找数据

### 1.1、问题描述

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

示例，现有矩阵 matrix 如下：
```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
- 给定 target = 5，返回 true；
- 给定 target = 20，返回 false；

### 1.2、思路

仔细观察矩阵，可以发现：**左下角元素** 为所在**列最大**元素，所在**行最小**元素
- 如果 **左下角元素** 大于了目标值，则目标值一定在该行的上方， **左下角元素** 所在行可以消去。
- 如果 **左下角元素** 小于了目标值，则目标值一定在该列的右方， **左下角元素** 所在列可以消去。

具体操作为从矩阵左下角元素开始遍历，并与目标值对比：
- 当 `matrix[i][j] > target` 时： 行索引向上移动一格（即 `i--`），即消去矩阵第 `i` 行元素；
- 当 `matrix[i][j] < target` 时： 列索引向右移动一格（即 `j++`），即消去矩阵第 `j` 列元素；
- 当 `matrix[i][j] == target` 时： 返回 true；
- 如果越界，则返回 false；

### 1.3、代码实现

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
	//初始化 i 和 j 为数组左下角元素
	int i = matrix.length - 1, 
	int j = 0;
	//如果 i 和 j 没有越界继续判断
	while(i >= 0 && j < matrix[0].length){
		if(matrix[i][j] > target){
			//行索引向上移动一格（即 i-- ），即消去矩阵第 i 行元素
			i--;
		}else if(matrix[i][j] < target){
			//列索引向右移动一格（即 j++ ），即消去矩阵第 j 列元素
			j++;
		}else{
			//找到目标值，直接返回 true
			return true;
		}     
	}
	//没有找到目标值，返回 false
	return false;
}
```