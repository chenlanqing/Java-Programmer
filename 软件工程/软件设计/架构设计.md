# 一、架构基础

架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现

## 1、基本概念

### 1.1、系统与子系统

- 系统：泛指由一群有`关联`的个体组成，根据某种`规则`运作，能完成个别原件不能单独完成的工作的群体。它的意思是“总体”、“整体”或联盟
    - `关联`：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统；
    - `规则`：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式
    - `能力`：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力
- 子系统：由一群有关联的个体所组成的系统，多半会是更大系统中的一部分；

其实子系统的定义和系统的定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统；

按照这个定义，系统和子系统比较容易理解，以微信为例来做一个分析：
- 微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。
- 朋友圈这个系统又包括动态、评论、点赞等子系统。
- 评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。
- 评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis 等是存储系统，但不是业务子系统。

> 一个系统的架构，只包括顶层这一个层级的架构，而不包括下属子系统层级的架构；

### 1.2、模块与组件

- 模块：是一套一致而互相有紧密关联的软件组装。它分别包含了`程序和数据结构`两部分。现代软件开发往往利用模块作为合成单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块
- 组件：定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易的被用于组装应用程序中。

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已；
- 从业务逻辑的角度来拆分系统后，得到的单元就是“模块”；
- 从逻辑角度来拆分系统，得到的单元就是“模块”；
- 从物理的角度来拆分系统后，得到的单元就是“组件”。<br/>
划分模块的主要目的是职责分离；划分组件的主要目的是复用；

作为业务系统的架构师，首先需要思考怎么从业务逻辑的角度把系统拆分成一个个模块角色，其次需要思考怎么从物理部署的角度把系统拆分成组件角色，比如MySQL

### 1.3、框架与架构

- 软件框架通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品；<br>
    关键点：
    - 框架是组件规范，例如MVC；
    - 框架提供基础功能产品，例如SpringMVC是MVC开发框架；
- 软件架构是指软件系统的基础架构，创造这些基础结构的准则，以及对这些结构的描述；

框架和架构的区别还是比较明显的：框架关注的是“规范”，架构关注的是“结构”；框架的英文是 Framework ，架构的英文是 Architecture ；

> 总结：框架是一整套开发规范，架构是某一套开发规范下的具体落地方案，包括各个模块之间的组合关系以及它们协同起来完成功能的运作规则。

### 1.4、软件架构

软件架构指软件系统的顶层（Rank）结构，它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）。
- Rank：它是指软件架构是分层的，对应“系统”和“子系统”的分层关系。通常情况下，只需要关注某一层的架构，最多展示相邻两层的架构，而不需要把每一层的架构全部糅杂在一起。无论是架构设计还是画架构图，都应该采取“自顶向下，逐步细化”的方式
- Role：它是指软件系统包含哪些角色，每个角色都会负责系统的一部分功能；架构设计最重要的工作之一就是将系统拆分为多个角色
- Relation：它是指软件系统的角色之间的关系，对应到架构图中其实就是连接线，角色之间的关系不能乱连，任何关系最后都需要代码来实现；
- Rule：它是指软件系统角色之间如何协作来完成系统功能

在实际工作中，Rank、Role 和 Relation 是通过系统架构图来展示的，而 Rule 是通过系统序列图（System Sequence Diagram）来展示的。

## 2、目的

架构设计的误区：
- 因为架构很重要，所以要做架构设计：不做架构设计系统就跑不起来么？做了架构设计就能提升开发效率么？设计良好的架构能促进业务发展么？
- 不是每个系统都要做架构设计吗？
- 公司流程要求系统开发过程中必须有架构设计
- 为了高性能、高可用、可扩展，所以要做架构设计

架构设计的真正目的：为了解决软件系统复杂度带来的问题。

（1）遵循该原则，新手做到心中有数，而不是一头雾水
- *“这么多需求，从哪里开始下手进行架构设计呢？”*：<br/>
▶ 通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。
- *“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”*：<br/>
▶ 架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。
- *“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”*：<br/>
▶ 理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。

（2）遵循该原则，老手有的放矢，而不是贪大求全。
- *“我们的系统一定要做到每秒 TPS 10 万”*：<br/>
▶ 如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。
- *“淘宝的架构是这么做的，我们也要这么做”*：<br/>
▶ 淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大；
- *“Docker 现在很流行，我们的架构应该将 Docker 应用进来”*：<br/>
▶ Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义

总结：
- 做软件架构是为两件事服务的：业务架构和业务量级，应该算是“软件系统复杂度带来问题”具体化
- 需求驱动架构，架起分析与设计实现的桥梁；
- 架构与开发成本的关系
- 做业务架构必须与其面向的实际应用场景相匹配，由于每个产品或项目的业务场景均有所不同，所以每次做新的软件开发前，必须先设计软件架构，试图不经分析直接套用先前的架构方案，十有八九会让当前的系统在某个点上报出大问题导致推翻重来，更不要说直接拿别人的现成架构方案了

## 3、复杂度

前面提到架构是为了解决软件系统复杂度带来的问题，那么软件系统的复杂度的来源有哪些？

### 3.1、高性能

软件系统中高性能带来的复杂度主要体现在两方面：
- 一方面是单台计算机内部为了高性能带来的复杂度；
- 另一方面是多台计算机集群为了高性能带来的复杂度。

**单机复杂度**

计算机内部复杂度最关键的地方就是操作系统；操作系统和性能最相关的就是进程和线程；

多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 种：
- SMP（Symmetric Multi-Processor，对称多处理器结构）；
- NUMA（Non-Uniform Memory Access，非一致存储访问结构）；
- MPP（Massive Parallel Processing，海量并行处理结构）。<br/>
其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。

如果要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂

**集群的复杂度**

要支持支付宝支付和微信红包这种复杂的业务，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能；通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务

（1）任务分配：意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。

![](image/架构-任务分配器扩展.png)

1 台服务器演变为 2 台服务器后，架构上明显要复杂多了，主要体现在：
- 需要增加一个任务分配器，这个分配器可能是硬件网络设备（例如，F5、交换机等），可能是软件网络设备（例如，LVS），也可能是负载均衡软件（例如，Nginx、HAProxy），还可能是自己开发的系统。选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面的因素。
- 任务分配器和真正的业务服务器之间有连接和交互（即图中任务分配器到业务服务器的连接线），需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。
- 任务分配器需要增加分配算法。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。如果按照服务器的负载进行分配，则业务服务器还要能够上报自己的状态给任务分配器。

上面这个架构只是最简单地增加 1 台业务机器，假设单台业务服务器每秒能够处理 5000 次业务请求，那么这个架构理论上能够支撑 10000 次请求，实际上的性能一般按照 8 折计算，大约是 8000 次左右。如果我们的性能要求继续提高，假设要求每秒提升到 10 万次，上面这个架构会出现什么问题呢？是不是将业务服务器增加到 25 台就可以了呢？显然不是，因为随着性能的增加，任务分配器本身又会成为性能瓶颈，当业务请求达到每秒 10 万次的时候，单台任务分配器也不够用了，任务分配器本身也需要扩展为多台机器；

![](image/架构-任务分配器扩展.png)

（2）任务分解：

为了能够继续提升性能，我们需要采取第二种方式：任务分解。通过这种任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），那为何通过任务分解就能够提升性能呢？
- *简单的系统更加容易做到高性能*：系统的功能越简单，影响性能的点就越少，就更加容易进行有针对性的优化。而系统很复杂的情况下，首先是比较难以找到关键性能点，因为需要考虑和验证的点太多；其次是即使花费很大力气找到了，修改起来也不容易，因为可能将 A 关键性能点提升了，但却无意中将 B 点的性能降低了，整个系统的性能不但没有提升，还有可能会下降。
- *可以针对单个任务进行扩展*：当各个逻辑任务分解到独立的子系统后，整个系统的性能瓶颈更加容易发现，而且发现后只需要针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多；

既然将一个大一统的系统分解为多个子系统能够提升性能，那是不是划分得越细越好呢？其实不然，这样做性能不仅不会提升，反而还会下降，最主要的原因是如果系统拆分得太细，为了完成某个业务，系统间的调用次数会呈指数级别上升，而系统间的调用通道目前都是通过网络传输的方式，性能远比系统内的函数调用要低得多；

任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。

### 3.2、

## 6、架构图

- [常见架构图](https://mp.weixin.qq.com/s/6Jh0EHdbjZb47DCsplwS_A)

常见架构图：
- 业务架构图
- 功能架构图
- 产品架构图
- 应用架构图
- 系统架构图
- 技术架构图
- 信息架构图
- 数据架构图


# 参考资料

* [凤凰架构-构建可靠的大型分布式系统](http://icyfenix.cn/)
* [架构的演进](https://www.cnblogs.com/hafiz/p/9222973.html)
* [如何画架构图](https://developer.aliyun.com/article/765140?spm=a2c6h.12873639.0.0.75482c6dlmkDa6)
* [分布式架构知识体系](https://developer.aliyun.com/article/721007?spm=a2c6h.12873639.0.0.75482c6dlmkDa6)
* [架构设计实践](https://www.infoq.cn/article/RQDwWxDcwbxtwU8LBFSG)
* [如何做技术选型](https://juejin.im/post/6870288195674718222)
* [如何画架构图](https://juejin.cn/post/6844904127856640014)
* [软件架构-RoadMap](https://roadmap.sh/software-architect)
* [COLA架构-整洁面向对象分层架构-应用案例](https://github.com/alibaba/COLA)
* [C4模型](https://c4model.com/)
* [《架构整洁之道》](https://github.com/leewaiho/Clean-Architecture-zh)
