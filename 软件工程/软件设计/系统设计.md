# 一、系统设计

- [系统设计面试题](https://mp.weixin.qq.com/s/zr4dkkpy5_QnifTPA7XkdQ)
- [系统设计入门](https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md)
- [系统设计](https://github.com/ksfzhaohui/blog/tree/master/java8)
- [领域驱动模型在互联网业务中运用](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)
- [system-design-interview](https://github.com/summerjava/system-design-interview)
- [grokking-modern-system-design-interview](https://www.educative.io/courses/grokking-modern-system-design-interview-for-engineers-managers)
- [grokking the system design interview]
- [如何面试系统设计](https://blog.acecodeinterview.com/intro/)
- [System Design Cheatsheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
- [系统设计路线图](https://roadmap.sh/system-design)
- [如何拿捏系统设计](https://mp.weixin.qq.com/s/fTjEWX0AkPH7gf6grSfjPA)
- [System Design 101](https://github.com/ByteByteGoHq/system-design-101)
- [系统设计案例](https://github.com/Admol/SystemDesign)
- [awesome-Interesting](https://github.com/sindresorhus/awesome)
- [RateLimiter Design](https://medium.com/javarevisited/system-design-basics-rate-limiter-249013cf5be4)

# 二、高并发系统设计

## 1、通用设计方法

应对高并发大流量时，归纳起来共有三种方法：
- Scale-out（横向扩展）：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。
- 缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。
- 异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。

### 1.1、Scale-out

将类似追逐摩尔定律不断提升 CPU 性能的方案叫做 Scale-up（纵向扩展），把类似 CPU 多核心的方案叫做 Scale-out
- Scale-up 通过购买性能更好的硬件来提升系统的并发处理能力；
- Scale-out 则是另外一个思路，它通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击；

一般来讲，在系统设计初期会考虑使用 Scale-up 的方式，因为这种方案足够简单，所谓能用堆砌硬件解决的问题就用硬件来解决，但是当系统并发超过了单机的极限时，就要使用 Scale-out 的方式。

Scale-out 方式引入的一些问题：
- 如果某个节点出现故障如何保证整体可用性？
- 当多个节点有状态需要同步时如何保证状态信息在不同节点的一致性？
- 如何做到使用方无感知的增加和删除节点？

### 1.2、缓存

从操作系统到浏览器，从数据库到消息队列，任何略微复杂的服务和组件中你都可以看到缓存的影子

在整个计算机体系中磁盘是最慢的一环，甚至比其它的组件要慢几个数量级。因此我们通常使用以内存作为存储介质的缓存，以此提升性能。

可以将任何降低响应时间的中间存储都称为缓存

### 1.3、异步处理

异步调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。

### 1.4、总结

罗马不是一天建成的，系统的设计也是如此，一般系统的演进过程应该遵循下面的思路：
- 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。
- 随着流量的增加和业务的变化修正架构中存在问题的点，如单点问题、横向扩展问题、性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。
- 当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。

高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的。

## 2、架构分层

[什么是分层架构](./架构设计.md#821分层架构)

## 3、系统设计目标

高并发系统设计的三大目标：高性能、高可用、可扩展

### 3.1、如何提升系统性能

[如何做性能优化](../../性能优化/性能优化.md)

高并发下的性能优化
- 提高系统的处理核心数，就是增加系统的并行处理能力；在评估系统性能时通常需要做压力测试，目的就是找到系统的“拐点”，从而知道系统的承载能力，也便于找到系统的瓶颈，持续优化系统性能
- 减少单次任务响应时间：
    - CPU 密集型系统中，需要处理大量的 CPU 运算，那么选用更高效的算法或者减少运算次数就是这类系统重要的优化手段
    - IO 密集型系统指的是系统的大部分操作是在等待 IO 完成，这里 IO 指的是磁盘 IO 和网络 IO。根据不同的场景进行采用不同的优化措施；

# 三、高可用系统设计

- [如何做到高可用](https://highscalability.com/)

- 降级：多级降级
    - 主动降级：开关推送
    - 被动降级：超时降级、异常降级、失败率、熔断保护

- 限流：压测确定限流阈值、动态调整限流
    - 网关层限流：Nginx、Redis+Lua
    - 业务层限流：本地限流（Guava）、分布式限流（sentinel）

- 弹性计算：全链路都要弹性计算（K8S+Docker）

- 流量切换：多机房环境
    - DNS：域名切换入库、Client端流量调度
    - 虚IP：HaProxy、LVS负载均衡
    - 应用层：Nginx + 服务网关

- 回滚：
    - 版本控制：配置中心、CICD Pipeline

# 其他

有限状态机

[Spring statemachine](https://docs.spring.io/spring-statemachine/docs/4.0.0/reference/index.html)

![dst_egpm](image/dst_egpm.png)

使用在线工具[domain-story-modeler](https://github.com/WPS/domain-story-modeler)，可以在线实践domain storytelling。

对象间关系：
- 一个对象为另一个对象的状态变更提供数据；
- 一个对象的状态变更导致另一个对象的状态变更；

# 七、重构

1）重构应该是随时随地进行。不应该为重构而重构。
2）三次法则：第一次做某件事只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做 第三次 再做类似的事情，就应该重构了。
3）添加功能
4）修复bug
5）复审代码，即Code Review时候




