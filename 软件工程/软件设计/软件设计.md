
## 1、什么是软件设计

关注长期变化的软件设计，软件设计，是一门关注长期变化的学问

软件最核心的三个部分：模型、接口和实现

软件设计应该包含两部分：
- 模型：是一个软件的骨架，是一个软件之所以是这个软件的核心。
  - 模型的粒度可大可小；
  - 常说的“高内聚、低耦合”指的就是对模型的要求，一个好的模型可以有效地隐藏细节，让开发者易于理解；
  - 模型是分层的，可以不断地叠加，基于一个基础的模型去构建上一层的模型，计算机世界就是这样一点点构建出来的；
- 规范：限定了什么样的需求应该以怎样的方式去完成。它对于维系软件长期演化至关重要，关于规范，常见的两种问题是：
  - 一个项目缺乏显式的、统一的规范；
  - 规范不符合软件设计原则。

模型与规范，二者相辅相成。一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型

> 软件设计，应该包括模型和规范；

### 1.1、分解

软件开发就是解决问题，最常见的解决问题的思路是：分而治之；那么如何分解和组合，是软件设计需要考虑的问题

常见的分解问题就是分解的粒度太大了，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫**分离关注点**；

分离关注点很重要：
- 一方面，不同的关注点混在一起会带来许多问题；
- 另一方面，分离关注点有助于我们发现不同模块的共性，更好地进行设计；

常见关注点混淆是：技术和业务的混淆；

把业务处理和技术实现混在一起，类似问题比较多。比如我们经常问怎么处理分布式事务，怎么做分库分表等。其实，你更应该问的是，我的业务需要分布式事务吗？我是不是业务划分没有做清楚，才造成了数据库的压力？

### 1.2、可测试性

要保证每个小模块的正确性，就要保证每个模块在开发阶段能够测试，而想要每个模块能够测试，在设计过程中，就要保证每个模块是可以测试的，而这就是可测试性。

如何在设计中考虑可测试性呢？其实就是要在设计时想一下，这个函数/模块/系统要怎么测，因此在设计一个函数/模块/系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖

如何做：
- 一方面，尽可能地给每个模块更多的测试，使构成系统的每个模块尽可能稳定，把集成测试环境更多地留作公共的验收资源。
- 另一方面，尽可能搭建本地的集成测试环境，周边的系统可以采用模拟服务的方案

在软件开发过程中考虑测试，实际上是思考软件的质量问题

## 2、如何了解一个软件的设计

如果接到一个新项目，阅读源码是必经的一步，却不应该是你的第一步。应该先从了解软件的设计开始

了解一个软件的设计可以从三个部分着手：模型、接口和实现
- 理解一个设计中的模型，可以帮助建立起对这个软件整体的认知；而理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用；
- 如果想深入源码，去了解一个软件，接口是一个很好的指向标。可以从一个接口进入到软件中，看它是怎样完成各种基本功能的；看接口的一个方法是找主线，看风格。
  - 先找到一条功能主线，对项目建立起结构性的了解。从文档起步，沿着主线梳理项目相关接口；
  - 有了主线之后，再沿着主线把相关接口梳理出来；维护项目的统一风格；
- 实现是指软件提供的模型和接口在内部是如何实现的，这是软件能力得以发挥的根基；如何找到实现，需要找到两个关键点：软件的结构和关键的技术：
  - 了解软件的结构，其实，就是把分层的模型展开，看下一层的模型。一方面，你要知道这个层次给你提供了怎样的模型，另一方面，你要带着自己的问题去了解这些模型为什么要这么设计；
  - 关键技术就是让这个软件与众不同的地方；

模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整；所以一般讨论设计的顺序：**先模型，再接口，最后是实现**

比如了解操作系统，就知道它有内存管理、进程调度、文件系统等模块。可以按照模型、接口和实现去理解每个模块，以进程管理为例：
- 进程管理的核心模型就包括进程模型和调度算法；
- 它的接口就包括，进程的创建、销毁以及调度算法的触发等；
- 不同调度算法就是一个个具体的实现；

## 3、程序设计语言

我们学习程序设计语言主要是为了学习程序设计语言提供的编程模型

### 3.1、程序设计语言模型的演变过程

主流路径：
- 汇编语言-引入了助记符；
- 高级程序设计语言：
  - Fortran：为程序语言设计发展奠定了基础；
  - C语言：屏蔽了计算机硬件的的诸多细节；
  - C++：兼容了C语言；增加了面向对象；
  - Java：支持面向对象；垃圾回收机制（上面三种语言都存在内存管理问题）；

次主流路径-函数式编程：
- 代表：LISP；
- 硬件因素-多核，打破了只习惯利用一个CPU写程序的传统方式；
- 探索：声明式编程、DSL等；
  
其他语言-动态语言：Perl、Python、PHP

> 一切语法都是语法糖

### 3.2、程序语言的接口

封装程序库，可以成为你软件设计进阶的发力点；因为程序库是为了消除重复而出现的。而消除重复，也是软件设计的初衷

如果通用性足够好，一些经过大量实践验证过的程序库甚至会变成语言的语法，而一些语法解决得不够好的地方，又会出现新的程序库去探索新的解决方案；语言设计就是程序库设计，程序库设计就是语言设计
- 一切有生命力的语言都会不断改善自己的语法，某些好用的程序库就可以转正成为语法。比如，Java 引入 Lambda，支持函数式编程；C++ 引入类型推演，简化了代码编写

### 3.3、程序语言的实现

程序设计语言的实现就是支撑程序运行的部分：运行时，也称之为运行时系统，或运行时环境，它主要是为了实现程序设计语言的执行模型；

运行时，是我们做软件设计的地基；做设计真正的地基，并不是程序设计语言，而是运行时，有了对于运行时的理解，我们甚至可以做出语言本身不支持的设计；

像Java语言，JVM就是运行时；程序运行时中，`程序如何运行`是一条主线，将各种知识贯穿起来
- 了解可执行文件结构；（JVM）对Java来说是class文件的结构；
- 了解程序如何加载；（JVM）加载器的运作和内存的布局；
- 了解指令如何执行；（JVM）运行机制和字节码的执行；
- 了解更多信息；（JVM）GC、语法、程序库；

运行时编程接口：
- 以程序库的方式提供；
- 以规范的形式提供；


意图和实现分离开来：
- 意图：做什么；实现：怎么做
- 意图可以理解成方法命名，实现可以理解成方法里的每行代码。
- 意图可以理解成接口定义，实现可以理解成实现类。

## 4、编程范式

编程范式（Programming paradigm），指的是程序的编写模式。使用了什么编程范式，通常意味着，你主要使用的是什么样的代码结构

现在主流的编程范式主要有三种：
- 结构化编程（structured programming）：通过一些结构化的控制结构进行程序的构建，最典型的结构化编程语言是 C 语言
- 面向对象编程（object-oriented programming）；是现在最主流的编程范式，它的核心概念就是对象，典型是Java语言；
- 函数式编程（functional programming）；函数式编程的代表性语言应该是 LISP

编程范式不仅仅是提供了一个个的概念，更重要的是，它对程序员的能力施加了约束。
- 结构化编程，限制使用 goto 语句，它是对程序控制权的直接转移施加了约束。.
- 面向对象编程，限制使用函数指针，它是对程序控制权的间接转移施加了约束。
- 函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。

### 4.1、结构化编程

C 语言就是一种典型的结构化编程语言；

结构化编程是相对于非结构化编程来讲的，它带来一个比较重要的方面是功能分解，也就是将大问题拆分成可以解决的小问题，这一思想影响深远，是我们做设计的根基所在；

结构编程的不足之处：
- 抽象级别不够高；
- 模块间依赖关系过强；
- 可测试性不够；

> 结构化编程不能有效地隔离变化，需要与其他编程范式配合使用。

### 4.2、面向对象编程

封装、多态、继承

**封装**

封装，是面向对象的根基；封装的重点在于对象提供了哪些行为，而不是有哪些数据； 

设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter 和 setter 是暴露实现细节的，尽可能不提供，尤其是 setter。

封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露

有了封装，对象就成了一个个可以组合的单元，也形成了一个个可以复用的单元。面向对象编程的思考方式就是组合这些单元，完成不同的功能

> 基于行为进行封装，不要暴露实现细节，最小化接口暴露

这里有一点需要注意的是，我们不需要把Java中一些POJO和实际业务对象混淆了

**继承**

类型：
- 实现继承：站在子类的角度向上看，面对的是子类；
- 接口继承：站在父类的角度往下看，面对的是父类；

误区：把实现继承当成一种代码复用的方式

通用原则：组合优于继承

**多态**

多态（Polymorphism）一个接口，多种形态；

多态需要构建出一个抽象，构建抽象，需要找出不同事物的共同点；

理解多态，还要理解好接口。它是将变的部分和不变的部分隔离开来，在二者之间建立起一个边界。一个重要的编程原则就是面向接口编程，这是很多设计原则的基础

### 4.3、函数式编程

函数式编程是一种编程范式，它提供给我们的编程元素就是函数；在函数式编程中，函数是一等公民，一等公民指：
- 它可以按需创建；
- 它可以存储在数据结构中；
- 它可以当作实参传给另一个函数；
- 它可以当作另一个函数的返回值、

**组合性**

在函数式编程中，有一类比较特殊的函数，它们可以接收函数作为输入，或者返回一个函数作为输出。这种函数叫做高阶函数（High-order function），高阶函数有什么用呢？它的一个重要作用在于，我们可以用它去做行为的组合；

函数式编程中，还有一个重要的体系，就是列表转换的思想，将很多操作分解成若干转换的组合。最基础的三个转换是：map、filter 和 reduce，更多的转换操作都可以基于这三个转换完成；
- map：把一组数据通过函数映射成另一组数据；
- filter：把一组数据按照条件过滤只留下满足条件的数据；
- reduce：把一组数据按照某种规则规约为一个数据

面向对象和函数式编程都提到了组合性，不同的是，面向对象关键在于结构的组合，而函数式编程在于函数接口的组合；

**不变性**

函数式编程的不变性主要体现在值和纯函数上。
- 值，可以将它理解为一个初始化之后就不再改变的量，换句话说，当你使用一个值的时候，值是不会变的。
- 纯函数，是符合下面两点的函数：
  - 对于相同的输入，给出相同的输出；
  - 没有副作用。

> 把值和纯函数合起来看，值保证不会显式改变一个量，而纯函数保证的是，不会隐式改变一个量。

编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法

## 5、设计原则与模式

主要：[SOLID原则](设计模式#2面向对象设计原则)，包含如下：
- 单一职责原则（Single responsibility principle，SRP）
- 开放封闭原则（Open–closed principle，OCP）
- Liskov替换原则（Liskov substitution principle，LSP）
- 接口隔离原则（Interface segregation principle，ISP）
- 依赖倒置原则（Dependency inversion principle，DIP）

### 5.1、单一职责原则

理解单一职责原则本质上就是要理解分离关注点。

如何理解好单一职责：
- 我们需要理解封装，知道要把什么样的内容放到一起；
- 我们需要理解分离关注点，知道要把不同的内容拆分开来；
- 我们需要理解变化的来源，知道把不同行为者负责的代码放到不同的地方。

单一职责原则讲的并不是一个类只做一件事，它的关注点在于变化；变化仍在，但是我们可以通过单一职责原则减少变化带来的影响；

> 应用单一职责原则衡量模块，粒度越小越好。

### 5.2、开发封闭原则

应该对扩展开放，对修改封闭

开放封闭原则描述的是一个结果，就是可以不修改代码而仅凭扩展就完成新功能。但是，这个结果的前提是要在软件内部留好扩展点，而这正是需要去设计的地方。因为每一个扩展点都是一个需要设计的模型

构建模型的难点，首先在于分离关注点，其次在于找到共性；跟多态结合

> 设计扩展点，迈向对修改关闭、对扩展开放；

### 5.3、Liskov替换原则

一般满足 Liskov 原则的，都有统一处理的接口，如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了 LSP

要满足 LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足 IS-A 的关系。LSP让我们的注意力集中在父类上

> 用父类的角度去思考，设计行为一致的子类。

### 5.4、接口隔离原则

接口最小化原则，强调的是一个接口拥有的行为应该尽可能的小，尽量细化接口，使类具有很好的可读性、可扩展性和可维护性；接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别：单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一；

在做接口设计时，应该关注不同的使用者；

> 识别对象的不同角色，设计小接口

### 5.5、依赖倒置原则

高层模块不应依赖于低层模块，二者应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。

通过DIP推导的一些编码规则：
- 任何变量都不应该指向一个具体类；
- 任何类都不应继承自具体类；
- 任何方法都不应该改写父类中已经实现的方法；

所谓倒置，就是把这种习惯性的做法倒过来，让高层模块不再依赖于低层模块

### 5.6、如何理解和学习设计模式

所谓模式，其实就是针对的就是一些普遍存在的问题给出的解决方案

用数学来比喻，设计原则就像公理，它们是我们讨论各种问题的基础，而设计模式则是定理，它们是在特定场景下，对于经常发生的问题给出的一个可复用的解决方案；

学习设计模式不仅仅要学习代码怎么写，更重要的是要了解模式的应用场景；设计模式背后其实是各种设计原则，在实际的工作中，更应该按照设计原则去写代码，不一定要强求设计模式，而按照设计原则去写代码的结果，往往是变成了某个模式


