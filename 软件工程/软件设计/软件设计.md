
## 1、什么是软件设计

关注长期变化的软件设计，软件设计，是一门关注长期变化的学问

软件最核心的三个部分：模型、接口和实现

软件设计应该包含两部分：
- 模型：是一个软件的骨架，是一个软件之所以是这个软件的核心。
  - 模型的粒度可大可小；
  - 常说的“高内聚、低耦合”指的就是对模型的要求，一个好的模型可以有效地隐藏细节，让开发者易于理解；
  - 模型是分层的，可以不断地叠加，基于一个基础的模型去构建上一层的模型，计算机世界就是这样一点点构建出来的；
- 规范：限定了什么样的需求应该以怎样的方式去完成。它对于维系软件长期演化至关重要，关于规范，常见的两种问题是：
  - 一个项目缺乏显式的、统一的规范；
  - 规范不符合软件设计原则。

模型与规范，二者相辅相成。一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型

> 软件设计，应该包括模型和规范；软件设计就是软件建模的过程，通过软件建模工具，将软件模型画出来，实现软件设计。

### 1.1、分解

软件开发就是解决问题，最常见的解决问题的思路是：分而治之；那么如何分解和组合，是软件设计需要考虑的问题

常见的分解问题就是分解的粒度太大了，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫**分离关注点**；

分离关注点很重要：
- 一方面，不同的关注点混在一起会带来许多问题；
- 另一方面，分离关注点有助于我们发现不同模块的共性，更好地进行设计；

常见关注点混淆是：技术和业务的混淆；

把业务处理和技术实现混在一起，类似问题比较多。比如我们经常问怎么处理分布式事务，怎么做分库分表等。其实，你更应该问的是，我的业务需要分布式事务吗？我是不是业务划分没有做清楚，才造成了数据库的压力？

### 1.2、可测试性

要保证每个小模块的正确性，就要保证每个模块在开发阶段能够测试，而想要每个模块能够测试，在设计过程中，就要保证每个模块是可以测试的，而这就是可测试性。

如何在设计中考虑可测试性呢？其实就是要在设计时想一下，这个函数/模块/系统要怎么测，因此在设计一个函数/模块/系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖

如何做：
- 一方面，尽可能地给每个模块更多的测试，使构成系统的每个模块尽可能稳定，把集成测试环境更多地留作公共的验收资源。
- 另一方面，尽可能搭建本地的集成测试环境，周边的系统可以采用模拟服务的方案

在软件开发过程中考虑测试，实际上是思考软件的质量问题

### 1.3、软件设计文档

软件设计文档就是架构师的主要工作成果，它需要阐释这节课开头提到的各种诉求，描绘软件的完整蓝图，而软件设计文档的主要组成部分就是软件模型。

软件设计过程可以拆分成需求分析、概要设计和详细设计三个阶段：
-**需求分析阶段**，主要是通过用例图来描述系统的功能与使用场景；对于关键的业务流程，可以通过*活动图*描述；如果在需求阶段就提出要和现有的某些子系统整合，那么可以通过*时序图*描述新系统和原来的子系统的调用关系；可以通过简化的*类图*进行领域模型抽象，并描述核心领域对象之间的关系；如果某些对象内部会有复杂的状态变化，比如用户、订单这些，可以用*状态图*进行描述；
- **概要设计阶段**，通过部署图描述系统最终的物理蓝图；通过组件图以及组件时序图设计软件主要模块及其关系；还可以通过组件活动图描述组件间的流程逻辑。
- **详细设计阶段**，主要输出的就是类图和类的时序图，指导最终的代码开发，如果某个类方法内部有比较复杂的逻辑，那么可以将这个方法的逻辑用活动图进行描述

## 2、如何了解一个软件的设计

如果接到一个新项目，阅读源码是必经的一步，却不应该是你的第一步。应该先从了解软件的设计开始

了解一个软件的设计可以从三个部分着手：模型、接口和实现
- 理解一个设计中的模型，可以帮助建立起对这个软件整体的认知；而理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用；
- 如果想深入源码，去了解一个软件，接口是一个很好的指向标。可以从一个接口进入到软件中，看它是怎样完成各种基本功能的；看接口的一个方法是找主线，看风格。
  - 先找到一条功能主线，对项目建立起结构性的了解。从文档起步，沿着主线梳理项目相关接口；
  - 有了主线之后，再沿着主线把相关接口梳理出来；维护项目的统一风格；
- 实现是指软件提供的模型和接口在内部是如何实现的，这是软件能力得以发挥的根基；如何找到实现，需要找到两个关键点：软件的结构和关键的技术：
  - 了解软件的结构，其实，就是把分层的模型展开，看下一层的模型。一方面，你要知道这个层次给你提供了怎样的模型，另一方面，你要带着自己的问题去了解这些模型为什么要这么设计；
  - 关键技术就是让这个软件与众不同的地方；

模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整；所以一般讨论设计的顺序：**先模型，再接口，最后是实现**

比如了解操作系统，就知道它有内存管理、进程调度、文件系统等模块。可以按照模型、接口和实现去理解每个模块，以进程管理为例：
- 进程管理的核心模型就包括进程模型和调度算法；
- 它的接口就包括，进程的创建、销毁以及调度算法的触发等；
- 不同调度算法就是一个个具体的实现；

## 3、程序设计语言

我们学习程序设计语言主要是为了学习程序设计语言提供的编程模型

### 3.1、程序设计语言模型的演变过程

主流路径：
- 汇编语言-引入了助记符；
- 高级程序设计语言：
  - Fortran：为程序语言设计发展奠定了基础；
  - C语言：屏蔽了计算机硬件的的诸多细节；
  - C++：兼容了C语言；增加了面向对象；
  - Java：支持面向对象；垃圾回收机制（上面三种语言都存在内存管理问题）；

次主流路径-函数式编程：
- 代表：LISP；
- 硬件因素-多核，打破了只习惯利用一个CPU写程序的传统方式；
- 探索：声明式编程、DSL等；
  
其他语言-动态语言：Perl、Python、PHP

> 一切语法都是语法糖

### 3.2、程序语言的接口

封装程序库，可以成为你软件设计进阶的发力点；因为程序库是为了消除重复而出现的。而消除重复，也是软件设计的初衷

如果通用性足够好，一些经过大量实践验证过的程序库甚至会变成语言的语法，而一些语法解决得不够好的地方，又会出现新的程序库去探索新的解决方案；语言设计就是程序库设计，程序库设计就是语言设计
- 一切有生命力的语言都会不断改善自己的语法，某些好用的程序库就可以转正成为语法。比如，Java 引入 Lambda，支持函数式编程；C++ 引入类型推演，简化了代码编写

### 3.3、程序语言的实现

程序设计语言的实现就是支撑程序运行的部分：运行时，也称之为运行时系统，或运行时环境，它主要是为了实现程序设计语言的执行模型；

运行时，是我们做软件设计的地基；做设计真正的地基，并不是程序设计语言，而是运行时，有了对于运行时的理解，我们甚至可以做出语言本身不支持的设计；

像Java语言，JVM就是运行时；程序运行时中，`程序如何运行`是一条主线，将各种知识贯穿起来
- 了解可执行文件结构；（JVM）对Java来说是class文件的结构；
- 了解程序如何加载；（JVM）加载器的运作和内存的布局；
- 了解指令如何执行；（JVM）运行机制和字节码的执行；
- 了解更多信息；（JVM）GC、语法、程序库；

运行时编程接口：
- 以程序库的方式提供；
- 以规范的形式提供；


意图和实现分离开来：
- 意图：做什么；实现：怎么做
- 意图可以理解成方法命名，实现可以理解成方法里的每行代码。
- 意图可以理解成接口定义，实现可以理解成实现类。

## 4、编程范式

编程范式（Programming paradigm），指的是程序的编写模式。使用了什么编程范式，通常意味着，你主要使用的是什么样的代码结构

现在主流的编程范式主要有三种：
- 结构化编程（structured programming）：通过一些结构化的控制结构进行程序的构建，最典型的结构化编程语言是 C 语言
- 面向对象编程（object-oriented programming）；是现在最主流的编程范式，它的核心概念就是对象，典型是Java语言；
- 函数式编程（functional programming）；函数式编程的代表性语言应该是 LISP

编程范式不仅仅是提供了一个个的概念，更重要的是，它对程序员的能力施加了约束。
- 结构化编程，限制使用 goto 语句，它是对程序控制权的直接转移施加了约束。.
- 面向对象编程，限制使用函数指针，它是对程序控制权的间接转移施加了约束。
- 函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。

### 4.1、结构化编程

C 语言就是一种典型的结构化编程语言；

结构化编程是相对于非结构化编程来讲的，它带来一个比较重要的方面是功能分解，也就是将大问题拆分成可以解决的小问题，这一思想影响深远，是我们做设计的根基所在；

结构编程的不足之处：
- 抽象级别不够高；
- 模块间依赖关系过强；
- 可测试性不够；

> 结构化编程不能有效地隔离变化，需要与其他编程范式配合使用。

### 4.2、面向对象编程

封装、多态、继承

**封装**

封装，是面向对象的根基；封装的重点在于对象提供了哪些行为，而不是有哪些数据； 

设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter 和 setter 是暴露实现细节的，尽可能不提供，尤其是 setter。

封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露

有了封装，对象就成了一个个可以组合的单元，也形成了一个个可以复用的单元。面向对象编程的思考方式就是组合这些单元，完成不同的功能

> 基于行为进行封装，不要暴露实现细节，最小化接口暴露

这里有一点需要注意的是，我们不需要把Java中一些POJO和实际业务对象混淆了

**继承**

类型：
- 实现继承：站在子类的角度向上看，面对的是子类；
- 接口继承：站在父类的角度往下看，面对的是父类；

误区：把实现继承当成一种代码复用的方式

通用原则：组合优于继承

**多态**

多态（Polymorphism）一个接口，多种形态；

多态需要构建出一个抽象，构建抽象，需要找出不同事物的共同点；

理解多态，还要理解好接口。它是将变的部分和不变的部分隔离开来，在二者之间建立起一个边界。一个重要的编程原则就是面向接口编程，这是很多设计原则的基础

### 4.3、函数式编程

函数式编程是一种编程范式，它提供给我们的编程元素就是函数；在函数式编程中，函数是一等公民，一等公民指：
- 它可以按需创建；
- 它可以存储在数据结构中；
- 它可以当作实参传给另一个函数；
- 它可以当作另一个函数的返回值、

**组合性**

在函数式编程中，有一类比较特殊的函数，它们可以接收函数作为输入，或者返回一个函数作为输出。这种函数叫做高阶函数（High-order function），高阶函数有什么用呢？它的一个重要作用在于，我们可以用它去做行为的组合；

函数式编程中，还有一个重要的体系，就是列表转换的思想，将很多操作分解成若干转换的组合。最基础的三个转换是：map、filter 和 reduce，更多的转换操作都可以基于这三个转换完成；
- map：把一组数据通过函数映射成另一组数据；
- filter：把一组数据按照条件过滤只留下满足条件的数据；
- reduce：把一组数据按照某种规则规约为一个数据

面向对象和函数式编程都提到了组合性，不同的是，面向对象关键在于结构的组合，而函数式编程在于函数接口的组合；

**不变性**

函数式编程的不变性主要体现在值和纯函数上。
- 值，可以将它理解为一个初始化之后就不再改变的量，换句话说，当你使用一个值的时候，值是不会变的。
- 纯函数，是符合下面两点的函数：
  - 对于相同的输入，给出相同的输出；
  - 没有副作用。

> 把值和纯函数合起来看，值保证不会显式改变一个量，而纯函数保证的是，不会隐式改变一个量。

编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法

## 5、设计原则与模式

主要：[SOLID原则](设计模式#2面向对象设计原则)，包含如下：
- 单一职责原则（Single responsibility principle，SRP）
- 开放封闭原则（Open–closed principle，OCP）
- Liskov替换原则（Liskov substitution principle，LSP）
- 接口隔离原则（Interface segregation principle，ISP）
- 依赖倒置原则（Dependency inversion principle，DIP）

### 5.1、单一职责原则

理解单一职责原则本质上就是要理解分离关注点。

如何理解好单一职责：
- 我们需要理解封装，知道要把什么样的内容放到一起；
- 我们需要理解分离关注点，知道要把不同的内容拆分开来；
- 我们需要理解变化的来源，知道把不同行为者负责的代码放到不同的地方。

单一职责原则讲的并不是一个类只做一件事，它的关注点在于变化；变化仍在，但是我们可以通过单一职责原则减少变化带来的影响；

> 应用单一职责原则衡量模块，粒度越小越好。

### 5.2、开发封闭原则

应该对扩展开放，对修改封闭

开放封闭原则描述的是一个结果，就是可以不修改代码而仅凭扩展就完成新功能。但是，这个结果的前提是要在软件内部留好扩展点，而这正是需要去设计的地方。因为每一个扩展点都是一个需要设计的模型

构建模型的难点，首先在于分离关注点，其次在于找到共性；跟多态结合

> 设计扩展点，迈向对修改关闭、对扩展开放；

### 5.3、Liskov替换原则

一般满足 Liskov 原则的，都有统一处理的接口，如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了 LSP

要满足 LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足 IS-A 的关系。LSP让我们的注意力集中在父类上

> 用父类的角度去思考，设计行为一致的子类。

### 5.4、接口隔离原则

接口最小化原则，强调的是一个接口拥有的行为应该尽可能的小，尽量细化接口，使类具有很好的可读性、可扩展性和可维护性；接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别：单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一；

在做接口设计时，应该关注不同的使用者；

> 识别对象的不同角色，设计小接口

### 5.5、依赖倒置原则

高层模块不应依赖于低层模块，二者应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。

通过DIP推导的一些编码规则：
- 任何变量都不应该指向一个具体类；
- 任何类都不应继承自具体类；
- 任何方法都不应该改写父类中已经实现的方法；

所谓倒置，就是把这种习惯性的做法倒过来，让高层模块不再依赖于低层模块

### 5.6、如何理解和学习设计模式

所谓模式，其实就是针对的就是一些普遍存在的问题给出的解决方案

用数学来比喻，设计原则就像公理，它们是我们讨论各种问题的基础，而设计模式则是定理，它们是在特定场景下，对于经常发生的问题给出的一个可复用的解决方案；

学习设计模式不仅仅要学习代码怎么写，更重要的是要了解模式的应用场景；设计模式背后其实是各种设计原则，在实际的工作中，更应该按照设计原则去写代码，不一定要强求设计模式，而按照设计原则去写代码的结果，往往是变成了某个模式

### 5.7、一些设计知道原则

一些编程原则：
- KISS 原则，Keep it simple, stupid，我们要让系统保持简单；比如如果有现成的程序库，就不要自己写
- YAGNI 原则，You aren’t gonna need it，不要做不该做的需求；
- DRY 原则，Don’t repeat yourself，不要重复自己，消除各种重复。在一个系统中，每一处知识都必须有单一、明确、权威的描述

简单设计原则
- 通过所有测试：有配置的自动化测试，保证测试覆盖大多数场景；
- 消除重复：发现重复，分离关注点
- 表达出程序员的意图：编写有表达性的代码；
- 让类和方法的数量最小化：不要过度设计

> 简单地做设计

## 6、设计方法

一种常见的做法是上来就设计数据库，剩下的就是对数据库进行CRUD，这种思路实际上是一种结构化编程的思路

### 6.1、领域驱动设计

- [领域驱动模型](系统设计.md#六领域驱动模型DDD)
- [四色建模法领域分析](https://www.infoq.cn/article/xh-four-color-modeling)

领域驱动设计，即DDD，理解 DDD 的基础：通用语言（Ubiquitous Language）和模型驱动的设计（Model-Driven Design），而领域驱动设计的过程，就是建立起通用语言和识别模型的过程，并提供了一套标准的建模方法

**通用语言**

概念：
- 一套在业务人员和开发人员之间的共有语言；
- 一个在业务中有哪些操作和概念

如何实践-常见的实践方法事件风暴（事件风暴是一个工作坊，基本做法就是找一面很宽的墙，上面铺上大白纸，然后，用便利贴把识别出来的概念贴在上面。当然，前提依然是让业务人员和技术人员都参与其中），其关注点是领域事件，领域事件是用来记录业务过程中发生过的重要事情；
事件风暴这个工作坊主要分成三步：
- 第一步就是把领域事件识别出来，这个系统有哪些是人们关心的结果。有了领域事件，下面一个问题是，这些事件是如何产生的，它必然会是某个动作的结果。
- 第二步就是找出这些动作，也就是引发领域事件的命令。比如：产品已上架是由产品上架这个动作引发的，而订单已下就是由下单这个命令引发的。
- 第三步就是找出与事件和命令相关的实体或聚合，比如，产品上架就需要有个产品（Product），下单就需要有订单（Order）。

**模型驱动设计**

- 战略设计：高层设计、按照业务将系统拆分为不同的领域；
- 战术设计：低层设计、考虑如何组织不同的业务模型；

### 6.2、战略设计

关键：如何划分系统

战略设计中的概念，一部分是为了将不同的业务区分开来，也就是要将识别出来的业务概念做一个划分，另一部分则是将划分出来的业务落实到真实的解决方案中；所以战略设计可以划分为做业务的划分和落地成解决方案两部分；

**业务概念的划分**

在领域驱动设计中，就是要把一个大领域分解成若干的小领域，而这个分解出来的小领域就是子域（Subdomain）

对于一个真实项目而言，划分出来的子域可能会有很多，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成`核心域（Core Domain）`、`支撑域（Supporting Subdomain）`和`通用域（Generic Subdomain）`；

如何识别核心域，可以从以下几个问题：
- 为什么这个系统值得写？
- 为什么不直接买一个？
- 为什么不外包？

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域；

还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行；

之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。业务概念的落地

**业务概念的落地**

有了切分的子域，怎样落实到代码中？首先要解决的就是这些子域如何组织的问题，领域驱动中有个重要概念：限界上下文（Bounded Context）

限界上下文，顾名思义，它形成了一个边界，一个限定了通用语言自由使用的边界，一旦出界，含义便无法保证；子域和限界上下文不一定是一一对应的，可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文；

限界上下文的重点在于，它是完全独立的，不会为了完成一个业务需求要跑到其他服务中去做很多事；

防腐层：限界上下文之间交互的方式，防腐层是最具防御性的一种关系，简言之，就是指我们要在外部模型和内部模型之间建立起一个翻译层，将外部模型转化为内部模型

### 6.3、战术设计

关键：如何设计模型

战术设计包含了很多概念，比如：实体、值对象、聚合、领域服务、应用服务等等

把战术设计比喻成写故事，写故事通常都是有一定套路的。要先构建好故事的背景，然后，要设定不同的角色，接下来，创建角色之间的关系，最后，我们要安排人物之间互动起来，形成故事；

对于战术设计而言，故事的背景就是需要面对的领域问题，剩下的就是在这个故事背景下，要找出不同的角色，找出角色之间的关系，让它们互动起来，这样就有了故事，也完成了战术设计；

**角色：实体、值对象**

在战术设计中角色就是各种名词，要识别的名词包括了实体和值对象；
- 实体（Entity）指的是能够通过唯一标识符标识出来的对象
- 值对象，它就表示一个值；它同实体的差别在于，它没有标识符；实体的属性是可以变的，只要标识符不变，它就还是那个实体。但是，值对象的属性却不能变，一旦变了，它就不再是那个对象，所以，会把值对象设置成一个不变的对象；

为什么要将对象分为实体和值对象？其实主要是为了分出值对象，也就是把变的对象和不变的对象区分开

**关系：聚合和聚合根**

- 聚合（Aggregate）就是多个实体或值对象的组合，这些对象是什么关系呢？可以理解为它们要同生共死；比如，一个订单里有很多个订单项，如果这个订单作废了，这些订单项也就没用了。所以，我们基本上可以把订单和订单项看成一个单元，订单和订单项就是一个聚合；聚合要保证事务（Transaction）一致性

  一个聚合里可以包含很多个对象，每个对象里还可以继续包含其它的对象，就像一棵大树一层层展开。但重点是，这是一棵树，所以，它只能有一个树根，这个根就是聚合根
- 聚合根（Aggregate Root），就是从外部访问这个聚合的起点；

**互动：工厂、仓库、领域服务、应用服务**

有了角色及其关系，接下来就是找到各种动词，让故事生动起来。这里的动作，也就是领域服务，以及动作的结果，也就是领域事件，还有创建对象的工厂和保存对象的仓库。这些内容构成了最核心的业务逻辑。一些额外的工作，可以放到外围来做，这就是应用服务；

应用服务和领域服务之间最大的区别就在于，领域服务包含业务逻辑，而应用服务不包含

## 7、实践

### 7.1、设计程序库

### 7.2、设计应用程序

### 7.3、改进应用设计

改进一个软件的设计： 首先，要确定改进的目标。改进的目标就是，重新设计这个软件，它应该设计成什么样子，让设计还原到它应有的本来面貌。寻找改进的起点，一部分可以从需求入手，还有一部分要从梳理接口入手；

设计改进的难点在于不要回到老路上，要做正常的设计，尤其是要把分解做好；

有了改进目标之后，接下来就是要找到一条改进路径，选择怎样的路径都是有道理的，但有两个关键点是非常重要的，一个是每步改进的动作要小；一个是要让相关利益人达成共识

> 改进既有设计，从做一个正常的设计开始，小步向前

示例：
- （1）瘦身，瘦身就是把系统的各种接口，页面接口，服务接口，job，通过监控统计已经下线的功能，把代码删除掉，最近一年没有访问的请求，把代码删除掉。另外，通过表，sql反向梳理，就是表里没有新数据，sql最近一年没有执行过，把这样的代码都删除掉。
- （2）重构，精准重构，
  - 1个是性能，梳理接口，统计超过一定阀值的接口，根据成本收益原则，确定优先级，分布实施；
  - 1个是功能复杂度，统计最近1年每个源代码文件提交的次数，我们的依据是开放封闭原则，一个类被频繁修改，就说明设计存在问题了。
- （3）新需求，新应用，对于业务领域是个全新的子域，我们坚决开发新应用解决，另外我们计划做服务标准化，对于新接口和服务，通过一个新应用实现。同样的遵守开放封闭原则

### 7.4、框架设计

区分功能性需求和非功能性需求：
- 功能性需求：一个框架支持的功能，比如一个限流框架，支持限流规则配置和提供编程接口；
- 非功能性需求：比如易用性、扩展性、灵活性、性能、容错性等。
