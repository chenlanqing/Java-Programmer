[凤凰架构-构建可靠的大型分布式系统](http://icyfenix.cn/)

# 一、架构基础

## 1、基本概念

- 系统与子系统

    - 系统：泛指由一群有关联的个体组成，根据某种规则运作，能完成个别原件不能单独完成的工作的群体。它的意思是“总体”、“整体”或联盟
    - 子系统：由一群有关联的个体所组成的系统，多半会是更大系统中的一部分；

其实子系统的定义和系统的定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统；

- 模块与组件
    - 模块：是一套一致而互相有紧密关联的软件组装。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成单位。
    - 组件：定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易的被用于组装应用程序中。

模块和组件都是系统的组成部分，知识从不同的角度拆分系统而已；从逻辑角度来拆分系统，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是复用；

- 框架与架构

    - 软件框架通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品；<br>
        关键点：
        - （1）框架是组件规范，例如MVC；
        - （2）框架提供基础功能产品，例如SpringMVC是MVC开发框架；
    - 软件架构是指软件系统的基础架构，创造这些基础结构的准则，以及对这些结构的描述；

框架和架构的区别还是比较明显的，框架关注的是“规范”，架构关注的是“结构”

## 2、业务架构、应用架构、技术架构

- 业务架构就是讲清楚核心业务的处理过程，定义各个业务模块的相互关系，它从概念层面帮助我们理解系统面临哪些问题以及如何处理；
- 应用架构就是讲清楚系统内部是怎么组织的，有哪些应用，相互间是怎么调用的，它从逻辑层面帮助我们理解系统内部是如何分工与协作的；
- 技术架构就是讲清楚系统由哪些硬件、操作系统和中间件组成，它们是如何和我们开发的应用一起配合，应对各种异常情况，保持系统的稳定可用。所以，技术架构从物理层面帮助我们理解系统是如何构造的，以及如何解决稳定性的问题；

业务架构给出了业务模块的划分和依赖关系，这也大致决定了应用系统如何分工和协作，当然这不需要严格地一一对应，比如一个商品业务，可能对应 3 个应用，一个前台商品展示应用、一个后台商品管理应用，以及一个商品基础服务，但这不影响我们从逻辑上理解，一个业务场景，有哪些应用参与，并且它们是如何协作的。

而技术架构呢，通过保障应用的稳定运行，最终保证业务不出问题。比如在大促的时候，多个应用可能会受大流量冲击，技术架构就要考虑怎么通过技术手段，保障相关的应用能够处理高并发，从而保证大促顺利进行；

> 所以做架构设计时，一般是先考虑业务架构，再应用架构，最后是技术架构

# 二、高可用架构

高可用本质上是通过“冗余”来实现的

## 1、服务降级


## 2、限流


## 3、超时和重试机制


## 4、回滚机制

## 5、服务容错

## 6、自动重启


# 三、容器化

## 1、容器

Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行；

比较了容器化技术和传统虚拟化方式的不同之处：
* 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；
* 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源

## 2、Docker

## 3、容器面试题

#### 3.1、Java程序运行在Docket等容器环境存在什么问题？

对于Java来说，Docker是一个新的环境，如其内存、CPU等资源限制都是通过CGroup（Control Group）实现的，早期的JDK版本并不能识别这些限制，进而导致一些基础问题：
- 如果未配置合适的JVM堆和元数据区、直接内存等参数，Java就有可能试图使用超过容器限制的内存，最终被容器OOM Kill，或者自身发生OOM；
- 错误判断了可获取的CPU资源，例如，Docker限制了CPU核数，JVM就可能设置不合适的GC并行线程数等；

#### 3.2、为什么类似Docker这种容器环境，会有点欺负JAVA？从JVM内部机制来讲，问题出现在哪里？

##### 3.2.1、出现问题的原因

- Docker与虚拟机非常相似，但是Docker并不是一种完全的虚拟机化技术，而更是一种轻量级的隔离技术；基于namespace，Docket为每个容器提供了单独的命名空间，对网络、PID、用户、IPC通信、文件系统挂载等实现了隔离，对于CPU、内存、磁盘IO等计算资源，则是用过CGroup进行管理。
- 容器虽然省略了虚拟操作系统的开销，实现了轻量级的目标，但也带来了额外的复杂性，它限制对于应用不是透明的，需要用户理解Docker的新行为；
- 对于Java平台来说，未隐藏的底层信息带来了意外，主要体现在：
    - 容器环境对于计算机资源的管理方式是全新的，CGroup作为相对比较新的技术，历史版本的Java显然并不能自然理解相应的资源限制；
    - namespace对于容器内的应用细节增量一些微妙差异

- 从JVM运行角度，这些为什么会导致OOM等问题？
    
    这就是所谓的Ergonomics机制
    - JVM会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的1/64；并将堆最大值设置为系统内存的1/4；
    - 而JVM检测到系统的CPU核数，则直接影响到了ParallelGC并行线程数目和JIT compiler线程数目，设置是应用中ForkJoinPool等机制的并行登记；

    这些是默认参数，是根据通用场景选择的初始值，但是由于容器环境的差异，Java的判断很可能是基于错误信息而做出的，更加严重的是JVM的一些原有诊断或备用机制也会受到影响

##### 3.2.2、如何解决
- 首先，如果能够升级到最新的JDK版本，问题就解决了；
- 如果只用老版本JDK，需要注意以下几点：
    - 明确设置堆大小、元数据等内存区域大小，保证Java进程的总大小可控；
    - 明确配置GC和JIT并行线程数目，以避免二者占用过多计算资源

# 四、数据库中间件

[](../../数据库/数据库中间件.md)

# 模块化

(OSGI)[http://www.osgi.com.cn/article/7289520]

## 参考资料

* [Sharding Sphere官方文档](https://shardingsphere.apache.org/)
* [架构的演进](https://www.cnblogs.com/hafiz/p/9222973.html)
* [如何画架构图](https://developer.aliyun.com/article/765140?spm=a2c6h.12873639.0.0.75482c6dlmkDa6)
* [分布式系统](https://developer.aliyun.com/article/721007?spm=a2c6h.12873639.0.0.75482c6dlmkDa6)
* [架构设计实践](https://www.infoq.cn/article/b1fCLl8Mk9L9qe45Zxp6)
* [技术选型](https://juejin.im/post/6870288195674718222)
* [如何画架构图](https://juejin.cn/post/6844904127856640014)
