

# 一、架构

## 1、Netty逻辑架构

Netty 采用了比较典型的三层网络架构进行设计，包含如下：

### 1.1、Reactor 通信调度层

它由一系列辅助类完成，包括 Reactor 线程 NioEventLoop 以及其父类、NioSocketChannel/NioServerSocketChannel 以及其父 类、ByteBuffer 以及由其衍生出来的各种 Buffer、Unsafe 以及其衍生出的各种内 部类等。该层的主要职责就是监听网络的读写和连接操作，负责将网络层的数据 读取到内存缓冲区中，然后触发各种网络事件，例如连接创建、连接激活、读事 件、写事件等等，将这些事件触发到 PipeLine 中，由 PipeLine 充当的职责链来 进行后续的处理。

### 1.2、职责链 PipeLine

它负责事件在职责链中的有序传播，同时负责动态的 编排职责链，职责链可以选择监听和处理自己关心的事件，它可以拦截处理和向 后/向前传播事件，不同的应用的 Handler 节点的功能也不同，通常情况下，往往 会开发编解码 Hanlder 用于消息的编解码，它可以将外部的协议消息转换成内部 的 POJO 对象，这样上层业务侧只需要关心处理业务逻辑即可，不需要感知底层的协议差异和线程模型差异，实现了架构层面的分层隔离。

### 1.3、业务逻辑处理层，可以分为两类：

- 纯粹的业务逻辑 处理，例如订单处理。
- 应用层协议管理，例如HTTP协议、FTP协议等

## 2、高性能

- 采用异步非阻塞IO类库，基于Reactor模式实现，解决了传统同步阻塞IO模式下一个服务端无法平滑的处理线性增长的客户端的问题；
- TCP接收和发送缓冲区使用直接内存代替堆内存，避免了内存复制，提升了IO读写性能；
- 支持通过内存池的方式循环利用ByteBuf，避免了频繁创建和销毁ByteBuf带来的性能损耗；
- 可配置的IO线程数、TCP参数等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景；
- 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁

    NioEventLoop读取到消息之后，直接调用ChannelPipeline的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直由NioEventLoop调用到用户Handler，期间不用进行线程处理

- 合理的使用线程安全容器、原子类等，提升系统的并发处理能力；
- 关键资源的处理使用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的CPU资源消耗问题；
- 通过引用计数器及时的申请释放不再被引用的对象，细粒度的内存管理降低了GC的频率，减少了频繁GC带来的时延增大和CPU损耗

## 3、可靠性

### 3.1、链路有效性检测

为了保证长连接的链路有效性，需要通过心跳机制周期性进行链路检测。有业务消息时，无需心跳检测，可以由业务消息进行链路可用性检测。心跳检测玩玩是在链路空闲时发送的

Netty提供了两种链路空闲检测机制
- 读空闲超时机制：当连续周期T没有消息可读时，触发超时Handler，用户可以基于读空闲超时发送心跳消息，进行链路检测。如果连续N个周期仍然没有读取到心跳消息，可以主动关闭链路；
- 写空闲超时机制：当连续周期T没有消息要发送时，触发超时Handler，用户可以基于写空闲超时发送心跳消息，进行链路检测。如果连续N个周期仍然没有接收到对方的心跳消息，可以主动关闭链路；

心跳检测机制分为三个层面：

- TCP层面的心跳检测，即TCP的Keep-Alive机制，它的作用域是整个TCP协议栈；
- 协议层的心跳检测，主要存在于长连接协议中。例如SMPP协议；
- 应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现

### 3.2、内存保护机制

- 通过对象引用计数器对Netty的ByteBuf等内置对象进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护；
- 通过内存池来重用Bytebuf，节省内存；
- 可设置的内存容量上限，包括ByteBuf、线程池线程数等；

### 3.3、优雅停机

Netty的优雅停机三部曲：
- 不再接收新消息
- 退出前的预处理操作
- 资源的释放操作

Java的优雅停机通常通过注册JDK的ShutdownHook来实现，当系统接收到退出指令后，首先标记系统处于退出状态，不再接收新的消息，然后将积压的消息处理完，最后调用资源回收接口将资源销毁，最后各线程退出执行。

通常优雅退出需要有超时控制机制，例如30S，如果到达超时时间仍然没有完成退出前的资源回收等操作，则由停机脚本直接调用kill -9 pid，强制退出



