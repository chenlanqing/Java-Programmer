<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一、Disruptor](#%E4%B8%80disruptor)
  - [1、LMAX架构](#1lmax%E6%9E%B6%E6%9E%84)
  - [2、Disruptor介绍](#2disruptor%E4%BB%8B%E7%BB%8D)
  - [3、Disruptor快速入门](#3disruptor%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8)
  - [4、Disruptor核心组件](#4disruptor%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6)
    - [4.1、RingBuffer](#41ringbuffer)
    - [4.2、Disruptor](#42disruptor)
    - [4.3、Sequence](#43sequence)
    - [4.4、Sequencer](#44sequencer)
    - [4.5、SequenceBarrier](#45sequencebarrier)
    - [4.6、WaitStrategy](#46waitstrategy)
    - [4.7、Event](#47event)
    - [4.8、EventProcessor](#48eventprocessor)
    - [4.9、EventHandler](#49eventhandler)
    - [4.10、WorkProcessor](#410workprocessor)
    - [4.11、Disruptor编程模型](#411disruptor%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B)
  - [5、Disruptor高级应用](#5disruptor%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8)
    - [5.1、核心链路应用场景](#51%E6%A0%B8%E5%BF%83%E9%93%BE%E8%B7%AF%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
    - [5.2、并行计算](#52%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97)
    - [5.3、多边形高端操作](#53%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%AB%98%E7%AB%AF%E6%93%8D%E4%BD%9C)
    - [5.4、多生产者与多消费者](#54%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85)
- [6、源码分析](#6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)
  - [6.1、Disruptor底层性能特点](#61disruptor%E5%BA%95%E5%B1%82%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9)
  - [6.2、数据结构与内存预加载机制](#62%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%86%85%E5%AD%98%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)
  - [6.3、使用单线程写](#63%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%86%99)
  - [6.4、内存优化：内存屏障](#64%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)
  - [6.5、系统缓存优化：消除伪共享](#65%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%B6%88%E9%99%A4%E4%BC%AA%E5%85%B1%E4%BA%AB)
  - [6.6、算法优化：序号栅栏机制](#66%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E5%BA%8F%E5%8F%B7%E6%A0%85%E6%A0%8F%E6%9C%BA%E5%88%B6)
  - [6.7、WaitStrategy等待策略](#67waitstrategy%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5)
  - [6.8、EventProcessor核心机制](#68eventprocessor%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 一、Disruptor

* [The LMAX Architecture](https://martinfowler.com/articles/lmax.html)
* [Disruptor框架英文翻译](http://ifeve.com/disruptor/)
* [LMAX架构](https://www.jianshu.com/p/5e0c4481efb7)

## 1、LMAX架构

LMAX是一种新型零售金融交易平台，它能够以很低的延迟(latency)产生大量交易(吞吐量)。

这个系统是建立在JVM平台上，核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中(in-memory)，使用事件源驱动方式(event sourcing). 业务逻辑处理器的核心是`Disruptors`，这是一个并发组件，能够在无锁的情况下实现网络的Queue并发操作；

## 2、Disruptor介绍


## 3、Disruptor快速入门

- （1）构架一个Event
    ```java
    @Data
    public class OrderEvent {
        private Long value;
    }
    ```
- （2）构建一个EventFactory
    ```java
    public class OrderEventFactory implements EventFactory<OrderEvent> {
        @Override
        public OrderEvent newInstance() {
            return new OrderEvent();
        }
    }
    ```

- （3）构建一个EventHandler
    ```java
    public class OrderEventHandler implements EventHandler<OrderEvent> {
        @Override
        public void onEvent(OrderEvent event, long sequence, boolean endOfBatch) throws Exception {
            System.out.println("消费者：" + event.getValue());
        }
    }
    ```

- （4）构建一个Disruptor
    ```java
    /**
     * 1 eventFactory: 消息(event)工厂对象
     * 2 ringBufferSize: 容器的长度
     * 3 executor: 线程池(建议使用自定义线程池) RejectedExecutionHandler
     * 4 ProducerType: 单生产者 还是 多生产者
     * 5 waitStrategy: 等待策略
     */
    //1. 实例化disruptor对象
    Disruptor<OrderEvent> disruptor = new Disruptor<OrderEvent>(orderEventFactory,
            ringBufferSize,
            executor,
            ProducerType.SINGLE,
            new BlockingWaitStrategy());
    //2. 添加消费者的监听 (构建disruptor 与 消费者的一个关联关系)
    disruptor.handleEventsWith(new OrderEventHandler());
    //3. 启动disruptor
    disruptor.start();
    ```
    关于RingBuffer的使用
    ```java
    //1 在生产者发送消息的时候, 首先 需要从我们的ringBuffer里面 获取一个可用的序号
    long sequence = ringBuffer.next();	//0	
    try {
        //2 根据这个序号, 找到具体的 "OrderEvent" 元素 注意:此时获取的OrderEvent对象是一个没有被赋值的"空对象"
        OrderEvent event = ringBuffer.get(sequence);
        //3 进行实际的赋值处理
        event.setValue(data.getLong(0));			
    } finally {
        //4 提交发布操作
        ringBuffer.publish(sequence);			
    }
    ```


## 4、Disruptor核心组件

### 4.1、RingBuffer

基于数组的缓存实现，也是创建sequence与定义WaitStrategy的入口

### 4.2、Disruptor


### 4.3、Sequence

- 通过顺序递增的序号来编号，管理进行交互的数据；
- 对数据的处理过程总是沿着序号逐个递增处理；
- 一个sequence用于跟踪标识某个特定的事件处理者（RingBuffer、Producer、Consumer）的处理进度
- Sequence可以看成是一个AtomicLong用于标识进度；
- 还有另外一个目的是防止不同的Sequence之间CPU缓存伪共享的问题

### 4.4、Sequencer

- Disruptor真正的核心
- 此接口有两个实现类：MultiProducerSequencer、SingleProducerSequencer
- 主要实现生产者和消费者之间快速、正确的传递数据的并发算法

### 4.5、SequenceBarrier

- 用于保持对RingBuffer的Mian Published Sequence和Consumer之间的平衡关系；SequenceBarrier还定义了决定Cosnumer是否还有可处理的事件的逻辑；

### 4.6、WaitStrategy

- 决定一个消费者将如何等待生产者将Event置入Disruptor

- BlockingWaitStrategy：是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现；
- SleepingWaitStrategy：其性能跟BlockingWaitStrategy差不多，对CPU的消耗类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；
- YieldingWaitStrategy：其性能最好，适合用于低延迟的系统。在要求极高性能且事件处理数小于CPU逻辑核心数的场景中，推荐使用此策略；比如CPU开启超线程的特性；

### 4.7、Event

- 从生产者到消费者过程中所处理的数据单元

### 4.8、EventProcessor

- 主要事件循环，处理Disruptor的Event，拥有消费者的Sequence
- 它有个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象；

### 4.9、EventHandler

由用户实现并且代表了Disruptor中的一个消费者的接口，也就是消费者的处理逻辑都需要写在这里；

### 4.10、WorkProcessor

确保每个sequence只能被一个processor消费，在同一个workpool中处理多个WorkProcessor不会被消费统一的sequence

### 4.11、Disruptor编程模型

![](image/Disruptor图解.png)

## 5、Disruptor高级应用

### 5.1、核心链路应用场景

如京东中下单：用户添加到购物车 -> 下单 —> 支付 —> 配送 -> 收货

核心链路的代码实现，业务逻辑非常复杂；核心链路特点：至关重要且业务复杂

主要实现方式：
- 传统的完全解耦模式
- 模板模式

上述方式不适合，解决手段：
- 领域模型的高度抽象
- 寻找更好的框架帮助进行编码：
    - 有限状态机框架，比如：spring-statemachine
    - 使用Disruptor

### 5.2、并行计算

- 串行操作：使用链式调用的方式：`disruptor.handleEventsWith(new Handler1()).handleEventsWith(new Handler2()).handleEventsWith(new Handler3());`
- 并行操作：使用单独调用的方式：
    - 单独调用：
        ```java
        disruptor.handleEventsWith(new Handler1());
        disruptor.handleEventsWith(new Handler2());
        disruptor.handleEventsWith(new Handler3());
        ```
    - 传入多个元素：`disruptor.handleEventsWith(new Handler1(), new Handler2(), new Handler3());`

### 5.3、多边形高端操作

Disruptor可以实现串并行同时编码
- 菱形操作
    ```java
    disruptor.handleEventsWith(new Handler1(), new Handler2())
            .handleEventsWith(new Handler3());
            
    // 或者 通过handlerEventsWith方法的返回参数：EventHandlerGroup 来处理
    EventHandlerGroup<Trade> ehGroup = disruptor.handleEventsWith(new Handler1(), new Handler2());
    ehGroup.then(new Handler3());
    ```
- 六边形操作
    ```java
    // 执行顺序：h1和h4是并行操作，h2在h1执行完成后执行；h5在h4执行完成后执行；在h2和h5都执行成功之后，在执行h3
    Handler1 h1 = new Handler1();
    Handler2 h2 = new Handler2();
    Handler3 h3 = new Handler3();
    Handler4 h4 = new Handler4();
    Handler5 h5 = new Handler5();
    disruptor.handleEventsWith(h1, h4);
    disruptor.after(h1).handleEventsWith(h2);
    disruptor.after(h4).handleEventsWith(h5);
    disruptor.after(h2, h5).handleEventsWith(h3);
    ```
    **注意：单消费者模式下，上述代码执行跟构造Disruptor时传入的线程池有关，因为上述代码有5个EventHandler，所以，线程池中线程数量必须至少有5个；这是因为单消费者下是由BatchEventProcessor来操作的，而BatchEventProcessor就代表一个线程，其实现了Runnable接口；对于多消费者是不存在该问题的；**

### 5.4、多生产者与多消费者

使用WorkPool来处理


# 6、源码分析

## 6.1、Disruptor底层性能特点

- 数据结构方面：是否环形结构、数组、内存预加载；
- 使用单线程写方式、内存屏障
- 消除伪共享（填充缓存行）
- 序号栅栏和序号配合使用来消除锁和CAS；

## 6.2、数据结构与内存预加载机制

- RingBuffer使用数组Object[] entries作为存储元素

## 6.3、使用单线程写

Disruptor的RingBuffer，做到完全无锁是因为单线程写；注入Redis、Netty等高性能技术框架的设计都是这个核心思想

其是基于系统内核

## 6.4、内存优化：内存屏障

要正确的实现无锁，还需另外一个关键技术：内存屏障

## 6.5、系统缓存优化：消除伪共享

- [伪共享问题](Java并发与多线程.md#15伪共享问题)

## 6.6、算法优化：序号栅栏机制

- Disruptor3.0中，序号栅栏SequenceBarrier和序号Sequence搭配使用，协调和管理消费者与生产者的工作节奏，避免了锁和CAS的使用；
- Disruptor3.0中，每个消费者和生产者都持有自己的序号，这些序号的变化必须满足如下基本条件：
    - 消费者序号数值必须小于生产者序号数值；
    - 消费者序号必须小于其前置（依赖关系）消费者的序号数值；
    - 生产者序号数值不能大于消费者中最小的序号数值，以避免生产者速度过快，将还未来得及消费的消息覆盖；

## 6.7、WaitStrategy等待策略


对于YieldingWaitStrategy实现类，尝试去修改源代码，降低高性能对CPU和内存资源的损耗

## 6.8、EventProcessor核心机制





