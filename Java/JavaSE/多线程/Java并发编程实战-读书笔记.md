<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [1.Java多线程](#1java%E5%A4%9A%E7%BA%BF%E7%A8%8B)
- [2.Java并发编程模型:并发模型与分布式系统之间有相似性](#2java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E7%9B%B8%E4%BC%BC%E6%80%A7)
- [3.竞态条件与临界区:](#3%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA)
- [4.线程安全与共享资源:](#4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90)
- [5.线程安全与不可变性:通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全](#5%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E9%80%9A%E8%BF%87%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BF%9D%E8%AF%81%E5%AF%B9%E8%B1%A1%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%97%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E4%BF%AE%E6%94%B9%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 1.Java多线程
	(1).优点:
		A:资源利用率更好;
		B:程序设计在某些情况下更简单;
		C:程序响应更快;
	(2).多线程代价:
		A:设计更复杂,在多线程访问共享数据的时候，这部分代码需要特别的注意
		B:上下文切换的开销:当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，
			程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行
		C:增加资源消耗,除了CPU，线程还需要一些内存来维持它本地的堆栈
		
# 2.Java并发编程模型:并发模型与分布式系统之间有相似性
	2.1.并发工作者:传入的作业会被分配到不同的工作者上【/* Java并发编程模型/并发工作者.png */】
		(1).在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。
		每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上
		(2).并行工作者模型是最常见的并发模型;
		(3).优点:容易理解;
		(4).缺点:
			①.共享状态可能会很复杂:共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的
			②.无状态的工作者:每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候
			③.任务顺序是不确定的
	2.2.流水线并发模型:		
		Delegator --->  Worker --->  Worker --->  Worker
		(1).通常使用非阻塞的IO来设计使用流水线并发模型的系统;
		(2).优点:
			①.无需共享的状态;
			②.有状态的工作者;
			③.较好的硬件整合（Hardware Conformity）
			④.合理的作业顺序;
		(3).缺点:
			加大了代码编写难度
	2.3.函数式并行:Functional Parallelism,函数式并行的基本思想是采用函数调用实现程序	
# 3.竞态条件与临界区:
	当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区
	
# 4.线程安全与共享资源:
	线程安全:允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件
		(1).局部变量:
			局部变量存储在线程自己的栈中.也就是说,局部变量永远也不会被多个线程共享.所以:基础类型的局部变量是线程安全的
		(2).局部的对象引用:
			对象的局部引用和基础类型的局部变量不太一样:尽管引用本身没有被共享,但引用所指的对象并没有存储在线程的栈内.
			所有的对象都存在共享堆中,如果在某个方法中创建的对象即该对象不会被其它方法获得,也不会被非局部变量引用到,
			那么它就是线程安全的.实际上:哪怕将这个对象作为参数传给其它方法,只要别的线程获取不到这个对象,那它仍是线程安全的
		(3).对象成员:对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的
		(4).线程控制逃逸规则:
		如果一个资源的创建、使用、销毁都在同一个线程内完成,且永远不会脱离该线程的控制，则该资源的使用就是线程安全的	
		
# 5.线程安全与不可变性:通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全		
	(1).引用不是线程安全的:即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		