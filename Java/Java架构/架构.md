<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一、架构基础](#%E4%B8%80%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80)
  - [1、基本概念](#1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
- [二、大型系统架构](#%E4%BA%8C%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84)
  - [1、提升网站性能及并发量](#1%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E5%8F%8A%E5%B9%B6%E5%8F%91%E9%87%8F)
  - [2、设计高可用](#2%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8)
- [三、SET化架构](#%E4%B8%89set%E5%8C%96%E6%9E%B6%E6%9E%84)
  - [1、架构设计衍变](#1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%A1%8D%E5%8F%98)
  - [2、部分架构思路](#2%E9%83%A8%E5%88%86%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF)
    - [2.1、同城“双活”](#21%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB)
    - [2.3、两地三中心](#23%E4%B8%A4%E5%9C%B0%E4%B8%89%E4%B8%AD%E5%BF%83)
  - [3、SET化架构](#3set%E5%8C%96%E6%9E%B6%E6%9E%84)
    - [3.1、SET化优化目标](#31set%E5%8C%96%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87)
    - [3.2、SET化架构设计](#32set%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
    - [3.3、SET化路由策略及其能力](#33set%E5%8C%96%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%85%B6%E8%83%BD%E5%8A%9B)
    - [3.4、SET化架构设计原则](#34set%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 一、架构基础

## 1、基本概念

- 系统与子系统

    - 系统：泛指由一群有关联的个体组成，根据某种规则运作，能完成个别原件不能单独完成的工作的群体。它的意思是“总体”、“整体”或联盟
    - 子系统：由一群有关联的个体所组成的系统，多半会是更大系统中的一部分；

其实子系统的定义和系统的定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统；

- 模块与组件
    - 模块：是一套一致而互相有紧密关联的软件组装。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成单位。
    - 组件：定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易的被用于组装应用程序中。

模块和组件都是系统的组成部分，知识从不同的角度拆分系统而已；从逻辑角度来拆分系统，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是复用；

- 框架与架构

    - 软件框架通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品；<br>
        关键点：
        - （1）框架是组件规范，例如MVC；
        - （2）框架提供基础功能产品，例如SpringMVC是MVC开发框架；
    - 软件架构是指软件系统的基础架构，创造这些基础结构的准则，以及对这些结构的描述；

框架和架构的区别还是比较明显的，框架关注的是“规范”，架构关注的是“结构”


# 二、大型系统架构

## 1、提升网站性能及并发量

- 提高硬件能力；
- 使用缓存：本地缓存、Redis等；
- 消息队列：解耦、削峰、异步
- 分布式部署开发；
- 分库分表：读写分离、水平分表、垂直分表；
- 集群
- CDN加速
- 浏览器缓存
- 合理使用线程池
- 适当使用多线程技术

## 2、设计高可用

- 服务降级
- 限流
- 缓存
- 超时和重试机制
- 回滚机制

# 三、SET化架构

## 1、架构设计衍变

对于大型分布式集群，会存在如下问题：
- 容灾问题：核心业务挂掉，会影响全网所有用户，导致业务不可用
- 资源扩展问题：单IDC资源；数据库主库单点
- 大集群拆分问题：分布式集群扩展，带来的问题；

## 2、部分架构思路

### 2.1、同城“双活”

- “双活”：在业务层面上已经做到真正的双活，分别承担部分流量；
- 存储层面比如定时任务、缓存、持久层、数据分析等都是主从架构，会有跨机房写；
- 一个数据中心故障，可以手动切换流量，部分组件可以自动切换；

### 2.3、两地三中心

使用灾备的思想，在同城双活的基础上，在异地部署一套灾备数据中心，每个中心都具有完备的数据处理能力，只有当主节点故障需要容灾的时候才会紧急启动备用数据中心；

存在问题：
- 冷备中心不公正，关键时刻不敢切换；
- 冷备中心不公正，成本存在严重浪费；
- 本质上数据仍然是单点写，数据瓶颈无法解决；
- 资源、容灾、扩展仍然未得到解决；

## 3、SET化架构

### 3.1、SET化优化目标

- 业务：解决业务遇到的扩展性和容灾等需求，支撑业务的高速发展；
- 通用性：架构侧形成统一通用的解决方案，方便各业务线接入使用；

### 3.2、SET化架构设计

![](image/SET化架构图.png)

- 流量路由：按照特殊的key（通常是userId）进行路由，判断某次请求该路由到中心集群还是单元化集群；
- 中心集群：未进行单元化改造的服务，通常是不在核心交易里链路，称为中心集群，跟当前架构保持一致；
- 单元化集群：每个单元化集群只负责本单元内的流量处理，以实现流量拆分以及故障隔离；每个单元化集群前期只存储本单元产生的交易数据，后续做双向数据同步，实现容灾切换需求；
- 中间件：RPC、KV、MQ等
- 数据同步：全局数据部署在中心集群，其他单元化集群同步全局数据到本单元化内；

### 3.3、SET化路由策略及其能力

- 异地容灾：通过SET化架构的流量调度能力，将SET分别部署在不同地区的数据中心，实现跨地区容灾支持；
- 高效的本地化服务：路由到本地的最近SET，提高最高效的本地化服务；
- 集装箱式扩展：SET封装性支持更灵活的部署扩展性，比如SET一键创建、一键发布；

### 3.4、SET化架构设计原则

- 对业务透明：SET化架构的实现对业务代码透明，业务代码层面不需要关系SET化规则、SET的部署等问题‘’
- 切换规则：理论上，切分规则由业务层面按需定制；实现上，建议优先选最大的业务维度进行切分；
- 部署规范原则：一个SET并不一定只限制在一个机房，也可以跨机房或者跨地区部署；








