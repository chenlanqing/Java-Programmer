<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一、架构基础](#%E4%B8%80%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80)
  - [1、基本概念](#1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
- [二、大型系统架构](#%E4%BA%8C%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84)
  - [1、提升网站性能及并发量](#1%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E5%8F%8A%E5%B9%B6%E5%8F%91%E9%87%8F)
  - [2、设计高可用](#2%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8)
- [三、SET化架构](#%E4%B8%89set%E5%8C%96%E6%9E%B6%E6%9E%84)
  - [1、架构设计衍变](#1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%A1%8D%E5%8F%98)
  - [2、部分架构思路](#2%E9%83%A8%E5%88%86%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF)
    - [2.1、同城“双活”](#21%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB)
    - [2.3、两地三中心](#23%E4%B8%A4%E5%9C%B0%E4%B8%89%E4%B8%AD%E5%BF%83)
  - [3、SET化架构](#3set%E5%8C%96%E6%9E%B6%E6%9E%84)
    - [3.1、SET化优化目标](#31set%E5%8C%96%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87)
    - [3.2、SET化架构设计](#32set%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
    - [3.3、SET化路由策略及其能力](#33set%E5%8C%96%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E5%8F%8A%E5%85%B6%E8%83%BD%E5%8A%9B)
    - [3.4、SET化架构设计原则](#34set%E5%8C%96%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 一、架构基础

## 1、基本概念

- 系统与子系统

    - 系统：泛指由一群有关联的个体组成，根据某种规则运作，能完成个别原件不能单独完成的工作的群体。它的意思是“总体”、“整体”或联盟
    - 子系统：由一群有关联的个体所组成的系统，多半会是更大系统中的一部分；

其实子系统的定义和系统的定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统；

- 模块与组件
    - 模块：是一套一致而互相有紧密关联的软件组装。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成单位。
    - 组件：定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易的被用于组装应用程序中。

模块和组件都是系统的组成部分，知识从不同的角度拆分系统而已；从逻辑角度来拆分系统，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是复用；

- 框架与架构

    - 软件框架通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品；<br>
        关键点：
        - （1）框架是组件规范，例如MVC；
        - （2）框架提供基础功能产品，例如SpringMVC是MVC开发框架；
    - 软件架构是指软件系统的基础架构，创造这些基础结构的准则，以及对这些结构的描述；

框架和架构的区别还是比较明显的，框架关注的是“规范”，架构关注的是“结构”


# 二、大型系统架构

## 1、提升网站性能及并发量

- 提高硬件能力；
- 使用缓存：本地缓存、Redis等；
- 消息队列：解耦、削峰、异步
- 分布式部署开发；
- 分库分表：读写分离、水平分表、垂直分表；
- 集群
- CDN加速
- 浏览器缓存
- 合理使用线程池
- 适当使用多线程技术

## 2、设计高可用

- 服务降级
- 限流
- 缓存
- 超时和重试机制
- 回滚机制

# 三、SET化架构

## 1、架构设计衍变

对于大型分布式集群，会存在如下问题：
- 容灾问题：核心业务挂掉，会影响全网所有用户，导致业务不可用
- 资源扩展问题：单IDC资源；数据库主库单点
- 大集群拆分问题：分布式集群扩展，带来的问题；

## 2、部分架构思路

### 2.1、同城“双活”

- “双活”：在业务层面上已经做到真正的双活，分别承担部分流量；
- 存储层面比如定时任务、缓存、持久层、数据分析等都是主从架构，会有跨机房写；
- 一个数据中心故障，可以手动切换流量，部分组件可以自动切换；

### 2.3、两地三中心

使用灾备的思想，在同城双活的基础上，在异地部署一套灾备数据中心，每个中心都具有完备的数据处理能力，只有当主节点故障需要容灾的时候才会紧急启动备用数据中心；

存在问题：
- 冷备中心不公正，关键时刻不敢切换；
- 冷备中心不公正，成本存在严重浪费；
- 本质上数据仍然是单点写，数据瓶颈无法解决；
- 资源、容灾、扩展仍然未得到解决；

## 3、SET化架构

### 3.1、SET化优化目标

- 业务：解决业务遇到的扩展性和容灾等需求，支撑业务的高速发展；
- 通用性：架构侧形成统一通用的解决方案，方便各业务线接入使用；

### 3.2、SET化架构设计

![](image/SET化架构图.png)

- 流量路由：按照特殊的key（通常是userId）进行路由，判断某次请求该路由到中心集群还是单元化集群；
- 中心集群：未进行单元化改造的服务，通常是不在核心交易里链路，称为中心集群，跟当前架构保持一致；
- 单元化集群：每个单元化集群只负责本单元内的流量处理，以实现流量拆分以及故障隔离；每个单元化集群前期只存储本单元产生的交易数据，后续做双向数据同步，实现容灾切换需求；
- 中间件：RPC、KV、MQ等
- 数据同步：全局数据部署在中心集群，其他单元化集群同步全局数据到本单元化内；

### 3.3、SET化路由策略及其能力

- 异地容灾：通过SET化架构的流量调度能力，将SET分别部署在不同地区的数据中心，实现跨地区容灾支持；
- 高效的本地化服务：路由到本地的最近SET，提高最高效的本地化服务；
- 集装箱式扩展：SET封装性支持更灵活的部署扩展性，比如SET一键创建、一键发布；

### 3.4、SET化架构设计原则

- 对业务透明：SET化架构的实现对业务代码透明，业务代码层面不需要关系SET化规则、SET的部署等问题‘’
- 切换规则：理论上，切分规则由业务层面按需定制；实现上，建议优先选最大的业务维度进行切分；
- 部署规范原则：一个SET并不一定只限制在一个机房，也可以跨机房或者跨地区部署；


# 四、高可用架构

高可用本质上是通过“冗余”来实现的

## 1、服务降级


## 2、限流

* [限流算法的实现](https://www.jianshu.com/p/76cc8ba5ca91)
* [Sentinel-高可用限流组件](https://github.com/all4you/sentinel-tutorial)
* [OpenResty防刷、限流](http://openresty.org/cn/)

### 2.1、概念

### 2.2、常见的限流手段

- 信号量计数：信号量竞争是用来控制并发的一个常见手段，它的优点即在于简单可靠，但是只能在单机环境中使用；
- 线程池隔离：隔离舱技术中也大量使用了线程池隔离的方式来实现，通过限制使用的线程数来对流量进行限制，一般会用阻塞队列配合线程池来实现
- 固定窗口计数：限制接口总并发数
- 自然窗口计数
- 滑动窗口计数
- 令牌桶和漏桶算法计数

### 2.3、限流算法实现

常见的限流算法有：计数器、令牌桶、漏桶

#### 2.3.1、计数器

- 算法思路：比如限流qps为100，思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数；

- 具体的实现可以是这样的：对于每次服务调用，可以通过AtomicLong#incrementAndGet()方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较

- 弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”

#### 2.3.2、漏桶算法

- 为了消除"突刺现象"，可以采用漏桶算法实现限流；
- 不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求，为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃；
- 算法实现：可以准备一个队列，用来保存请求，另外通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行；
- 弊端：无法应对短时间的突发流量；

#### 2.3.3、令牌桶算法

- 令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用；
- 在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝；
- 实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器，通过RateLimiter类的create方法，创建限流器

### 2.4、集群限流

可以使用redisson的RateLimiter

## 3、[缓存](缓存.md)


## 4、超时和重试机制


## 5、回滚机制

# "4+1"视图



