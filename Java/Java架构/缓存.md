<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [1.缓存](#1%E7%BC%93%E5%AD%98)
- [2.高并发环境下缓存场景问题:](#2%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98)
  - [2.1.缓存一致性](#21%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7)
  - [2.2.缓存并发问题](#22%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98)
  - [2.3.缓存穿透现象;](#23%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%8E%B0%E8%B1%A1)
  - [2.4.缓存的雪崩现象](#24%E7%BC%93%E5%AD%98%E7%9A%84%E9%9B%AA%E5%B4%A9%E7%8E%B0%E8%B1%A1)
- [2.缓存最佳实践](#2%E7%BC%93%E5%AD%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 1.缓存
# 2.高并发环境下缓存场景问题:
## 2.1.缓存一致性
    (1).更新数据库成功,更新缓存失败 -> 数据不一致
    (2).更新缓存成功,更是数据库失败 -> 数据不一致
    (3).更新数据库成功,淘汰缓存失败 -> 数据不一致
    (4).淘汰缓存成功,更新数据库失败 -> 查询缓存miss
## 2.2.缓存并发问题
## 2.3.缓存穿透
### 2.3.1.什么是缓存穿透
    缓存穿透是指查询一个根本不存在的数据,缓存层和存储层都不会命中,
    但是出于容错的考虑,如果从存储层查不到数据则不写入缓存层,整个过程分为如下 3 步:
    (1).缓存层不命中
    (2).存储层不命中,所以不将空结果写回缓存
    (3).返回空结果
### 2.3.2.缓存穿透造成后果
    可能会使后端存储负载加大,由于很多后端存储不具备高并发性,甚至可能造成后端存储宕掉;
    可能在程序中分别统计总调用数,缓存层命中数,存储层命中数,如果发现大量存储空命中,
    可能出现了缓存穿透现象.
### 2.3.3.缓存穿透产生原因
    (1).业务自身代码或者数据出现问题
    (2).一些恶意攻击、爬虫等造成大量空命中
### 2.3.4.缓存穿透的解决方法
    (1).缓存空对象:当下列第二步存储层不命中后,仍然将空对象保留到缓存层中,之后再访问这个数据时
        将会从缓存中获取,保护后端数据源
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/Java架构/image/cache/缓存穿透-空对象.png)

        缓存空对象存在两个问题:
        * 空值做了缓存,意味着缓存层中存了更多的键,需要更多的内存空间.比较有效的方法是针对这类数
          据设置一个较短的过期时间,让其自动剔除;
          或者可以将空值放在其他的缓存空间,否则当空间不足时,缓存系统的LRU算法可能会先剔除正常值,再剔除空值.
        * 缓存层和存储层的数据会有一段时间窗口的不一致,可能会对业务有一定的影响.
          可以利用消息系统或者其他方式清除掉缓存层中的空对象.
    --> 缓存空对象伪代码:
```java
String get(String key){
    // 从缓存中获取数据
    String cacheValue = cache.get(key);
    if(StringUtils.isBlank(cacheValue)){
        // 从存储中获取数据
        String storageValue = storage.get(key);
        cache.set(key, storageValue);
        // 如果存储数据为空,需要设置一个过期时间
        if(storageValue == null){
            cache.expire(key, 60*5);
        }
        return storageValue;
    } else {
        // 缓存非空
        return cacheValue;
    }
}
```
    (2).布隆过滤器拦截
        
## 2.4.缓存雪崩

# 2.缓存最佳实践
    (1).缓存系统主要消耗的是服务器的内存,因此,在使用缓存时必须先对应用需要缓存的数据大小进行评估,
        包括缓存的数据结构、缓存大小、缓存数量、缓存的失效时间,然后根据业务情况自行推算未来一段时间
        容量的使用情况,根据容量评估的结果来申请和分配缓存资源,否则会造成资源浪费或者缓存空间不够;
    (2).将使用缓存的业务进行分离,核心业务和非核心业务使用不同的缓存实例,从物理上进行隔离,如果有条件,
        则请对么个业务使用单独的实例或者集群,以减少应用之间互相影响的可能性.
    (3).根据缓存实例提供的内存大小推送应用需要使用的缓存实例数量;
    (4).缓存一般是用来加速数据库的读材质的,一般先访问缓存后访问数据库,所以缓存的超时时间设置很重要.
        有可能缓存超时设置较长,从而拖垮服务的线程池,最终导致服务雪崩;
    (5).所有的缓存实例都需要添加监控,需要对慢查询,大对象,内存使用情况做可靠的监控;
    (6).如果多个业务共享一个缓存实例,需要通过规范来限制各个应用使用的key一定要有唯一的前缀,并进行
        隔离设计,避免缓存互相覆盖的问题产生;
    (7).任何缓存的ke都必须设定缓存失效时间,且失效时间不能集中在某一点,否则会导致缓存占满内存或者缓存穿透.
    (8).低频访问的数据不要放在缓存中;
    (9).缓存的数据不易过大,尤其是redis,因为redi使用的是单线程模型,单个缓存key的数据过大时,会阻塞其他请求处理;
    (10).对于存储较多value饿key,尽量不要使用HGETALL等集合操作,该操作会造成请求阻塞,影响其他应用的访问;
    (11).缓存一般用于交易系统中加速查询的场景,有大量的更新数据时,尤其是批量处理,请使用批量模式;
    (12).如果对性能要求不是非常高,尽量使用分布式缓存,不要使用本地缓存,因为本地缓存在服务的各个节点
        之间复制,在某一时刻副本之间的是不一致的;
    (13).写缓存时一定写入完全正确的数据,如果缓存数据一部分有效,一部分无效,则宁可放弃缓存,也不要把部分数
        据写入缓存,否则会造成空指针,程序异常等;
    (14).在通常情况下,读的顺序是先缓存、后数据库；写的顺序是先数据库、后缓存.
    (15).当使用本地缓存时,一定要严格控制缓存对象的个数和生命周期.由于JVM特性,过多的缓存对象会极大影响
        JVM性能,甚至导致内存溢出等问题出现.
    (16).在使用缓存时,一定有降级处理,尤其对关键业务环节,缓存有问题或者失效也要能回溯到数据库进行处理.

# 参考文章

* [高性能网站设计之缓存更新的套路](http://blog.csdn.net/tTU1EvLDeLFq5btqiK/article/details/78693323)
* [缓存穿透、雪崩](https://segmentfault.com/a/1190000008931971)
* [缓存穿透、缓存并发、热点缓存之最佳招式](http://blog.didispace.com/chengchao-huancun-zuijiazhaoshi/)
* [分布式缓存击穿](http://www.cnblogs.com/rjzheng/p/8908073.html)
