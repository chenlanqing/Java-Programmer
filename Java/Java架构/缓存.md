<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [1.缓存](#1%E7%BC%93%E5%AD%98)
- [2.高并发环境下缓存场景问题:](#2%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98)
  - [2.1.缓存一致性](#21%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7)
  - [2.2.缓存并发问题](#22%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98)
  - [2.3.缓存穿透现象;](#23%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%8E%B0%E8%B1%A1)
  - [2.4.缓存的雪崩现象](#24%E7%BC%93%E5%AD%98%E7%9A%84%E9%9B%AA%E5%B4%A9%E7%8E%B0%E8%B1%A1)
- [2.缓存最佳实践](#2%E7%BC%93%E5%AD%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 1.缓存
# 2.高并发环境下缓存场景问题:
## 2.1.缓存一致性
    (1).更新数据库成功,更新缓存失败 -> 数据不一致
    (2).更新缓存成功,更是数据库失败 -> 数据不一致
    (3).更新数据库成功,淘汰缓存失败 -> 数据不一致
    (4).淘汰缓存成功,更新数据库失败 -> 查询缓存miss
## 2.2.缓存并发问题
## 2.3.缓存穿透现象;
## 2.4.缓存的雪崩现象

# 2.缓存最佳实践
    (1).缓存系统主要消耗的是服务器的内存,因此,在使用缓存时必须先对应用需要缓存的数据大小进行评估,
        包括缓存的数据结构、缓存大小、缓存数量、缓存的失效时间,然后根据业务情况自行推算未来一段时间
        容量的使用情况,根据容量评估的结果来申请和分配缓存资源,否则会造成资源浪费或者缓存空间不够;
    (2).将使用缓存的业务进行分离,核心业务和非核心业务使用不同的缓存实例,从物理上进行隔离,如果有条件,
        则请对么个业务使用单独的实例或者集群,以减少应用之间互相影响的可能性.
    (3).根据缓存实例提供的内存大小推送应用需要使用的缓存实例数量;
    (4).缓存一般是用来加速数据库的读材质的,一般先访问缓存后访问数据库,所以缓存的超时时间设置很重要.
        有可能缓存超时设置较长,从而拖垮服务的线程池,最终导致服务雪崩;
    (5).所有的缓存实例都需要添加监控,需要对慢查询,大对象,内存使用情况做可靠的监控;
    (6).如果多个业务共享一个缓存实例,需要通过规范来限制各个应用使用的key一定要有唯一的前缀,并进行
        隔离设计,避免缓存互相覆盖的问题产生;
    (7).任何缓存的ke都必须设定缓存失效时间,且失效时间不能集中在某一点,否则会导致缓存占满内存或者缓存穿透.
    (8).低频访问的数据不要放在缓存中;
    (9).缓存的数据不易过大,尤其是redis,因为redi使用的是单线程模型,单个缓存key的数据过大时,会阻塞其他请求处理;
    (10).对于存储较多value饿key,尽量不要使用HGETALL等集合操作,该操作会造成请求阻塞,影响其他应用的访问;
    (11).缓存一般用于交易系统中加速查询的场景,有大量的更新数据时,尤其是批量处理,请使用批量模式;
    (12).如果对性能要求不是非常高,尽量使用分布式缓存,不要使用本地缓存,因为本地缓存在服务的各个节点
        之间复制,在某一时刻副本之间的是不一致的;
    (13).写缓存时一定写入完全正确的数据,如果缓存数据一部分有效,一部分无效,则宁可放弃缓存,也不要把部分数
        据写入缓存,否则会造成空指针,程序异常等;
    (14).在通常情况下,读的顺序是先缓存、后数据库；写的顺序是先数据库、后缓存.
    (15).当使用本地缓存时,一定要严格控制缓存对象的个数和生命周期.由于JVM特性,过多的缓存对象会极大影响
        JVM性能,甚至导致内存溢出等问题出现.
    (16).在使用缓存时,一定有降级处理,尤其对关键业务环节,缓存有问题或者失效也要能回溯到数据库进行处理.

# 参考文章

* [高性能网站设计之缓存更新的套路](http://blog.csdn.net/tTU1EvLDeLFq5btqiK/article/details/78693323)
* [缓存穿透、雪崩](https://segmentfault.com/a/1190000008931971)
* [缓存穿透、缓存并发、热点缓存之最佳招式](http://blog.didispace.com/chengchao-huancun-zuijiazhaoshi/)

