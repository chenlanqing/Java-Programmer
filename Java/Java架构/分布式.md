<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一.分布式系统](#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)
  - [1.分布式系统](#1%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)
  - [2.为什么要用分布式系统](#2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)
  - [3.集群](#3%E9%9B%86%E7%BE%A4)
  - [4.集群和分布式](#4%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F)
- [二.分布式事务](#%E4%BA%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
- [三.分布式session](#%E4%B8%89%E5%88%86%E5%B8%83%E5%BC%8Fsession)
- [四.分布式锁](#%E5%9B%9B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
  - [1.分布式锁:](#1%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
  - [2.数据库分布式锁](#2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
  - [3.Redis分布式锁](#3redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
  - [4.Zookeeper分布式锁](#4zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
- [五.分布式缓存](#%E4%BA%94%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98)
- [六.分布式其他问题](#%E5%85%AD%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98)
  - [1.幂等性](#1%E5%B9%82%E7%AD%89%E6%80%A7)
- [七.分布式ID:](#%E4%B8%83%E5%88%86%E5%B8%83%E5%BC%8Fid)
  - [1.ID生成的核心需求:](#1id%E7%94%9F%E6%88%90%E7%9A%84%E6%A0%B8%E5%BF%83%E9%9C%80%E6%B1%82)
  - [2.数据库自增长序列或字段:最常见的方式,利用数据库,全库唯一](#2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E9%95%BF%E5%BA%8F%E5%88%97%E6%88%96%E5%AD%97%E6%AE%B5%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A8%E5%BA%93%E5%94%AF%E4%B8%80)
  - [3.UUID:](#3uuid)
  - [4.Redis生成ID](#4redis%E7%94%9F%E6%88%90id)
  - [5.Twitter-Snowflake](#5twitter-snowflake)
  - [6.MongoDB的ObjectId](#6mongodb%E7%9A%84objectid)
  - [7.分布式唯一ID需要满足的条件](#7%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%9D%A1%E4%BB%B6)
- [参考文章:](#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 一.分布式系统
## 1.分布式系统
	由多个节点组成的系统,节点之前相互连通;
	把一个计算任务分解成若干个计算单元,并且分派到若干不同的计算机中去执行,然后汇总计算结果的过程
## 2.为什么要用分布式系统
	(1).升级单机处理能力的性价比越来越低;
	(2).单机处理能力存在瓶颈;
	(3).出于稳定性和可用性考虑;
## 3.集群

## 4.集群和分布式
	(1).集群是每台服务器都具有相同的功能,处理请求时调用哪台服务器都可以,主要是分流作用
		分布式是将不同的业务放到不同的服务器中,处理一个请求可能需要用到多台服务器.
	(2).集群主要有:静态资源集群和应用程序集群.
		session同步是集群和分布式一个核心问题.
		session同步有两种处理方式:一种是在 session 发生变化后自动同步到其他服务器,另一种就是用一个程序统一管理session.
		tomcat 默认使用的是第一种.第二种需要安装高效的缓存程序来统一管理session.

# 二.分布式事务

# 三.分布式session

# 四.分布式锁
## 1.分布式锁:
	在分布式环境下,保证一个方法在同一时间只有一个线程能调用一个方法,或者多个客户端同时对一个服务请求时,
	需要使用分布式锁.
	1.1.分布式锁应该是怎样的?
	* 可以保证在分布式部署的应用集群中,同一个方法在同一时间只能被一台机器上的一个线程执行;
	* 这把锁要是一把可重入锁(避免死锁)
	* 这把锁最好可以是一把阻塞锁;
	* 有高可用的获取锁和释放锁功能;
	* 获取锁和释放锁的性能要好
	1.2.分布式锁的实现方案:
		(1).基于数据库实现分布式锁;
		(2).基于缓存(redis,tair)等;
		(3).基于zookeeper实现分布式锁
## 2.数据库分布式锁
### 2.1.基于数据库表
	要实现分布式锁,最简单的方式可能就是直接创建一张锁边,然后通过操作该表中的数据来实现.
	当要锁住某个方法或者资源时,就在该表中增加一条记录,如果要释放锁就删除该记录.
## 3.Redis分布式锁

## 4.Zookeeper分布式锁

# 五.分布式缓存

# 六.分布式其他问题
## 1.幂等性
### 1.1.定义
	1.1.1.数学定义:在数学里,幂等主要有两种定义
		(1).在某一个二元运算下,幂等元素是指被自己重复运算的结果等于它自己,例如乘法下唯一的两个幂等实数为0和1;
		(2).某一元运算为幂等时,其作用在任一元素两次后和其作用一次的结果都相同.例如高斯符号便是幂等:f(f(x))=f(x)
	1.1.2.HTTP规范定义:
		HTTP幂等性指的是一次或者多次请求某一个资源应该具有相同的副作用.如果通过PUT解决将数据的status置为1
		无论是第一次执行还是多次执行,获取到的结果应该是相同的,即执行完成之后Status =1
### 1.2.何种接口提供幂等性
	1.2.1.在HTTP规范中定义GET,PUT和DELETE方法应该具有幂等性:
		(1).GET:是向服务器查询,不会对系统产生副作用,具有幂等性(不代表每次请求相同的结果)
		(2).PUT:首先判断系统中是否有相关的记录，如果有记录则更新该记录，如果没有则新增记录
		(3).DELETE:删除服务器上的相关记录
# 七.分布式ID:
## 1.ID生成的核心需求:
	1.1.全局唯一:需要单独设置一个和业务无关的主键,专业术语叫做代理主键
		这也是为什么数据库设计范式,唯一主键是第一范式!
	1.2.趋势有序:InnoDB引擎表是基于B+树的索引组织表(IOT),每个表都需要有一个聚集索引,所有的行记录都存储在B+树的叶子节点(leaf pages of the tree)
		基于聚集索引的增、删、改、查的效率相对是最高的
		(1).如果我们定义了主键(PRIMARY KEY),那么InnoDB会选择其作为聚集索引;
		(2).如果没有显式定义主键,则InnoDB会选择第一个不包含有 NULL .值的唯一索引作为主键索引
		(3).如果也没有这样的唯一索引,则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引
			(ROWID随着行记录的写入而主键递增,这个ROWID不像ORACLE的ROWID那样可引用,是隐含的)
		==> 如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话,这时候存取效率是最高的,也就是下面几种情况效率最高:
			Ⅰ.使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致
			Ⅱ.该表不指定自增列做主键,同时也没有可以被选为主键的唯一索引(上面的条件),这时候InnoDB会选择内置的ROWID作为主键,写入顺序和ROWID增长顺序一致
			Ⅲ.除此以外,如果一个InnoDB表又没有显示主键,又有可以被选择为主键的唯一索引,但该唯一索引可能不是递增关系时
				(例如字符串、UUID、多字段联合唯一索引的情况),该表的存取效率就会比较差
## 2.数据库自增长序列或字段:最常见的方式,利用数据库,全库唯一
	2.1.优点:
		(1).简单,代码方便,性能可以接受;
		(2).数字ID天然排序,对分页或者需要排序的结果很有帮助
	2.2.缺点:
		(1).不同数据库语法和实现不同,数据库迁移的时候或多数据库版本支持的时候需要处理;
		(2).在单个数据库或读写分离或一主多从的情况下,只有一个主库可以生成.有单点故障的风险
		(3).在性能达不到要求的情况下,比较难于扩展;
		(4).如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦; 分表分库的时候会有麻烦
	2.3.优化方案:
		针对主库单点,如果有多个Master库,则每个Master库设置的起始数字不一样,步长一样,可以是Master的个数.
## 3.UUID:
	3.1.优点:
		(1).简单,代码方便.
		(2).生成ID性能非常好,基本不会有性能问题.
		(3).全球唯一,在遇见数据迁移,系统数据合并,或者数据库变更等情况下,可以从容应对
	3.2.缺点:
		(1).没有排序,无法保证趋势递增;
		(2).UUID往往是使用字符串存储,查询的效率比较低;
		(3).存储空间比较大,如果是海量数据库,就需要考虑存储量的问题;
		(4).传输数据量大\不可读
		(5).不可读
	3.3.为什么UUI会导致数据库性能变差:
		涉及到B+数索引的分裂:
		果我们的ID按递增的顺序来插入,比如陆续插入8，9，10,新的ID都只会插入到最后一个节点当中.当最后一个节点满了,
		会裂变出新的节点.这样的插入是性能比较高的插入,因为这样节点的分裂次数最少,而且充分利用了每一个节点的空间.
		但是,如果我们的插入完全无序,不但会导致一些中间节点产生分裂,也会白白创造出很多不饱和的节点,
		这样大大降低了数据库插入的性能
## 4.Redis生成ID
	当使用数据库来生成ID性能不够要求的时候,可以尝试使用Redis来生成.主要依赖于Redis是单线程的,所以可以用于
	生成全局唯一ID.(使用Redis的原子操作incr 和 incrby 来实现)
	比较适合使用Redis来生成每天从0开始的流水号.
	4.1.优点:
		(1).不依赖于数据库,灵活方便,且性能优于数据库;
		(2).数字ID天然排序,对分页或者需要排序的结果很有帮助;
	4.2.缺点:
		(1).如果系统中没有Redis,还需要引入新的组件,增加系统复杂度
		(2).需要编码和配置的工作量比较大
## 5.Twitter-Snowflake
	5.1.Snowflake算法组成:
		(1).占用1bit,其值始终是0,没有实际作用;
		(2).41位的时间序列(精确到毫秒,41位的长度可以使用69年)
		(3).10位的机器标识(其中高位5bit是数据中心ID,低位5bit是工作节点,10位的长度最多支持部署1024个节点)
		(4).12位的计数顺序号(12位的计数顺序号支持每个节点每毫秒产生4096个ID序号).最高位是符号位,始终为0
	算法示意图:
![image](https://github.com/chenlanqing/learningNote/blob/master/数据库/MySQL/image/snowflake-64bit.jpg)

		SnowFlake算法在同一毫秒内最多可以生成全局ID个数:1024 X 4096 =  4194304

	5.2.优点:
		(1).不依赖数据库等第三方系统,以服务的方式部署,稳定性更高,生成ID的性能也是非常高的;
		(2).按时间有序,毫秒数在高位,自增序列在低位,整个ID都是趋势递增的
	5.3.缺点:
		强依赖机器时钟,如果机器上时钟回拨,会导致发号重复或者服务会处于不可用状态
		--> 解决时间问题:需要关闭ntp的时间同步功能,或者当检测到ntp时间调整后,拒绝分配id
## 6.MongoDB的ObjectId
	6.1.ObjectId使用12字节的存储空间,其生成方式如下:
		|0|1|2|3|4|5|6 |7|8|9|10|11|
		|时间戳 |机器ID|PID|计数器 |
		前四个字节时间戳是从标准纪元开始的时间戳,单位为秒,有如下特性:
		(1).时间戳与后边5个字节一块,保证秒级别的唯一性;
		(2).保证插入顺序大致按时间排序
		(3).隐含了文档创建时间;
		(4).时间戳的实际值并不重要,不需要对服务器之间的时间进行同步
	时间戳保证秒级唯一,机器ID保证设计时考虑分布式,避免时钟同步,PID保证同一台服务器运行
	多个mongod实例时的唯一性,最后的计数器保证同一秒内的唯一性

## 7.分布式唯一ID需要满足的条件
	(1).高可用:不能有单点故障
	(2).全局唯一性:不能出现重复的ID号,既然是唯一标识,这是最基本的要求;
	(3).趋势递增:在MySQL InnoDB引擎中使用的是聚集索引,
		在主键的选择上面我们应该尽量使用有序的主键保证写入性能
	(4).时间有序:以时间为序,或者ID里包含时间
		这样一是可以少一个索引,二是冷热数据容易分离;
	(5).分片支持:可以控制ShardingId
	(6).单调递增:保证下一个ID一定大于上一个ID,例如事务版本号、IM增量消息、排序等特殊需求;
	(7).长度适中:不要太长，最好64bit
	(8).信息安全:如果ID是连续的,恶意用户的扒取工作就非常容易做了,直接按照顺序下载指定URL即可;	


# 参考文章:

* [幂等性](http://blog.brucefeng.info/post/api-idempotent)
* [分布式锁的几种实现方式](http://www.hollischuang.com/archives/1716)
* [分布式事务](https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html)
* [分布式服务系统一致性](https://blog.csdn.net/rickiyeat/article/details/70224722)
* [深入理解分布式事务](http://www.codeceo.com/article/distributed-transaction.html)
* [分布式唯一ID](https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA)
* [分布式自增ID算法snowflake](https://blog.csdn.net/li396864285/article/details/54668031)







