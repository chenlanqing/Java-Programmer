# 一、系统架构设计

https://mp.weixin.qq.com/s/zr4dkkpy5_QnifTPA7XkdQ
https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md

约定大于配置

## 1、基础理论

## 2、高并发系统设计

### 2.1、设计原则

- 局部并发原则：比如电商场景中的下单链路，涉及到商品检查、用户信息检查、生成付款连接、地址信息、订单快照等，其中没有相互依赖的可以并行处理；
- 服务化拆分：主链路规划

## 3、高可用系统设计

### 3.1、设计原则

- 降级：多级降级
    - 主动降级：开关推送
    - 被动降级：超时降级、异常降级、失败率、熔断保护

- 限流：压测确定限流阈值、动态调整限流
    - 网关层限流：Nginx、Redis+Lua
    - 业务层限流：本地限流（Guava）、分布式限流（sentinel）

- 弹性计算：全链路都要弹性计算（K8S+Docker）

- 流量切换：多机房环境
    - DNS：域名切换入库、Client端流量调度
    - 虚IP：HaProxy、LVS负载均衡
    - 应用层：Nginx + 服务网关

- 回滚：
    - 版本控制：配置中心、CICD Pipeline

## 4、有限状态机

spring statemachine

# 二、池化技术设计

## 1、对象池

Commons-Pool2

## 2、数据库连接池

- [数据库连接池比较](http://blog.didispace.com/java-datasource-pool-compare/)

### 2.1、基本思想

数据库连接池的基本思想是：为数据库连接建立一个“缓冲池”，预先在池中放入一定数量的数据库连接管道，需要时，从池子中取出管道进行使用，操作完毕后，在将管道放入池子中，从而避免了频繁的向数据库申请资源，释放资源带来的性能损耗

### 2.2、数据库连接池需要考虑的问题

- 限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。
- 当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。
- 当客户不在使用连接，需要把连接重新放回连接池。
- 连接池中允许处于空闲状态的连接的最大项目。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5
- 程序退出时，断开所有连接，并释放资源

### 2.3、设计模式

### 2.4、调优

经验公式：连接数 = 2N + 可用磁盘数

## 3、Redis连接池

## 4、HTPP连接池


# 三、数据库设计

## 1、数据库字段逻辑删除

逻辑删除存在的问题：
- 所有查询都需要加上 `where status != deleted`，包括 `select count(*)` 这类操作；
- 表结构里面不能有一致性约束的业务字段，比如：username、手机号、身份证这类字段，不然就存在问题；（删除时加上前缀也存在类似问题，多次删除，还需要加上时间）；
- 如果有外键约束或者是表 join 的话，那问题会变得更复杂，所有的表都需要加 status != deleted；

关于逻辑删除正确解法：回归到业务上——究竟什么是真正的X问题：
- 如果x问题是需要备份的数据，应该走的是数据备份，而不是软删除；
- 如果x问题是需要归档的数据，应该走的是归档流程；
- 如果x问题只是需要冻结数据，应该做 inactive 的标记，这样在语义是非常好的，而一致性约束同样没有问题；

## 2、新零售系统数据库设计

### 2.1、SPU、SKU

SPU：标准产品单位，SPU描述一个产品的特性

- SKU：stock Keeping Unit，是库存进出计量单位，SKU是物理上不可分割的最小存货单元；

### 2.2、表设计

#### 2.2.1、商品设计

- SKU与权重：新零售平台主要是B2C的，所以修改SU对权重的影响不大。但是B2B的平台，修改SKU对商品权重影响很大。

- SKU与参数对应：

    ![](图片/参数与SKU的关系.png)

    
#### 2.2.2、设计品类与参数表

- 品类数据结构
    
    ```sql
    create table t_spec_group(
        id int UNSIGNED PRIMARY key auto_increment comment '主键',
        spg_id int UNSIGNED not null comment '品类编号',
        `name` varchar(200) not null comment '品类名称',
        UNIQUE index unq_spg_id(spg_id),
        UNIQUE index unq_name(`name`),
        index idx_spg_id(spg_id)
    ) COMMENT='品类表';
    ```
- 品类参数数据结构

#### 2.2.3、设计品牌与分类关系

- 品牌表

- 分类表

- 品牌与分类关系表

#### 2.2.4、设计产品表和商品表

- 产品表


- 商品表

#### 2.2.5、设计商品的库存

如果新零售系统没有分店，可以直接把库存定义到商品表中

零售店与仓库的对应关系、零售店与仓库、商品的关系

- 省份与城市

- 仓库与库存

- 零售店与库存

#### 2.2.6、客户表

- 会员等级表

- 客户表

- 客户收货地址

#### 2.2.7、设计购物券

- 购物券表

- 客户与购物券关联

#### 2.2.8、设计订单表

- 订单表

- 订单详情

#### 2.2.8、设计员工与用户表

新零售系统具有进销存属性，需要员工表、用户表、角色表

- 部分、职位、员工

- 用户

- 角色

#### 2.2.9、设计快递表、退货表

- 快递表

- 退货表

#### 2.2.10、设计评价表

- 评价表

#### 2.2.11、供应商数据表

- 供货商信息
- 供货商对应的商品


#### 2.2.12、设计采购和入库数据表

- 采购表

- 入库表

- 采购与入库的关联关系

### 2.3、ER图与数据库模型

### 2.4、如何避免篡改商品信息

需要保留商品历史信息，需要保存SPU、SKU两张表的修改记录；

### 2.5、订单拆分

- 根据仓库与收货人的地址进行拆分，可以通过高德地图获取到对应仓库和收货人地址的经纬度，通过mysql计算两点之间的距离：st_distance函数可以计算两个坐标之间相差的度数
    ```sql
    select st_distance(
        point(116, 39),
        point(121, 31)
    ) * 111195 / 1000;

    ```

# 四、API设计

## 1、设计对外安全的API

### 1.1、安全措施

个人觉得安全措施大体来看主要在两个方面，一方面就是如何保证数据在传输过程中的安全性，另一个方面是数据已经到达服务器端，服务器端如何识别数据，如何不被攻击；下面具体看看都有哪些安全措施。

#### 1、数据加密

我们知道数据在传输过程中是很容易被抓包的，如果直接传输比如通过http协议，那么用户传输的数据可以被任何人获取；所以必须对数据加密，常见的做法对关键字段加密比如用户密码直接通过md5加密；现在主流的做法是使用https协议，在http和tcp之间添加一层加密层(SSL层)，这一层负责数据的加密和解密；

#### 2、数据加签

数据加签就是由发送者产生一段无法伪造的一段数字串，来保证数据在传输过程中不被篡改；你可能会问数据如果已经通过https加密了，还有必要进行加签吗？数据在传输过程中经过加密，理论上就算被抓包，也无法对数据进行篡改；但是我们要知道加密的部分其实只是在外网，现在很多服务在内网中都需要经过很多服务跳转，所以这里的加签可以防止内网中数据被篡改；

#### 3、时间戳机制

数据是很容易被抓包的，但是经过如上的加密，加签处理，就算拿到数据也不能看到真实的数据；但是有不法者不关心真实的数据，而是直接拿到抓取的数据包进行恶意请求；这时候可以使用时间戳机制，在每次请求中加入当前的时间，服务器端会拿到当前时间和消息中的时间相减，看看是否在一个固定的时间范围内比如5分钟内；这样恶意请求的数据包是无法更改里面时间的，所以5分钟后就视为非法请求了；如果在设置的超时时间范围内，是不能阻止DoS攻击的。timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理

#### 4、AppId机制

大部分网站基本都需要用户名和密码才能登录，并不是谁来能使用我的网站，这其实也是一种安全机制；对应的对外提供的接口其实也需要这么一种机制，并不是谁都可以调用，需要使用接口的用户需要在后台开通appid，提供给用户相关的密钥；在调用的接口中需要提供appid+密钥，服务器端会进行相关的验证；

#### 5、限流机制

本来就是真实的用户，并且开通了appid，但是出现频繁调用接口的情况；这种情况需要给相关appid限流处理，常用的限流算法有令牌桶和漏桶算法；

#### 6、黑名单机制

如果此appid进行过很多非法操作，或者说专门有一个中黑系统，经过分析之后直接将此appid列入黑名单，所有请求直接返回错误码；

#### 7、数据合法性校验

这个可以说是每个系统都会有的处理机制，只有在数据是合法的情况下才会进行数据处理；每个系统都有自己的验证规则，当然也可能有一些常规性的规则，比如身份证长度和组成，电话号码长度和组成等等；

### 1.2、如何实现

以上大体介绍了一下常用的一些接口安全措施，当然可能还有其他我不知道的方式，希望大家补充，下面看看以上这些方法措施，具体如何实现；

#### 1、数据加密

现在主流的加密方式有对称加密和非对称加密；  
- **对称加密**：对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES，AES；优点是计算速度快，缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了；  
- **非对称加密**：服务端会生成一对密钥，私钥存放在服务器端，公钥可以发布给任何人使用；优点就是比起对称加密更加安全，但是加解密的速度比对称加密慢太多了；广泛使用的是RSA算法；

两种方式各有优缺点，而https的实现方式正好是结合了两种加密方式，整合了双方的优点，在安全和性能方面都比较好；

对称加密和非对称加密代码实现，jdk提供了相关的工具类可以直接使用，此处不过多介绍；  
关于https如何配置使用相对来说复杂一些，可以参考本人的之前的文章[HTTPS分析与实战](https://my.oschina.net/OutOfMemory/blog/1620342)

#### 2、数据加签

数据签名使用比较多的是md5算法，将需要提交的数据通过某种方式组合和一个字符串，然后通过md5生成一段加密字符串，这段加密字符串就是数据包的签名，可以看一个简单的例子：

```java
str：参数1={参数1}&参数2={参数2}&……&参数n={参数n}$key={用户密钥};
MD5.encrypt(str);
```

注意最后的用户密钥，客户端和服务端都有一份，这样会更加安全；一般是根据某些参数来进行拼接在一起，然后根据某种算法来实现；数据传递方根据对应的数据进行加签操作；

#### 3、时间戳机制

解密后的数据，经过签名认证后，我们拿到数据包中的客户端时间戳字段，然后用服务器当前时间去减客户端时间，看结果是否在一个区间内，伪代码如下：

```java
long interval=5*60*1000；//超时时间
long clientTime=request.getparameter("clientTime");
long serverTime=System.currentTimeMillis();
if(serverTime-clientTime>interval){
    return new Response("超过处理时长")
}
```

#### 4、AppId机制

生成一个唯一的AppId即可，密钥使用字母、数字等特殊字符随机生成即可；生成唯一AppId根据实际情况看是否需要全局唯一；但是不管是否全局唯一最好让生成的Id有如下属性：  

**趋势递增**：这样在保存数据库的时候，使用索引性能更好；  

**信息安全**：尽量不要连续的，容易发现规律；  

关于全局唯一Id生成的方式常见的有类snowflake方式等；

#### 5、限流机制

常用的限流算法包括：令牌桶限流，漏桶限流，计数器限流；

**1、令牌桶限流** 

令牌桶算法的原理是系统以一定速率向桶中放入令牌，填满了就丢弃令牌；请求来时会先从桶中取出令牌，如果能取到令牌，则可以继续完成请求，否则等待或者拒绝服务；令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌；  

**2、漏桶限流**  

漏桶算法的原理是按照固定常量速率流出请求，流入请求速率任意，当请求数超过桶的容量时，新的请求等待或者拒绝服务；可以看出漏桶算法可以强制限制数据的传输速度； 

**3、计数器限流**  
计数器是一种比较简单粗暴的算法，主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流；

具体基于以上算法如何实现，Guava提供了RateLimiter工具类基于基于令牌桶算法：

```
RateLimiter rateLimiter = RateLimiter.create(5);
```

以上代码表示一秒钟只允许处理五个并发请求，以上方式只能用在单应用的请求限流，不能进行全局限流；这个时候就需要分布式限流，可以基于redis+lua来实现；

#### 6、黑名单机制

如何为什么中黑我们这边不讨论，我们可以给每个用户设置一个状态比如包括：初始化状态，正常状态，中黑状态，关闭状态等等；或者我们直接通过分布式配置中心，直接保存黑名单列表，每次检查是否在列表中即可；

#### 7、数据合法性校验

合法性校验包括：常规性校验以及业务校验；  
常规性校验：包括签名校验，必填校验，长度校验，类型校验，格式校验等；  
业务校验：根据实际业务而定，比如订单金额不能小于0等；

## 2、如何优化接口访问速度

### 2.1、主要涉及点

- 针对 HTTP 请求的优化，是否能升级 HTTP 1.1 到 HTTP2 ？
- 针对带宽瓶颈的升级？
- 是否做了 DNS 缓存？
- 可以通过 LBS 等负载功能提高集群的吞吐量以充分利用单机的性能？
- 是否可以添加缓存？
- 是否热点数据不均衡？
- 是否有慢 SQL ？
- 是否可以通过分库分表解决？
- 是否可以通过读写分离解决？
- 是否代码上面可以优化？
- 是否可以使用无锁编程？
- 是否可以调整 GC 策略？

## 3、开放平台API使用流程

- 接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数
- 客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign=加密(appId + timestamp + key)
- 客户端拿着api_token 去访问不需要登录就能访问的接口
- 当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口

# 五、缓存设计

## 1、缓存设计

### 1.1、考虑点

考虑点主要在数据用何种方式存储，能存储多少数据，多余的数据如何处理等几个点，下面我们来详细的介绍每个考虑点，以及该如何去实现；

#### 1、数据结构

首要考虑的就是数据该如何存储，用什么数据结构存储，最简单的就直接用Map来存储数据；或者复杂的如redis一样提供了多种数据类型哈希，列表，集合，有序集合等，底层使用了双端链表，压缩列表，集合，跳跃表等数据结构；

#### 2、对象上限

因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如1024，当达到某个上限后需要有某种策略去删除多余的数据；

#### 3、清除策略

上面说到当达到对象上限之后需要有清除策略，常见的比如有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)等策略；

#### 4、过期时间

除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如redis可以给每个key设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略+过期时间双重保证；

#### 5、线程安全

像redis是直接使用单线程处理，所以就不存在线程安全问题；而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题；并且线程安全问题是不应该抛给使用者去保证；

#### 6、简明的接口

提供一个傻瓜式的对外接口是很有必要的，对使用者来说使用此缓存不是一种负担而是一种享受；提供常用的get，put，remove，clear，getSize方法即可；

#### 7、是否持久化

这个其实不是必须的，是否需要将缓存数据持久化看需求；本地缓存如ehcache是支持持久化的，而guava是没有持久化功能的；分布式缓存如redis是有持久化功能的，memcached是没有持久化功能的；

#### 8、阻塞机制

在看Mybatis源码的时候，二级缓存提供了一个blocking标识，表示当在缓存中找不到元素时，它设置对缓存键的锁定；这样其他线程将等待此元素被填充，而不是命中数据库；其实我们使用缓存的目的就是因为被缓存的数据生成比较费时，比如调用对外的接口，查询数据库，计算量很大的结果等等；这时候如果多个线程同时调用get方法获取的结果都为null，每个线程都去执行一遍费时的计算，其实也是对资源的浪费；最好的办法是只有一个线程去执行，其他线程等待，计算一次就够了；但是此功能基本上都交给使用者来处理，很少有本地缓存有这种功能；

### 1.2、如何实现

以上大致介绍了实现一个本地缓存我们都有哪些需要考虑的地方，当然可能还有其他没有考虑到的点；下面继续看看关于每个点都应该如何去实现，重点介绍一下思路；

#### 1、数据结构

本地缓存最常见的是直接使用Map来存储，比如guava使用ConcurrentHashMap，ehcache也是用了ConcurrentHashMap，Mybatis二级缓存使用HashMap来存储：

```
Map<Object, Object> cache = new ConcurrentHashMap<Object, Object>()
```

Mybatis使用HashMap本身是非线程安全的，所以可以看到起内部使用了一个SynchronizedCache用来包装，保证线程的安全性；  
当然除了使用Map来存储，可能还使用其他数据结构来存储，比如redis使用了双端链表，压缩列表，整数集合，跳跃表和字典；当然这主要是因为redis对外提供的接口很丰富除了哈希还有列表，集合，有序集合等功能；

#### 2、对象上限

本地缓存常见的一个属性，一般缓存都会有一个默认值比如1024，在用户没有指定的情况下默认指定；当缓存的数据达到指定最大值时，需要有相关策略从缓存中清除多余的数据这就涉及到下面要介绍的清除策略；

#### 3、清除策略

配合对象上限之后使用，场景的清除策略如：LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)；  
**LRU**：Least Recently Used的缩写最近最少使用，移除最长时间不被使用的对象；常见的使用LinkedHashMap来实现，也是很多本地缓存默认使用的策略；  
**FIFO**：先进先出，按对象进入缓存的顺序来移除它们；常见使用队列Queue来实现；  
**LFU**：Least Frequently Used的缩写大概也是最近最少使用的意思，和LRU有点像；区别点在LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的；可以通过HashMap并且记录访问次数来实现；  
**SOFT**：软引用基于垃圾回收器状态和软引用规则移除对象；常见使用SoftReference来实现；  
**WEAK**：弱引用更积极地基于垃圾收集器状态和弱引用规则移除对象；常见使用WeakReference来实现；

#### 4、过期时间

设置过期时间，让缓存数据在指定时间过后自动删除；常见的过期数据删除策略有两种方式：被动删除和主动删除；  
**被动删除**：每次进行get/put操作的时候都会检查一下当前key是否已经过期，如果过期则删除，类似如下代码：

```java
if (System.currentTimeMillis() - lastClear > clearInterval) {
      clear();
}
```

**主动删除**：专门有一个job在后台定期去检查数据是否过期，如果过期则删除，这其实可以有效的处理冷数据；

#### 5、线程安全

尽量用线程安全的类去存储数据，比如使用ConcurrentHashMap代替HashMap；或者提供相应的同步处理类，比如Mybatis提供了SynchronizedCache：

```java
 public synchronized void putObject(Object key, Object object) {
    ...省略...
  }

  @Override
  public synchronized Object getObject(Object key) {
    ...省略...
  }
```

#### 6、简明的接口

提供常用的get，put，remove，clear，getSize方法即可，比如Mybatis的Cache接口：

```java
public interface Cache {
  String getId();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  Object removeObject(Object key);
  void clear();
  int getSize();
  ReadWriteLock getReadWriteLock();
}
```

再来看看guava提供的Cache接口，相对来说也是比较简洁的：

```java
public interface Cache<K, V> {
  V getIfPresent(@CompatibleWith("K") Object key);
  V get(K key, Callable<? extends V> loader) throws ExecutionException;
  ImmutableMap<K, V> getAllPresent(Iterable<?> keys);
  void put(K key, V value);
  void putAll(Map<? extends K, ? extends V> m);
  void invalidate(@CompatibleWith("K") Object key);
  void invalidateAll(Iterable<?> keys);
  void invalidateAll();
  long size();
  CacheStats stats();
  ConcurrentMap<K, V> asMap();
  void cleanUp();
}
```

#### 7、是否持久化

持久化的好处是重启之后可以再次加载文件中的数据，这样就起到类似热加载的功效；比如ehcache提供了是否持久化磁盘缓存的功能，将缓存数据存放在一个.data文件中；

```
diskPersistent="false" //是否持久化磁盘缓存
```

redis更是将持久化功能发挥到极致，慢慢的有点像数据库了；提供了AOF和RDB两种持久化方式；当然很多情况下可以配合使用两种方式；

#### 8、阻塞机制

除了在Mybatis中看到了BlockingCache来实现此功能，之前在看**<<java并发编程实战>>**的时候其中有实现一个很完美的缓存，大致代码如下：

```java
public class Memoizerl<A, V> implements Computable<A, V> {
    private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;

    public Memoizerl(Computable<A, V> c) {
        this.c = c;
    }

    @Override
    public V compute(A arg) throws InterruptedException, ExecutionException {
        while (true) {
            Future<V> f = cache.get(arg);
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    @Override
                    public V call() throws Exception {
                        return c.compute(arg);
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                }
                try {
                    return f.get();
                } catch (CancellationException e) {
                    cache.remove(arg, f);
                }
            }
        }
    }
}
```

compute是一个计算很费时的方法，所以这里把计算的结果缓存起来，但是有个问题就是如果两个线程同时进入此方法中怎么保证只计算一次，这里最核心的地方在于使用了ConcurrentHashMap的putIfAbsent方法，同时只会写入一个FutureTask；

# 六、领域驱动模型（DDD）

- [洞见：DDD领域驱动](https://insights.thoughtworks.cn/tag/domain-driven-design/)
- [淘技术：DDD领域驱动](https://mp.weixin.qq.com/s/1rdnkROdcNw5ro4ct99SqQ)



# 七、软件开发周期

```
瀑布模型：

　　计划 → 需求分析 →  设计 →  编码 →  测试 →  运行维护

       特点：①软件开发的各项活动严格按照线性方式进行。

　　　       ②当前活动接受上一项活动的工作结果。

　　           ③当前活动的工作结果需要进行验证。

       缺点：①由于开发模型是线性的，增加了开发的风险。

　　           ②早期的错误可能要等到开发后期的阶段才能发现。

原型模型：

　　客户与开发公司紧密联系，开发周期长。开发会受到需求变更的影响。

       特征：①实现客户与系统的交互。

                  ② 进一步细化待开发软件需求。

　　　　　③开发人员可以确定客户的真正需求是什么。

螺旋模型：

　　制定计划 →   风险分析 →   实施工程（需求确认、软件需求、软件产品设计、设计确认与认证、详细设计、开发、测试） →   客户评估

　　特点：①螺旋模型是将瀑布模型与快速原型模型结合起来。

　　  　　   ②强调了其他模型所忽视的风险分析。

　　   　　  ③每一次螺旋包括4个步骤：制定计划、风险分析、实施工程、客户评估。

　　  缺点：①强调风险分析，但要求许多客户接受并相信这种分析，是不容易的。

敏捷开发模型：

　　特点：①短周期开发。

　　　　   ②增量开发。

　　　　   ③ 由程序员和测试人员编写的自动化测试来监控开发进度。

　　　　   ④通过口头沟通、测试和源代码来交流系统的结构和意图。

　　　　   ⑤编写代码之前先写测试代码。也叫做测试先行。

     缺点： ①团队的组建较难，人员素质要求较高。

　　　      ②对测试员要求完全掌握各种脚本语言编程，会单元测试。
```

# 参考资料

- [系统设计](https://github.com/ksfzhaohui/blog/tree/master/java8)
- [领域驱动模型在互联网业务中运用](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)