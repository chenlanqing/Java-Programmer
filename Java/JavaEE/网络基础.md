<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一.OSI 七层模型](#%E4%B8%80osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B)
  - [1.OSI(Open System Interconnection):](#1osiopen-system-interconnection)
    - [1.1.物理层](#11%E7%89%A9%E7%90%86%E5%B1%82)
    - [1.2.数据链路层](#12%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82)
    - [1.3.网络层](#13%E7%BD%91%E7%BB%9C%E5%B1%82)
    - [1.4.传输层](#14%E4%BC%A0%E8%BE%93%E5%B1%82)
    - [1.5.会话层](#15%E4%BC%9A%E8%AF%9D%E5%B1%82)
    - [1.6.表示层:数据将按照网络能理解的方案进行格式化](#16%E8%A1%A8%E7%A4%BA%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B0%86%E6%8C%89%E7%85%A7%E7%BD%91%E7%BB%9C%E8%83%BD%E7%90%86%E8%A7%A3%E7%9A%84%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96)
    - [1.7.应用层:是最靠近用户的OSI层](#17%E5%BA%94%E7%94%A8%E5%B1%82%E6%98%AF%E6%9C%80%E9%9D%A0%E8%BF%91%E7%94%A8%E6%88%B7%E7%9A%84osi%E5%B1%82)
  - [2.TCP/IP 协议:](#2tcpip-%E5%8D%8F%E8%AE%AE)
- [二.传输层控制协议](#%E4%BA%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
  - [1.TCP:传输控制协议](#1tcp%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
    - [1.1.TCP主要特性](#11tcp%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7)
  - [2.TCP数据段格式](#2tcp%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F)
  - [3.TCP套接字](#3tcp%E5%A5%97%E6%8E%A5%E5%AD%97)
    - [3.1.套接字概述](#31%E5%A5%97%E6%8E%A5%E5%AD%97%E6%A6%82%E8%BF%B0)
    - [3.2.Socket原语](#32socket%E5%8E%9F%E8%AF%AD)
  - [4.TCP端口](#4tcp%E7%AB%AF%E5%8F%A3)
  - [5.TCP状态转移](#5tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB)
    - [5.1.TCP的连接状态](#51tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81)
    - [5.2.TCP状态转换](#52tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2)
  - [6.TCP 建立连接](#6tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5)
  - [7.TCP连接释放](#7tcp%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE)
  - [8.TCP传输建立与释放相关问题](#8tcp%E4%BC%A0%E8%BE%93%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98)
    - [8.1为什么要三次握手:](#81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    - [8.2.为什么要四次挥手:](#82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
    - [8.3.为什么建立连接协议是三次握手,而关闭连接却是四次挥手呢?](#83%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2)
    - [8.4.为什么不能用两次握手进行连接?](#84%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5)
  - [9.TCP的可靠性传输](#9tcp%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93)
    - [9.1.TCP字节编号机制](#91tcp%E5%AD%97%E8%8A%82%E7%BC%96%E5%8F%B7%E6%9C%BA%E5%88%B6)
    - [9.2.TCP的数据段确认机制](#92tcp%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6)
    - [9.3.TCP超时重传机制](#93tcp%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)
    - [9.4.TCP的选择性确认机制](#94tcp%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6)
  - [10.TCP流量控制](#10tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)
  - [11.TCP拥塞控制](#11tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  - [12.UDP-用户数据报文协议](#12udp-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE)
    - [12.1.基本特性](#121%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7)
    - [12.2.UDP的数据报头部格式](#122udp%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F)
  - [13.说说 HTTP,UDP,TCP 之间关系和区别.](#13%E8%AF%B4%E8%AF%B4-httpudptcp-%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB)
- [三.IP-网络层](#%E4%B8%89ip-%E7%BD%91%E7%BB%9C%E5%B1%82)
- [四.HTTP协议-应用层](#%E5%9B%9Bhttp%E5%8D%8F%E8%AE%AE-%E5%BA%94%E7%94%A8%E5%B1%82)
  - [1.HTTP协议](#1http%E5%8D%8F%E8%AE%AE)
  - [2.HTTP协议工作原理](#2http%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [3.HTTP报文](#3http%E6%8A%A5%E6%96%87)
  - [4.HTTP状态码](#4http%E7%8A%B6%E6%80%81%E7%A0%81)
  - [5.HTTP请求方式](#5http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F)
  - [6.浏览器缓存机制](#6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)
    - [6.1.浏览器缓存控制机制有两种](#61%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%B8%A4%E7%A7%8D)
    - [6.2.几个重要概念:](#62%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5)
    - [6.3.几种状态码的区别:](#63%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [6.4.用户行为与缓存:](#64%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E4%B8%8E%E7%BC%93%E5%AD%98)
  - [7.HTTPS](#7https)
- [五.DNS协议-应用层](#%E4%BA%94dns%E5%8D%8F%E8%AE%AE-%E5%BA%94%E7%94%A8%E5%B1%82)
  - [1.DNS 协议:](#1dns-%E5%8D%8F%E8%AE%AE)
  - [2.DNS 解析过程:](#2dns-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B)
  - [3.清除缓存的域名:](#3%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%9F%E5%90%8D)
  - [4.域名解析方式:](#4%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F)
- [六.其他网络相关知识点](#%E5%85%AD%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9)
  - [1.跨域问题](#1%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98)
    - [1.1.什么是跨域](#11%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F)
    - [1.2.广义的跨域](#12%E5%B9%BF%E4%B9%89%E7%9A%84%E8%B7%A8%E5%9F%9F)
    - [1.3.什么是同源策略:(SOP-Same Origin Policy)](#13%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5sop-same-origin-policy)
    - [1.4.常见跨域场景:](#14%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E5%9C%BA%E6%99%AF)
    - [1.5.常见跨域解决方案:](#15%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
  - [2.](#2)
- [参考资料](#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->



# 一.OSI 七层模型
## 1.OSI(Open System Interconnection):
    称为开放式系统互联参考模型,针对广域网通信进行设计的,将整个网络通信
    份名为7个层次:物理层、数据链路层、网络层、传输层、会话层、表示层、应用层.
    (1).OSI 低四层(从物理层到传输层)定义了如何进行端到端的数据传输,也就是定义了如何通过网卡、物理电缆、
        交换机和路由器进行数据传输.
    (2).而高三层(从会话层到应用层)定义了终端系统的应用程序和用户如何彼此通信,即定义了如何重建从发送方
        到目的方的应用程序数据流
### 1.1.物理层
    是所有计算机网络体系结构的最底层,为所有网络/数据通信提供物理的通信线路.
    是用来构建计算机网络通信和数据传输的通道的.
    中继器,集线器、网线、HUB
### 1.2.数据链路层
    控制网络层与物理层之间的通信,提供点对点的数据传输通道,通过MAC地址寻址把数据传到
    目的节点.为了保证传输,从网络层接收到的数据被分割成特定的可被物理层传输的帧.
    (1).数据链路层在不可靠的物理介质上提供可靠的传输.
        该层的作用包括:物理地址寻址、数据的成帧、流量控制、数据的检错、重发等
    (2).据链路层协议的代表包括:SDLC、HDLC、PPP、STP、帧中继等;
    (3).数据链路可以分为逻辑链路和物理链路.
        网卡,网桥,交换机
### 1.3.网络层
    (1).其主要功能是将网络地址翻译成对应的物理地址,并决定如何将数据从发送方路由到接收方
    (2).在网络中,"路由"是基于编址方案、使用模式以及可达性来指引数据的发送.
    (3).网络层是可选的,它只用于当两个计算机系统处于不同的由路由器分割开的网段这种情况,或者当通信应用
        要求某种网络层或传输层提供的服务、特性或者能力时
### 1.4.传输层
    (1).以端到端方式建立数据传输连接和通信,屏蔽途径网络中所有低层服务上的差异
    (2).以数据段为基本格式提供流量控制,拥塞控制和差错控制
    (3).传输层的协议:TCP,UDP
    (4).作用:传输层为它上面的应用层提供通信服务;
    (5).在OSI七层参考模型中,传输层是面向通信的最高层,也是用户功能的最底层;
    (6).传输层两大重要的功能:复用 和 分用
        * 复用:在发送端,多个应用进程共用一个传输层;
        * 分用:在接收端,传输层会根据端口号将数据分派给不同的应用进程.
    (7).和网络层的区别
        * 网络层为不同主机提供通信服务,而传输层为不同主机的不同应用提供通信服务;
        * 网络层只对报文头部进行差错检测,而传输层对整个报文进行差错检测
### 1.5.会话层
    (1).维护通信双方应用进程会话;管理双方数据交换进程
    (2).建立通信链接,保持会话过程通信链接的畅通,同步两个节点之间的对话,决定通信是否被中断以及通信
        中断时决定从何处重新发送
        SESSION认证、断点续传
### 1.6.表示层:数据将按照网络能理解的方案进行格式化
    (1).数据格式转换,数据加密与解密,数据压缩与解压缩
### 1.7.应用层:是最靠近用户的OSI层
    (1).负责接受用户的各种网络应用进程的调用;
    (2).协议:FTP,SMTP,HTTP

![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/计算机网络体系结构分层.png)

## 2.TCP/IP 协议:
    TCP/IP 协议体系结构,是专门针对使用TCP/IP 协议簇的广域网计算机网络而开发的.其只划分了四层:
    应用层、传输层、网际互连层、网络访问层
    1.2.1.应用层:
        将OSI参考模型中的会话层和表示层的功能合并到应用层实现
    1.2.2.传输层:
        传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话
    1.2.3.网际互连层:
        (1).网络互连层是整个 TCP/IP 协议栈的核心.它的功能是把分组发往目标网络或主机
        (2).定义了分组格式和协议,即IP协议(Internet Protocol)
    1.2.4.网络访问层
# 二.传输层控制协议
## 1.TCP:传输控制协议
### 1.1.TCP主要特性
    TCP是TCP/IP体系结构中最主要的传输层协议.
    (1).面向连接的传输协议:应用程序在使用TCP之前,必须先建立TCP传输连接,
        在数据传输完毕之后,必须释放已建立的TCP传输连接;
    (2).仅支持单播传输
        每条TCP传输连接只有两个端点,只能进行点对点的数据传输,不支持多播和广播的传输方式.
        * 注意:这里的TCP传输连接的"端点"不是主机或者主机的IP等,而是套接字(Socket).
          套接字是IP地址和端口号的组合;
    (3).提供可靠的交付服务:通过TCP连接传送的数据可以无差错、不丢失、不重复,且按时序到达对端
    (4).传输单位为数据段
        由于数据段大小受应用层传输的报文大小和所途径网络的MTU值大小决定.每次发送的TCP数据段大小不固定.
        最小的数据段可能仅有21字节
    (5).仅一种TPDU格式;
    (6).支持全双工传输:
        TCP允许通信双方的应用程序在任何时候都能发送数据,因为TCP连接的两端都设有发送和缓存,
        用来临时存放双向通信的数据.
    (7).TCP连接是基于字节流的,而非报文流;
    (8).每次发送的TCP数据端大小和数据段都是可变的
## 2.TCP数据段格式
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/TCP数据段格式.jpg)

    (1).源端口和目的端口
        源端口和目的端口分别代表的呼叫方和被叫方的TCP端口号,各占16位.
        一个端口与其主机的IP地址可以完整的标识一个端点.
    (2).序号(Sequence Number)
        序号指TCP数据段中的"数据"部分(不包含"数据段头"部分)的第一个字节的编号,栈32位.
        整个要传输的字节流的起始序号必须在连接建立时设置.
    (3).确认序号(Acknowlegment Number)
        确认号指期望接收到对方下一个数据段中"数据"部分的第一个字节序号,占32位.
        注意,"确认号"不是代表已经正确接收到最后一个字节的序号.
        "序号"和"确认号"两个字段共同用于TCP服务中的差错控制,确保TCP数据传输的可靠性
    (4).数据偏移
        数据偏移指数据段中的"数据"部分起始处距离TCP数据段起始处的字节偏移量,占4位.
        这里的数据偏移也是在确定TCP数据段头部分的长度.
        数据偏移量是以32位(4字节)为单位来计算的.而不是以单个字节来计算的.
        4个比特位可以表示的最大数为15,所以数据偏移量最大位60字节,也是TCP数据段头部分最大长度.
    (5).保留(Reserved)
        为将来应用而保留的6个比特位,目前应全设置位0
    (6).URG
        Urgent Pointer(紧急指针)控制位,指出当前数据段中是否有紧急数据,占1位,置1时表示有紧急数据.
        紧急数据会优先安排传送,而不会按照原来的排队顺序进行发送.
        仅当本字段设置为1时,后面的紧急指针字段才有意义;
    (7).ACK
        Acknowlegment(确认)控制位,指示TCP数据段中的"确认号"字段是否有效,占1位.
        仅当ACK位置1时才表示"确认号"字段有效,否则表示"确认号"字段无效.
    (8).PSH
        Push(推)控制位,指示是否需要立即把收到的该数据段提交给应用进程,占1位.
        当PSH位置1时要求接收端尽快把该数据提交给应用进程,而置时没有这个要求,可以先缓存起来.
    (9).RST
        Reset(重置控制位),用于重置、释放一个已经混乱的传输连接,然后重新的传输连接,占1位.
        当RST位置1时,释放当前传输连接,然后可以重新建立新的传输连接.
    (10).SYN
        Synchronization(同步)控制位,用来在传输连接建立时同步传输连接序号,占1位.
        当SYN位置1时,表示这一个连接请求或连接确认报文.
        当SYN=1,而ACK=0 时,表示这是一个连接请求数据段.如果对方统一建立连接,则对方
        会返回一个SYN=1、ACK=1的确认.
    (11).FIN
        Final(最后)控制位,用于释放一个传输连接,占1位.
        当FIN位置1时,表示数据已经传输完成,发送端没有数据要传输了,要求释放当前连接,
        但是接收端仍然可以继续接收还没有接收完的数据.在正常传输时,该位置1.
    (12).窗口大小
        指示发送此TCP数据段的主机上用来存储传入数据段的窗口大小,也即发送者当前还可以接收
        的最大字节数,占16位
    (13).检验和(Checksum)
        检验和是指对"数据段头"、"数据"和"伪头部"这三部分进行校验,主干16位."伪头部"包括源
        主机和目的主机的32位IP地址、TCP协议号(6),以及TCP数据段长度.
    (14).紧急指针(Urgent Pointer)
        仅当前面的URG控制位置1时才有意义,它指出本数据段中位紧急数据的字节数,占16位.
        "紧急指针"字段指明了紧急数据的末尾在数据段中的位置.
        注意,即使当前窗口大小位0,也是可以发送紧急数据的,因为紧急数据无须缓存.
    (15).可选项(Option)
        "可选项"字段时可选的,且长度可变,最长可达40字节.当没有使用该字段时,TCP头部的长度
        时20字节.
    (16).数据(Data)
        这是由应用层的应用进程提交的数据,作为TCP数据段的"数据"部分.
## 3.TCP套接字
### 3.1.套接字概述
    在TCP/IP网络中,区分不同应用程序进程间的网络通信和连接时主要有三个参数:
    * 通信的目的IP地址
    * 使用的传输层协议(TCP或UDP)
    * 使用的端口号
    通过这三个参数结合起来与一个Socket进行绑定,应用层就可以与传输层一起通过套接字接口来区分来自不同应用
    程序进程或网络连接通信,实现数据传输的并发服务.
### 3.2.Socket原语
    (1).基本概述
        在TCP Socket中,包含如下表了一组(共8个)TCP数据传输服务原语,表中前4个原语由服务器按照顺序执行.
        其中,SOCKET原语用来创建一个新的端点,并且在传输实体中为它们分配相应的空间.SOCKET原语调用成功后,
        返回一个普通的文件描述符,以便后续在其他的原语调用中使用.
        但由于新创建的套接字并没有网络地址,需要通过BIND原语为它进行分配,所以BIND原语的用途是为新建的
        套接字绑定一个本地网络地址.
        客户端调用的原语包括:SOCKET,CONNECT,SEND,RECV.
    (2).TCP Socket原语
|原语名称|含义|
|-------|----|
|SCOKET|创建一个新的通信端点|
|BIND|将一个本地地址关联到一个套接字上|
|LISTEN|通告愿意接受连接,并给出队列大小|
|ACCEPT|阻塞调用方,直到有人企图进行连接|
|CONNECT|主动尝试建立一个连接|
|SEND|在指定的连接上发送数据|
|RECV|从指定的连接上接收数据|
|CLOSE|释放指定的连接|
    (3).TCP Socket原语调用基本流程

![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/TCP-Scoket原语调用基本流程.png)

## 4.TCP端口
    每个端口都拥有一个称为"端口号"整数描述符,用来标识不同的端口或进程.
    在TCP的数据段格式中,分别定义了一个16比特长度的"源端口"和"目的端口"两个字段,也就是
    说可以定义2^16个端口,其端口号位0~2^16-1(65535).
    由于TCP/IP传输层中的TCP和UDP时两个完全独立的软件模块,因此各自的端口号也相互独立,即
    各自独立拥有65535个端口.
    端口可以分为三类:
    (1).保留端口
        通常将0~1023号TCP端口保留,因此,这类端口也称为"常规端口".这些端口都已
        固定的分配给了已知的网络应用协议
|端口号|对应的协议|用途说明|
|-----|----------|--------|
|20|FTP|FTP数据传输|
|21|FTP|FTP控制消息|
|22|SSH|安全登录|
|23|TELNET|远程登录|
|25|SMTP|邮件发送|
|42|WINS|Internet名称解析服务|
|53|DNS|域名解析服务|
|69|TFTP|小型文件传输协议|
|79|Finger|查询有关用户的信息|
|80|HTTP|万维网服务|
|110|POP3|邮件接收服务|
|115|SFTP|简单文件传输协议|
    (2).动态分配端口
        动态分配的端口一般大于1024,可以动态分配给任意网络服务应用程序使用.
    (3).注册端口
        注册端口比较特殊,它也是固定位某个应用程序服务的端口,但是它所代表的不是已经
        形成的应用层协议,而是某个软件厂商开发的应用程序.如mysql的3360,
        redis的6379等

## 5.TCP状态转移
### 5.1.TCP的连接状态
状态 | 描述
-----|-----
CLOSED|呈阻塞,关闭状态,表示主机当前没有获得的传输连接或正在进行传输连接
LISTEN|呈监听状态,表示服务器正在等待新的传输连接进入
SYN RCVD|表示主机已接收到一个传输连接请求,但尚未确认
SYN SENT|表示主机已经一个传输连接请求,等待对方确认
ESTABLISHED|传输连接建立,通信双方进入正常数据传输状态
FIN WAIT 1|(主动关闭)主机已经发送关闭连接请求,等待对方确认
FIN WAIT 2|(主动关闭)主机已接收到对方关闭传输连接确认,等待对方发送关闭传输连接请求
TIMED WAIT|完成双向传输连接关闭,等待所有分组消息
CLOSIND| 双方同时尝试关闭传输连接,等待对方确认
CLOSE WAIT|(被动关闭)收到对方发来的关闭传输连接请求,并已确认
LASC ACK|(被动关闭)等待最后一个关闭传输连接确认,并等待所有分组消失

### 5.2.TCP状态转换
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/TCP状态转换图.jpg)
 
    每个连接均开始于CLOSED状态.当一方执行了被动的连接原语(LISTEN)或主动的连接原语(CONNECT)时,它便会离开CLOSED状态.
    如果此时执行了相对应的连接原语,连接便建立了,并且状态变为 ESTABLISHED.任何一方均可以首先请求释放连接,当连接被释放后,
    状态又回到了CLOSED

## 6.TCP 建立连接
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/TCP-三次握手.jpg)

    在TCP/IP 协议中,TCP 协议提供可靠的连接服务,连接是通过三次握手进行初始化的.
    三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息
    (1).第一次握手:建立连接
        客户端发送连接请求报文段,将SYN位置为1,初始序号为 i; 然后,客户端进入SYN_SENT状态,等待服务器的确认;
    (2).第二次握手:服务器收到 SYN 报文段
        服务器收到客户端的 SYN 报文段,返回一个SYN字段置1、ACK字段置1(表示此为确认数据)、ack(确认号)=i+1、
        初始化序号为 j 的应答数据段此时服务器进入 SYN_RECV 状态;
        注意:这里确认好是i+1,而不是i
    (3).第三次握手:客户端收到服务器的 SYN+ACK 报文段
        向服务器发送一个ACK=1(表示此为确认数据段)、序号为i+1、ack=j+1的确认数据段,同时进入ESTABLISHED状态,
        服务器在收到客户端的ACK数据段后,进入ESTABLISHED状态,完成双休连接建立
## 7.TCP连接释放
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/TCP-四次挥手.png)

    四次挥手:断开TCP连接
    (1).第一次挥手:
        主机1(可以使客户端，也可以是服务器端),设置 Sequence Number 和 Acknowledgment Number,
        向主机2发送一个 FIN 报文段;此时,主机1进入 FIN_WAIT_1 状态;这表示主机1没有数据要发送给主机2了;
    (2).第二次挥手:
        主机2收到了主机1发送的 FIN 报文段,向主机1回一个 ACK 报文段,Acknowledgment Number 为
        Sequence Number 加1;
        主机1进入 FIN_WAIT_2 状态;主机2告诉主机1,我"同意"你的关闭请求;
    (3).第三次挥手:
        主机2向主机1发送 FIN 报文段,请求关闭连接,同时主机2进入 LAST_ACK 状态;
    (4).第四次挥手:
        主机1收到主机2发送的 FIN 报文段,向主机2发送 ACK 报文段,然后主机1进入 TIME_WAIT 状态;
        主机2收到主机1的ACK报文段以后,就关闭连接;
        此时,主机1等待2MSL后依然没有收到回复,则证明Server端已正常关闭,那好,主机1也可以关闭连接了
## 8.TCP传输建立与释放相关问题
### 8.1为什么要三次握手:
    (1).为了防止已失效的连接请求报文段突然又传送到了服务端,因而产生错误.防止了服务器端的一直等待而浪费资源
        如:client发出的第一个连接请求报文段并没有丢失,而是在某个网络结点长时间的滞留了,
        以致延误到连接释放以后的某个时间才到达server
    (2).从另一个角度来看问题:
        问题的本质是,信道不可靠,但是通信双发需要就某个问题达成一致.而要解决这个问题, 无论你在消息中
        包含什么信息, 三次通信是理论上的最小值.所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠
        信道上可靠地传输信息"这一需求所导致的
### 8.2.为什么要四次挥手:
    TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议.TCP 是全双工模式,这就意味着,当主机1发出FIN报文段时,
    只是表示主机1没有数据要发送了,当主机1告诉主机2时,它的数据已经发送完成;但是此时主机1还是可以接收来自主机2的数据,
    当主机2返回ACK报文段时,表示它已经直到主机1没有数据要发送了,但是主机2还是可以发送数据到主机1的,当主机2也发送了FIN
    报文段时,此时表示主机2也没有数据要发送了,主机1也知道主机2没有数据发送了,之后彼此中断此次TCP连接.
    四次挥手过程中状态变化.
    (1).FIN_WAIT_1:(主动方)
        其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文.
        而这两种状态的区别是:
        * FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时,它想主动关闭连接,向对方发送了FIN报文,
          此时该SOCKET即进入到FIN_WAIT_1状态
        * 而当对方回应ACK报文后,则进入到FIN_WAIT_2状态,当然在实际的正常情况下,无论对方何种情况下,
          都应该马上回应ACK报文,所以FIN_WAIT_1状态一般是比较难见到的,而FIN_WAIT_2状态还有时常常可以用netstat看到
    (2).FIN_WAIT_2:(主动方)
        FIN_WAIT_2状态下的SOCKET,表示半连接,也即有一方要求close连接,但另外还告诉对方,
        暂时还有点数据需要传送给你(ACK信息),稍后再关闭连接
    (3).CLOSE_WAIT:表示在等待关闭(被动方)
        当对方close一个SOCKET后发送FIN报文给自己,你系统毫无疑问地会回应一个ACK报文给对方,此时则进入到CLOSE_WAIT状态.
        接下来需要考虑的是当前是否有数据需要发送给对方,如果没有的话,自己这边也可以close该Socket,发送FIN报文段给对方,
        即关闭连接.所以在CLOSE_WAIT状态下,需要完成的事情是等该关闭连接.
    (4).LAST_ACK:(被动方)
        是被动一方在发生FIN报文后,最后等待对方的ACK报文.当收到ACK报文后,也可以进入到CLOSED可用状态. 
    (5).TIME_WAIT:(主动方)
         表示收到了对方的FIN报文,并发送出了ACK报文,就等2MSL后即可回到CLOSED可用状态了.
         如果FIN_WAIT1状态下,收到了对方同时带FIN标志和ACK标志的报文时,可以直接进入到TIME_WAIT状态,而无须经过FIN_WAIT_2状态.
    (6).CLOSED:表示连接中断

### 8.3.为什么建立连接协议是三次握手,而关闭连接却是四次挥手呢?
    (1).这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的连接请求后,
        它可以把ACK和SYN(ACK起应答作用,而SYN起同步作用)放在一个报文里来发送.
    (2).但关闭连接时,当收到对方的 FIN 报文通知时,它仅仅表示对方没有数据发送给你了;
        但未必你所有的数据都全部发送给对方了,所以你可能未必会马上会关闭SOCKET,也即你
        可能还需要发送一些数据给对方之后,再发送FIN报文给对方来表示你同意现在可以关闭连接了,
        所以它这里的ACK报文和FIN报文多数情况下都是分开发送的
### 8.4.为什么不能用两次握手进行连接?
    (1).3次握手完成两个重要的功能:既要双方做好发送数据的准备工作(双方都知道彼此已准备好),
        也要允许双方就初始序列号进行协商,这个序列号在握手过程中被发送和确认.
    (2).把三次握手改成仅需要两次握手,死锁是可能发生的

## 9.TCP的可靠性传输
    在TCP可靠传输主要采用下列四种机制
    (1)."字节编号机制":TCP数据段以字节为单位对数据段中的"数据"部分进行一一编号,确保每个字节的数据都可以有序的传送和接收
    (2)."数据段确认机制":TCP要求每接收一个数据段都必须由接收端向发送端返回一个确认数据段.
        其中"确认号"表明了接收端已正确接收的数据段序号.
    (3)."超时重传机制":TCP中有一个重传定时器(RTT),在发送一个数据段的同时也启动了该定时器.如果在定时器过期时间该
        数据段还没有被对方确认的话,则定时器停止,然后重传对应序号的数据段.
    (4)."选择性确认(SACK)机制":在SACK支持下,仅可以重传缺少部分的数据,而不会重传哪些已经正确接收的数据
### 9.1.TCP字节编号机制
    因为是按字节进行编号的,所以接收端根据所接收到的数据段中的序号可以知道前面是否还有数据没有接收到,
    数据可以按顺序向应用进程提交,在对经过了数据段的数据进行重组时也可以根据这个序号进行正确的重组.
### 9.2.TCP的数据段确认机制
#### 9.2.1.几个重要概念
    (1).数据段
        指TCP对从应用层接收的数据进行分割所得到的数据块,通常包含千个以上字节,而且必须是整数倍字节数.
        正因如此,TCP发送的是字节流,而不是通常所说的报文流,因为在TCP数据段中没有报文边界
    (2).序号
        TCP发送的数据段中"数据"部分,每个字节都有一个序号,每个数据段中的"序号"字段是以该数据段中第一个字节的序号进行填充.
    (3).窗口大小
        窗口的大小时本端要告诉对端当前可以接收的数据量,也暗示着对端可以一次性发送的数据大小,以字节位单位.
        窗口大小字段是随着接收端"接收窗口大小"变化而变化的,不是固定的
        无论发送端还是接收端,都分别有"发送窗口"和"接收窗户"这两个窗口.
    (4).确认号
        指发送包含这个"确认号"的数据段的一端期望接收另一端的下一个数据段的起始序号.
        同时也暗示了在此序号之前的所有字节数据均已正确接收;
    (5).ACK
        是一个表明"确认号"字段是否有效的标志位.只有ACK=1时数据段中的"确认号"才有意义
#### 9.2.2.TCP确认机制特性
    (1).TCP可一次连续发送多个数据段
    (2).仅对连续接收的数据段进行确认
    (3).不连续序号的数据将先缓存
### 9.3.TCP超时重传机制
    原理是在发送某一个数据段以后就开启一个超时重传计时器.如果在这个定时器时间内没有收到来自对方的某个
    数据段的确认,发送端启动重传机制,重新发送对应的的数据段.
    (1).SRTT的计算
    (2).RTO的计算
### 9.4.TCP的选择性确认机制
    在上面超时重传机制中,如果在重传定时器超时后仍没有收到一个数据段的确认,则可能会重传对应序号后面的所有数据段.
    为了避免这种线程的出现,出现了一种称为"选择性确认(SACK)"的机制,就是在TCP数据段格式的头部"可选项"字段中添加
    一个代表支持SACK的选项.但这个选项在不同的数据段中有不同的字段名称和不同的含义.

## 10.TCP流量控制

## 11.TCP拥塞控制

## 12.UDP-用户数据报文协议
    是一种无连接传输协议,不能保证数据传输成功.
### 12.1.基本特性
    (1).无连接性
        UDP可以提供五连接的数据报服务,这决定了在使用UDP进行数据传输前时不需要建立
        专门的传输连接的,也无须释放连接.
    (2).不可靠性
        因为UDP传输数据时时不需要建立专门的传输连接的,所以它的传世时不可靠的.
        UDP适合用于一些短消息类的数据传输,如DHCP,DNS的一些消息就是采用UDP传输的.
    (3).以报文为边界
        UDP直接对应用层提交的报文进行封装、传输,但不拆分也不合并,保留原来报文的边界.
        因此UDP时报文流,而TCP时字节流.
    (4).无流量控制和拥塞控制功能.
    (5).支持各种交互通信的方式
        TCP不支持组播和广播的通信方式,只支持一对一的单播方式,但UDP支持各种通信方式.
        计算机网络中很多使用UDP的应用服务:DNS,SNMP,DHCP,RIP等
### 12.2.UDP的数据报头部格式
    (1).源端口
    (2).目的端口
    (3).长度
    (4).校验和
    
## 13.说说 HTTP,UDP,TCP 之间关系和区别.
    (1).HTTP 是应用层协议,UDP 和 TCP 是传输层协议;
    (2).HTTP 利用 TCP 在两台电脑(通常是Web服务器和客户端)之间传输信息的协议
    (3).TCP 协议是有连接的,有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接,
        会话结束之后也要结束连接;而UDP是无连接的
    (4).TCP 协议保证数据按序发送,按序到达,提供超时重传来保证可靠性;
        UDP 不保证按序到达,甚至不保证到达,只是努力交付,即便是按序发送的序列,也不保证按序送到.
    (5).TCP 协议所需资源多,TCP 首部需20个字节(不算可选项);UDP 首部字段只需8个字节。
    (6).TCP 有流量控制和拥塞控制;UDP 没有，网络拥堵不会影响发送端的发送速率
    (7).TCP 是一对一的连接;而UDP则可以支持一对一、多对多、一对多的通信。
    (8).TCP 面向的是字节流的服务;UDP 面向的是报文的服务

# 三.IP-网络层

# 四.HTTP协议-应用层
## 1.HTTP协议

## 2.HTTP协议工作原理

## 3.HTTP报文

## 4.HTTP状态码
    (1).常见的状态码:
		200-->服务器成功返回, 404-->请求的网页不存在, 503-->服务不可用
	(2).HTTP: Status 1xx  (临时响应)
		->表示临时响应并需要请求者继续执行操作的状态代码.
		100-->请求者应当继续提出请求.服务器返回此代码表示已收到请求的第一部分.正在等待其余部分
		101-->请求者已要求服务器切换协议,服务器已确认并准备切换
	(3).HTTP Status 2xx  (成功)->表示成功处理了请求的状态代码;
		HTTP Status 200 (成功) -> 服务器已成功处理了请求. 通常这表示服务器提供了请求的网页.
		HTTP Status 201 (已创建)-> 请求成功并且服务器创建了新的资源
		HTTP Status 202 (已接受)-> 服务器已接受请求,但尚未处理.
		HTTP Status 203 (非授权信息)-> 服务器已成功处理了请求,但返回的信息可能来自另一来源.
		HTTP Status 204 (无内容)-> 服务器成功处理了请求,但没有返回任何内容.
		HTTP Status 205 (重置内容)-> 服务器成功处理了请求,但没有返回任何内容.
		HTTP Status 206 (部分内容)-> 服务器成功处理了部分 GET 请求
	(4).HTTP Status 3xx (重定向)->表示要完成请求,需要进一步操作.通常,这些状态代码用来重定向
	(5).HTTP Status 4xx (请求错误)-->这些状态代码表示请求可能出错,妨碍了服务器的处理
		HTTP Status 400 (错误请求) -->服务器不理解请求的语法.
		HTTP Status 401 (未授权) -->请求要求身份验证. 对于需要登录的网页,服务器可能返回此响应.
		HTTP Status 403 (禁止)	--> 服务器拒绝请求.
		HTTP Status 404 (未找到) -->服务器找不到请求的网页.
		HTTP Status 405 (方法禁用) -->禁用请求中指定的方法.
		HTTP Status 406 (不接受) -->无法使用请求的内容特性响应请求的网页.
		HTTP Status 407 (需要代理授权) -->此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理.
		HTTP Status 408 (请求超时)-->服务器等候请求时发生超时.
		HTTP Status 409 (冲突)-->服务器在完成请求时发生冲突. 服务器必须在响应中包含有关冲突的信息.
		HTTP Status 410 (已删除)--> 如果请求的资源已永久删除，服务器就会返回此响应.
		HTTP Status 411 (需要有效长度) -->服务器不接受不含有效内容长度标头字段的请求.
		HTTP Status 412 (未满足前提条件) -->服务器未满足请求者在请求中设置的其中一个前提条件.
		HTTP Status 413 (请求实体过大) -->服务器无法处理请求，因为请求实体过大，超出服务器的处理能力.
		HTTP Status 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理.
		HTTP Status 415 (不支持的媒体类型)-->请求的格式不受请求页面的支持.
		HTTP Status 416 (请求范围不符合要求) -->如果页面无法提供请求的范围，则服务器会返回此状态代码.
		HTTP Status 417 (未满足期望值)-->服务器未满足”期望”请求标头字段的要求
	(6).HTTP Status 5xx (服务器错误)-->这些状态代码表示服务器在尝试处理请求时发生内部错误.这些错误可能是服务器本身的错误,而不是请求出错.
		HTTP Status 500 (服务器内部错误) -->服务器遇到错误,无法完成请求.
		HTTP Status 501 (尚未实施) -->服务器不具备完成请求的功能. 例如,服务器无法识别请求方法时可能会返回此代码.
		HTTP Status 502 (错误网关) -->服务器作为网关或代理,从上游服务器收到无效响应.
		HTTP Status 503 (服务不可用)--> 服务器目前无法使用(由于超载或停机维护). 通常,这只是暂时状态.
		HTTP Status 504 (网关超时)	-->服务器作为网关或代理,但是没有及时从上游服务器收到请求.
		HTTP Status 505 (HTTP 版本不受支持)	--> 服务器不支持请求中所用的 HTTP 协议版本.
## 5.HTTP请求方式

## 6.浏览器缓存机制
### 6.1.浏览器缓存控制机制有两种
    HTML Meta标签 和 HTTP头信息
    (1).HTML Meta 标签控制缓存:
        浏览器缓存机制,其实主要就是HTTP协议定义的缓存机制,如:Expires, Cache-control等
        但是也有非HTTP协议定义的缓存机制,如使用HTML Meta 标签,Web 开发者可以在HTML页面的<head>节点中加入<meta>标签
        <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
    (2).HTTP 头信息控制缓存:
        浏览器第一次请求:/Java知识点/Java/JavaEE/浏览器第一次请求流程图.png
        浏览器再次请求时:/Java知识点/Java/JavaEE/浏览器请求流程.png
### 6.2.几个重要概念:
    (1).Expires 策略:
        Expires 是Web服务器响应消息头字段,在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而无需再次请求
        Expires 是HTTP 1.0的东西,现在默认浏览器均默认使用HTTP 1.1,所以它的作用基本忽略;
        Expires 的一个缺点就是:返回的到期时间是服务器端的时间;
        在HTTP 1.1版开始,使用 Cache-Control: max-age=秒替代;
    (2).Cache-control策略:
        Cache-Control与 Expires的作用一致,都是指明当前资源的有效期,控制浏览器是否直接从浏览器缓存取数据还是重新发
            请求到服务器取数据.如果同时设置的话,其优先级高于Expires;
        值可以是:public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age
        各个消息中的指令含义如下:
            A.public:指示响应可被任何缓存区缓存.
            B.private:指示对于单个用户的整个或部分响应消息.不能被共享缓存处理.
                这允许服务器仅仅描述当用户的部分响应消息.此响应消息对于其他用户的请求无效。
            C.no-cache:指示请求或响应消息不能缓存,该选项并不是说可以设置"不缓存".容易望文生义.
            D.no-store:用于防止重要的信息被无意的发布.在请求消息中发送将使得请求和响应消息都不使用缓存,完全不存下來.
            E.max-age:指示客户机可以接收生存期不大于指定时间(以秒为单位)的响应.
            F.min-fresh:指示客户机可以接收响应时间小于当前时间加上指定时间的响应.
            G.max-stale:指示客户机可以接收超出超时期间的响应消息.如果指定max-stale消息的值,
                那么客户机可以接收超出超时期指定值之内的响应消息
    (3).Last-Modified/If-Modified-Since:Last-Modified/If-Modified-Since 要配合 Cache-Control 使用.
        Last-Modified:标示这个响应资源的最后修改时间.web服务器在响应请求时,告诉浏览器资源的最后修改时间.
        If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)发现资源具有 Last-Modified声明,则再次向web服务器请求
            时带上头 If-Modified-Since,表示请求时间.web服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修改时
            间进行比对.若最后修改时间较新,说明资源又被改动过,则响应整片资源内容(写在响应消息包体内)HTTP 200;
            若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包体，节省浏览),告知浏览器继续使用所保存的cache;
    (4).Etag(实体标识):使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新,为什么还需要Etag?
        HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题:
            Last-Modified 标注的最后修改只能精确到秒级,如果某些文件在1秒钟以内,被修改多次的话,它将不能准确标注文件的修
            改时间如果某些文件会被定期生成,当有时内容并没有任何变化,但 Last-Modified 却改变了,导致文件没法使用缓存
            有可能存在服务器没有准确获取文件修改时间,或者与代理服务器时间不一致等情形
        Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符,能够更加准确的控制缓存.
        Last-Modified 与 ETag一起使用时,服务器会优先验证ETag
### 6.3.几种状态码的区别:
    (1).200 状态:当浏览器本地没有缓存或者下一层失效时,或者用户点击了 CTRL+F5 时,浏览器直接去服务器下载最新数据;
    (2).304 状态:这一层由 Last-Modified/ETag 控制.当下一层失效时或用户点击refresh,F5时,浏览器就会发送请求给服务器,
        如果服务器端没有变化,则返回304给浏览器;
    (3).200 (form cache):这一层由 expire/cache-control 控制,expires(http1.0有效)是绝对时间,cache-control(http1.1)相对时间,
        两者都存在时,cache-control 覆盖 expires,只要没有失效,浏览器只访问自己的缓存.
### 6.4.用户行为与缓存:
    用户行为 	|Expires/Cache-Control| Last-Modified/Etag	
    地址栏回车		有效					有效
    页面链接跳转	有效					有效
    新开窗口		有效					有效
    前进/后退		有效					有效
    F5刷新			无效(BR重置max-age=0)	有效
    Ctrl+F5刷新		无效(重置CC=no-cache)	无效
    
## 7.HTTPS

# 五.DNS协议-应用层
## 1.DNS 协议:
    是应用层协议,使用客户机/服务器模式在通信的端系统之间运行
## 2.DNS 解析过程:
![image](https://github.com/chenlanqing/learningNote/blob/master/Java/JavaEE/images/DNS解析过程.png)

    (1).浏览器会检查缓存中有没有这个域名对应的解析过的IP地址,如果缓存中存在,则这个解析过程结束.
        浏览器缓存域名也是有限制的,不仅浏览器的缓存大小有限制,而且缓存的时间也有限制.
    (2).如果用户浏览器缓存中没有数据,浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果.
        操作系统也有一个域名解析的过程.windows是通过C:\Windows\System32\drivers\etc\hosts文件来设置,
        在Linux中可以通过/etc/hosts文件来设置,用户可以将任何域名解析到任何能够访问的IP地址;
    (3).前两个过程无法解析时,就需要用到DNS服务器地址了.操作系统会把这个域名发送给 LDNS(本地区的域名服务器).
        专门的域名解析服务器性能都会很好,它们一般都会缓存域名解析结果,当然缓存时间是受到域名的失效时间控制的.
        大约80%的域名解析到这里就结束了,所以LDNS主要承担了域名的解析工作;
    (4).如果 LDNS 仍未命中,就直接到 Root Server 域名服务器请求解析;
    (5).根域名服务器返回本地域名服务器一个所查询的主域名服务器(gTLD Server)的地址.
        gTLD是国际顶级域名服务器,如.com、.cn、.org等,全球只有13台左右
    (6).本地域名服务器 LDNS 再向上一步返回的 gTLD 服务器发送请求.
    (7).接受请求的gTLD服务器查找并返回此域名对应的Name Server 域名服务器的地址,这个Name Server
        通常就是用户注册的域名服务器;
    (8).Name Server 域名服务器会查询存储的域名和IP的映射关系表,在正常情况下都根据域名得到目标IP地址,
        连同一个TTL值返回给 DNS Server 域名服务器;
    (9).返回该域名对应的IP和TTL值,LDNS 会缓存这个域名和IP的对应关系,缓存时间由TTL值控制;
    (10).把解析的结果返回给用户,用户根据TTL值缓存在本地系统中,域名解析过程结束.
## 3.清除缓存的域名:
    缓存解析结果的位置:Local DNS Server 和 用户的本地机器
    (1).windows: ipconfig /flushdns
    (2).Linux 环境下可以通过/etc/init.d/nscd restart来清除缓存
    (3).Java 中 JVM 也会缓存 DNS 解析的结果,这个缓存是在 InetAddress 类中完成的,这个缓存时间比较特殊,
        有两种缓存策略:一种是正确的解析结果,一种是错误的解析结果;
        这两个缓存时间有两个配置项控制,配置项在 %JRE_HOME%/lib/security/java.security 文件中配置的.
        对应配置项分别为:networkaddress.cache.ttl,networkaddress.cache.negative.ttl,默认值分别为 -1(永不失效)
        和 10(缓存10秒).直接修改这两个值就可以了,也可以通过在Java启动参数中增加 -Dsun.net.inetaddr.ttl=xxx来
        修改默认值,也可以通过 InetAddress 类动态修改;
        ==> 如果需要使用 InetAddress 类解析域名,必须是单例模式,不然会有验证的性能问题.
## 4.域名解析方式:
    域名解析记录主要分为 A记录、MX记录、CNAME记录、NS记录 和 TXT记录
    (1).A记录:A 代表 Address,用来指定域名对应的IP地址,如将item.taobao.com指定到115.238.23.xxx,将switch.taobao.com
        指定到121.14.24.xxx. A 记录可以将多个域名解析到一个IP地址,但是不能将一个域名解析到多个IP地址;
    (2).MX记录:Mail Exchange,就是可以将某个域名下的邮件服务器指向自己的 Mail Server,如taobao.com域名的	A记录IP地址
        是115.238.25.xxx,如果将MX记录设置为115.238.25.xxx,即xxx@taobao.com的邮件路由,DNS 会将邮件发送到115.238.25.xxx
        所在的服务器,而正常通过Web请求的话仍然解析到A记录的IP地址;
    (3).CANME 记录:Canonical Name,即别名解析,所谓别名解析就是可以为一个域名设置一个或者多个别名;
    (4).NS记录:为某个域名指定 DNS 解析服务器,也就是这个域名由指定的IP地址的DNS服务器取解析;
    (5).TXT记录:为某个主机名或域名设置说明,如可以为ddd.net设置TXT记录为"这是XXX的博客"这样的说明

# 六.其他网络相关知识点
## 1.跨域问题
### 1.1.什么是跨域
    跨域是指一个域下的文档或脚本试图去请求另一个域下的资源
    是因为JavaScript同源策略的限制,a.com 域名下的js无法操作b.com或是c.a.com域名下的对象.
    当两个域具有相同的协议(如http), 相同的端口(如80),相同的host(如www.example.org),那么我们就可以认为它们是相同的域,
    比如 "http://www.example.org/index.html"和"http://www.example.org/sub/index.html"是同域,
    而 "http://www.example.org", "https://www.example.org", "http://www.example.org:8080", "http://sub.example.org"
    中的任何两个都将构成跨域;
### 1.2.广义的跨域
    (1).资源跳转:A 链接,重定向,表单提交
    (2).资源嵌入:<link>,<script>,<img>,<frame>等dom标签,还有样式中的background:url(),@font-face等文件外链;
    (3).脚本请求:js发起的ajax请求,dom和js的跨域操作;
    我们常说的跨域是狭义的,是由浏览器同源策略限制的一类请求场景
### 1.3.什么是同源策略:(SOP-Same Origin Policy)
    (1).同源策略是一种约定,是浏览器最核心的也是最基本的安全功能,如果缺少同源策略很容易收到XSS,CSRF 攻击.
        所谓同源,即"协议+域名+端口"三者相同,即使是两个不同的域名指向同一个IP地址,也非同源
    (2).同源策略限制以下行为:
        cookie,localString 和indexDb无法读取;
        dom和js对象无法获得
        ajax请求不能发送
### 1.4.常见跨域场景:
    URL                                      说明                    是否允许通信
    http://www.domain.com/a.js
    http://www.domain.com/b.js         同一域名，不同文件或路径           允许
    http://www.domain.com/lab/c.js

    http://www.domain.com:8000/a.js
    http://www.domain.com/b.js         同一域名，不同端口                不允许
        
    http://www.domain.com/a.js
    https://www.domain.com/b.js        同一域名，不同协议                不允许
        
    http://www.domain.com/a.js
    http://192.168.4.12/b.js           域名和域名对应相同ip              不允许
        
    http://www.domain.com/a.js
    http://x.domain.com/b.js           主域相同，子域不同                不允许
    http://domain.com/c.js
        
    http://www.domain1.com/a.js
    http://www.domain2.com/b.js        不同域名                         不允许
### 1.5.常见跨域解决方案:
#### 1.5.1.通过jsonp跨域:
    (1).通常为了减轻web服务器的负载,我们把js、css、img等静态资源分离到另一台独立域名的服务器上,在html页面中再通过相应的标签从不同域名
        下加载静态资源,而被浏览器允许.基于此原理.我们可以通过动态创建script.再请求一个带参网址实现跨域通信.
    (2).原生实现:
        <script>
            var script = document.createElement('script');
            script.type = 'text/javascript';
            // 传参并指定回调执行函数为onBack
            script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
            document.head.appendChild(script);
            // 回调执行函数
            function onBack(res) {
                alert(JSON.stringify(res));
            }
            </script>
            服务端返回如下:
            onBack({"status": true, "user": "admin"})
    (3).jQuery实现:
        $.ajax({
            url: 'http://www.domain2.com:8080/login',
            type: 'get',
            dataType: 'jsonp',  // 请求方式为jsonp
            jsonpCallback: "onBack",    // 自定义回调函数名
            data: {}
        });
    (4).缺点:只能实现get一种请求
#### 1.5.2.document.domain + iframe跨域:此方案仅限主域相同,子域不同的跨域应用场景
    (1).实现原理:两个页面都通过js强制设置document.domain为基础主域,就实现了同域.
    (2).父窗口:(http://www.domain.com/a.html)
        <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
        <script>
            document.domain = 'domain.com';
            var user = 'admin';
        </script>
    (3)子窗口:(http://child.domain.com/b.html)
        <script>
            document.domain = 'domain.com';
            // 获取父窗口中变量
            alert('get js data from parent ---> ' + window.parent.user);
        </script>
#### 1.5.3.location.hash + iframe:
    (1).实现原理:a欲与b跨域相互通信,通过中间页c来实现. 三个页面.不同域之间利用iframe的location.hash传值.相同域之间直接js访问来通信
    (2).具体实现:A域:a.html ---> B域:b.html ---> A域:c.html,a与b不同域只能通过hash值单向通信,b与c也不同域也只能单向通信,但c与a同域,
        所以c可通过parent.parent访问a页面所有对象
    (3).
#### 1.5.4.window.name + iframe跨域
#### 1.5.5.postMessage跨域
#### 1.5.6.跨域资源共享(CORS)
#### 1.5.7.nginx代理跨域
#### 1.5.8.nodejs中间件代理跨域
#### 1.5.9.WebSocket 协议跨域

## 2.


# 参考资料

* [详解TCP/IP协议](https://www.jianshu.com/p/9f3e879a4c9c)
* [详解HTTP协议](https://www.jianshu.com/p/6e9e4156ece3)
* [OSI七层模型图解](http://www.cnblogs.com/lemo-/p/6391095.html)
* [TCP三次握手四次挥手详解](http://www.cnblogs.com/zmlctt/p/3690998.html)
* [TCP/IP四层模型](http://www.cnblogs.com/BlueTzar/articles/811160.html)
* [简析TCP的三次握手与四次分手](https://www.jellythink.com/archives/240)
* [前端常见跨域解决方案](https://segmentfault.com/a/1190000011145364)
