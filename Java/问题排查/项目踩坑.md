## 1、关于定时任务

在做定时任务时，如果定时任务时周期性的，比如5分钟执行一次，需要考虑如果某次定时任务运行时间超过了5分钟，下次定时任务执行时需要控制是否执行，具体方案：
- 使用锁控制，比如redis锁，注意一点要释放redis锁、设置锁超时时间；
- 使用对应数据的状态，比如说：查询的是失败的记录，那么处理中的数据状态变为处理中；

## 2、系统压力

注意跨系统调用时考虑对接系统的压力

## 3、慢SQL的问题

## 4、死锁问题

- 批量处理数据时，注意在更新数据时对需要更新的数据进行排序，防止并发造成数据库死锁；
- 批量更新数据时，最好是按照主键来更新，如果更新的where条件的字段不带索引，或者是多个条件，也可能造成死锁；mysql中最常用的引擎是Innodb，Innodb默认使用的是行锁。而行锁是基于索引的，因此要想加上行锁，在加锁时必须命中索引，否则将使用表锁

## 5、关于多线程处理

有表 table_a 有个字段count，需要根据原有数量更新最新数量，更新的量m，如果直接从事数据库查询会存在并发问题，可以直接在sql中：count = count + m;

## 6、关于长事务

处理逻辑要有很长的处理事务逻辑
- 不要一次性地用 delete 语句删除太多数据。其实，这就是一个典型的大事务场景。一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作；
- 大表 DDL

## 7、关于时间

终端的时间需要保持跟服务端的时间一致；

## 8、关于线上数据删除

账号分离。这样做的目的是，避免写错命令：
- 只给业务开发同学 DML 权限，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持；
- 即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号；

制定操作规范。这样做的目的，是避免写错要删除的表名：
- 在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。
- 改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表

备份脚本、执行脚本、验证脚本和回滚脚本