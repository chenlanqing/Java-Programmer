# 一.IO 通信:
#### 1.Linux 网络IO 模型:
	(1).阻塞IO模型:缺省情况下,所有文件操作都是阻塞的;
	(2).非阻塞IO模型;
	(3).IO复用模型;
	(4).信号驱动IO模型;
	(5).异步IO
#### 2.Java中IO:
	2.1.BIO:采用BIO通信模型的服务端,由一个独立的 Acceptor现场负责监听客户端连接, 它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理,
		处理完成后,通过输出流返回给应答给客户端,线程销毁.这是典型的一请求一应答通信模型.
		该模型最大的问题是缺乏弹性伸缩能力,当客户端并发访问量增加后,服务端的线程个数和客户端并发访问数呈1:1的正比关系.由于线程是Java虚拟机的非常宝贵的系统
		资源,当线程数膨胀后,系统的性能急剧下降,系统可能会发生线程堆栈溢出,创建线程失败等.
	2.2.伪异步IO:采用线程池和任务队列可以实现伪异步IO
	2.3.NIO:
	2.4.AIO:
# 二.Netty 入门:
#### 1.不建议使用原生NIO类库进行开发的原因:
	(1).NIO 类库和API繁杂,使用麻烦,你需要熟练掌握 Selector, ServerSocketChannel,SocketChannel,ByteBuffer 等.
	(2).需要具备其他的额外技能做铺垫,例如熟悉Java多线程编程.这时因为NIO编程设计到Reactor模式,你必须对多线程和
	网络编程非常熟悉,才能编写出高质量的NIO程序.
	(3).可靠性能力补齐,工作量和难度非常大.例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和
	异常码流的处理问题.NIO 编程的特点是功能开发相对容易、但是可靠性能力补齐的工作量和难度都非常大.
	(4).JDK NIO 的bug,如臭名昭著的 epoll bug 会导致 Selector 空轮询,最终导致CPU 100%;
#### 2.Netty 的特点:
	(1).API 使用简单,开发门槛低;
	(2).功能强大,预置了多种编解码功能,支持多种主流协议;
	(3).定制能力强,可以通过 ChannelHandler 对通信框架进行灵活扩展;
	(4).性能高,通过与其他业界主流的NIO框架对比,Netty 的综合性能最优;
	(5).成熟,稳定,Netty 修复了发现了JDK NIO BUG;
	(6).社区活跃,版本迭代周期短,发现的bug可以即使修复
	(7).经历了大规模的商业应用考虑.
#### 3.粘包和拆包:
	3.1.TCP 是个流的协议,是连成一片的,其间没有分界线,TCP 底层并不了解业务数据的具体含义,它会根据 TCP 缓冲区的实际
		情况进行包的划分,所以在业务上认为,一个完整可能会被TCP拆分成多个包进行发送,也有可能把多个小的包封装成一个
		大的数据包发送.就是所谓的TCP粘包和拆包问题.
	3.2.TCP 粘包和拆包发生的原因:
		(1).应用程序 write 写入的字节大小大于套接口发送的缓冲区大小;
		(2).进行 MSS 大小的TCP分段;
		(3).以太网帧 payload 大于 MTU 进行 IP 分片;
	3.3.粘包解决策略:
		由于底层的TCP无法理解上层的业务数据,所以在底层是无法保证数据不被拆分和重组的.这个问题只能通过
		上层的应用协议栈设计来解决.
		(1).消息定长,例如每个报文的大小固定长度200字节,如果不够,空位补空格;
		(2).在包尾增加回车换行符进行分割,如FTP协议
		(3).将消息分为消息头和消息体,消息头中包含表示消息总长度的字段,
	3.4.Netty 解决粘包和拆包:
		(1).LineBasedFrameDecoder:依次遍历 ByteBuf 中可读的字节,判断是否有"\n" 或者 "\r\n",如果有就以此
			位置为结束位置;
		(2).StringDecoder:
		两者组合是按行奇幻的文本解码器
# 三.Netty 源码分析: