# 一、微服务

## 1、微服务与微服务架构

- 微服务：强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用；
- 微服务架构：微服务架构一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级通信机制互相沟通，这些服务是围绕业务能力建立的，并且可以由完全自动化的部署机构独立部署。这些服务的集中管理只有最低限度，可以用不同的编程语言编写并使用不同的数据存储技术；

微服务的核心是远程通信和服务治理。远程通信提供了服务之间通信的桥梁，服务治理则提供了服务的后勤保障

## 2、微服务优缺点

- 优点：
    - 每个服务足够内聚，足够小，代码容易理解，这样能够聚焦一个值得的业务功能；
    - 开发简单，开发效率提高；
    - 微服务能够被小团队独立开发；
    - 微服务是松耦合的，可以独立部署；
    - 微服务能够使用不同的语言开发；
    - 易于与第三方集成；
    - 微服务知识业务逻辑的代码，不会前端相关组件产生关系；

- 缺点：
    - 分布式系统的复杂性；
    - 多服务运维难度高；
    - 系统部署依赖；
    - 服务通信成本；
    - 数据一致性；
    - 系统集成测试；
    - 性能监控；

## 3、微服务技术栈

- 服务开发：SpringBoot、Spring、SpringMVC
- 服务配置与管理：Netflix的Archaius、阿里的Diamond
- 服务注册：Eureka、Consul、Zookeeper等
- 服务调用：Rest、Rpc、Grpc
- 服务负载均衡：Ribbon、Nginx
- 服务监控：
- 服务熔断、降级：Hystrix、Envoy、Resilience4j
- 服务路由（网关）：Zuul、gateway
- 链路追踪：Slueth
- 消息队列：Kafka、RabbitMQ、ActiveMQ、Stream
- 服务配置中心：SpringCloudConfig
- 服务部署：Docker
。。。

## 4、微服务选型

### 4.1、微服务选型依据

- 整体解决方案和框架成熟度
- 社区热度
- 可维护性
- 学习曲线

### 4.2、微服务框架对比

Dubbo、HSF、DubboX
- 功能定位
- 支持Rest
- 支持多语言
- 负载均衡
- 配置服务
- 服务调用链调用
- 高可用、容错

## 5、微服务设计原则

![](image/微服务一般架构.png)

- API
- Service
- Dao/Repo

### 5.1、不同维度拆分微服务

- 压力模型：高频高并发流量（商品详情页、优惠计算）、低频突发流量（秒杀、批量上架）------> 服务隔离【热点数据、热点隔离】
- 主链路规划：搜索、详情、购物车、下单、支付  -----> 服务隔离、异常容错、流控、弹性
- 大中台：领域模型拆分（DDD）
- 用户群体拆分：2C、2B、用户端、运营、采购 ----> 相同领域、独有场景
- 前后台业务：商家后台、运营后台

### 5.2、微服务改造

- 抗压维度：低频瞬时流量场景（商品发布服务、库存发布）、高频匀速流量场景（商品详情页、商品搜索服务）
- 业务维度：定时任务（改价单、库存发布计划）、主链路 + 用户场景（商品详情页、商品搜索服务、营销优惠计算、领券、购物车、订单页商品信息、广告投放）、运营场景（商品编辑、类目编辑、营销规则设置、商品发布服务）
- 隔离业务场景、剥离高频接口

### 5.3、微服务的无状态化

有状态：上下文依赖，缺乏水平扩展，比如单机Session、单机缓存（Hash + 本地缓存的热点方案）

应用无状态、配置管理有状态

### 5.4、接口版本控制兼容

API Version 实现思路：
- RPC接口：可以指定具体的接口版本
- HTTP接口：通过path 或 header（在header中设置版本号） --> 业务网关

## 6、微服务问题

### 6.1、服务雪崩

### 6.2、服务熔断

#### 1、断路器原理

熔断，形象一点儿说：熔断机制参考了电路中保险丝的保护原理，当电路出现短路、过载时，保险丝就会自动熔断，保证整体电路的安全。

而在微服务架构中，服务的熔断机制是指：在服务 A 调用服务 B 时，如果 B 返回错误或超时的次数超过一定阈值，服务 A 的后续请求将不再调用服务 B。这种设计方式就是断路器模式；

在这种模式下，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机中存在关闭、半打开和打开三种状态：
- 关闭：正常调用远程服务。
- 半打开：尝试调用远程服务。
- 打开：直接返回错误，不调用远程服务

这三种状态之间切换的过程如下。
- `关闭`转换`打开`：当服务调用失败的次数累积到一定的阈值时，服务熔断状态，将从关闭态切换到打开态。
- `打开`转换`半打开`：当熔断处于打开状态时，我们会启动一个超时计时器，当计时器超时后，状态切换到半打开态。
- `半打开`转换`关闭`：在熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态

#### 2、如何实现断路器

- [resilience4j](https://github.com/resilience4j/resilience4j)

![](image/微服务-断路器实现流程.png)

#### 3、服务熔断中需考虑的设计

- 异常处理
- 异常的类型
- 日志
- 手动重置
- 加快熔断器的熔断操作
- 重复失败请求

### 6.3、服务降级

**降级设计的原理：**

降级设计本质上是站在系统整体可用性的角度上考虑问题：当资源和访问量出现矛盾时，在有限的资源下，放弃部分非核心功能或者服务，保证整体的可用性。这是一种有损的系统容错方式；这样看来，熔断也是降级的一种手段（除此之外还有限流、兜底服务等）

**如何设计一个降级机制：**

从架构设计的角度出发，降级设计就是在做取舍，你要从服务降级和功能降级两方面来考虑

在实现上，服务降级可以分为读操作降级和写操作降级。
- 读操作降级：做数据兜底服务，比如将兜底数据提前存储在缓存中，当系统触发降级时，读操作直接降级到缓存，从缓存中读取兜底数据，如果此时缓存中也不存在查询数据，则返回默认值，不在请求数据库；
- 写操作降级：同样的，将之前直接同步调用写数据库的操作，降级为先写缓存，然后再异步写入数据库；

提炼一下这两种情况的设计原则。
- 读操作降级的设计原则，就是取舍非核心服务。
- 写操作降级的设计原则，就是取舍系统一致性：实现方式是把强一致性转换成最终一致性。比如，两个系统服务通过 RPC 来交互，在触发降级时，将同步 RPC 服务调用降级到异步 MQ 消息队列中，然后再由消费服务异步处理

**降级的方式：**
- 延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行；
- 在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区；
- 页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
- 页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址；
- 写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。 
- 读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景

### 6.4、服务容错

### 6.5、线程隔离

### 6.6、接口版本兼容

### 6.7、流量整形

- 限流：令牌桶、漏斗
- 增强算法：预热模型（Guava）

### 6.8、服务治理

- [如何搭建服务治理平台](https://blog.51cto.com/u_13609606/3108217)

如何维护当前可用的服务列表：注册中心

（1）服务注册
（2）服务发现：基于client的服务发现，服务主动拉取
（3）发起调用
（4）服务续约/心跳
（5）服务剔除

### 6.9、主链路规划

用户流量漏斗模型：流量由多到少

确保主链路，提高转化率

比如下单链路场景：主搜导购 → 购物车 → 下单

主搜导购：
- 导流：站内、直播、直通车、分会场、类目渠道、抖音、聚划算等；
- 转化：SKU、库存信息、用户评论、图片空间、富文本信息、收藏夹、客服中心、热销排行、视频空间、营销计算、活动信息；

购物车：
- 添加购物车
- 商品列表信息
- 营销计算
- 商家信息模组
- 页面操作：修改数量、删除商品；
- 导购模组：掌柜热卖、最近浏览、画像推荐

下单：
- 创建订单
- 商品列表信息
- 营销计算
- 地址模块
- 支付系统对接

### 6.10、链路监控

离群点分析，在链路监控中，可以通过离群点分析来判断某个时间段或者时间点内业务发生异常；

## 7、EDA事件驱动

### 7.1、概述

### 7.2、适用场景

- 异步处理
- 跨平台/语言通信
- 应用解耦
- 可靠投递
- 最终一致性

## 8、服务拆分

- 为什么做架构拆分？通常最直接目的就是做系统之间解耦、子系统之间解耦，或模块之间的解耦。
- 为什么要做系统解耦？系统解耦后，使得原本错综复杂的调用逻辑能有序地分布到各个独立的系统中，从而使得拆封后的各个系统职责更单一，功能更为内聚。
- 为什么要做职责单一？因为职责单一的系统功能逻辑的迭代速度会更快，会提高研发团队响应业务需求的速度，也就是提高了团队的开发效率。
- 为什么要关注开发效率？研发迭代效率的提升是任何一家公司在业务发展期间都最为关注的问题，所以从某种程度上看，架构拆分是系统提效最直接的手段。

所以，架构拆分其实是管理在技术上提效的一种手段；


# 二、微服务授权认证

- HTTP 基本认证
- 基于 Session 的认证：分布式Session
- 基于 Token 的认证
    - JWT
    - OAuth2.0
 
# 三、微服务部署

## 1、蓝绿发布

## 2、滚动发布

## 3、灰度发布

灰度发布， 也叫金丝雀发布。是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来

## 4、A/B 测试



# 参考资料

* [理解微服务架构的核心](https://segmentfault.com/a/1190000014352312)
* [Dubbo面试题](https://mp.weixin.qq.com/s/Q_En263YPBsmuu5bBI6Rcw)
* [Dubbo服务暴露、调用过程](https://www.jianshu.com/p/1ff25f65587c)
* [Dubbo中SPI的使用](https://mp.weixin.qq.com/s/DdTw_4xBXU1NTv2Sm3xEZg)
* [Dubbo中SPI的实现原理](https://juejin.im/post/5c909949e51d450fae18deb8)
* [Dubbo中Filter原理](https://www.jianshu.com/p/c5ebe3e08161)
* [Hystrix工作原理](https://segmentfault.com/a/1190000012439580)
* [SpringCloud与Dubbo对比](http://youzhixueyuan.com/comparison-of-dubbo-and-springcloud-architecture-design.html)
* [Soul网关](https://github.com/Dromara/soul)
* [微服务架构设计](https://gudaoxuri.gitbook.io/microservices-architecture/)
* [服务探测](https://github.com/megaease/easeprobe)
