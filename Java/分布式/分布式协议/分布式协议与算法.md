# 一、拜占庭将军问题

## 1、问题描述

https://github.com/XChainLab/documentation/blob/master/consensus/consensus.byzantine.generals.md

拜占庭帝国，即中世纪的东罗马帝国，拥有巨大的财富，周围10个邻邦垂诞已久。但拜占庭高墙耸立，固若金汤，没有一个单独的邻邦能够成功入侵。任何单个邻邦入侵都会失败，同时也有可能自身被其他9个邻邦入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。然而，如果其中的一个或者几个邻邦事先答应好一起进攻，但实际过程出现背叛，那么入侵者可能都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题；

在这个问题里，各邻国最重要的事情是：所有将军如何能够达成共识去攻打拜占庭帝国。这些将军需要实现某一个统一的目标，一致进攻或者一致撤退，但是单独行动却又可能面临失败，所以必须达成共识，一致合作。由于叛徒的存在，将军们缺乏达成一致的有效途径。这里的“一致性”才是拜占庭将军问题需要探讨的内容，假如本来叛徒数量就已经多到了问题无解的地步，那么这个就是“反叛”的问题了。同时我们的目标是忠诚的将军能够达成一致，对于这些忠诚的将军来说，进攻或者撤退都是可以的，只要他们能够达成一致就可以

> 一句话概括：如何在可能有误导信息的情况下，采用合适的通讯机制，让多个将军达成共识，制定一致性的作战计划？

## 2、二忠一叛问题

### 2.1、问题描述

假设有3个将军一起进攻，`A、B、C`三位将军，因为对方很强大，只有半数以上的将军参与进攻，才能击败敌人，在这个期间，将军们彼此之间需要通过信使传递消息，然后协商一致之后，才能在同一时间点发动进攻；有一天，这三位将军各自一脸严肃地讨论明天是进攻还是撤退，并让信使传递信息，按照“少数服从多数”的原则投票表决，两个人意见一致就可以了，比如：
- `A`根据侦查情况决定撤退；
- `B`、`C`根据侦查信息，决定进攻；

那么按照原则，`A`也会进攻。最终，3支军队同时进攻，大败敌军

可是，问题来了： 一旦有人在暗通敌军，就会出现作战计划不一致的情况。比如`A`向`B`、`C`分别发送了`撤退`的消息，`B`向`A`和`C`发送了`进攻`的消息。撤退：进攻 =1:1，无论C投进攻还是撤退，都会成为 2:1，这个时候还是会形成一个一致性的作战方案；

但是`C`这个叛徒在暗中配合敌军，让信使向`A`发送了`撤退`，向`B`发送了`进攻`，那么：
- `B`看到的是，撤退：进攻 =1:2；
- `A`看到的是，撤退：进攻 =2:1；

按照"少数服从多数"的原则，就会出现`B`单独进攻敌军，当然，最后肯定是因为寡不敌众，被灭了；

在这里，你可以看到，叛将`C`通过发送误导信息，非常轻松地干扰了`A`和`B`的作战计划，导致这两位忠诚将军被敌军逐一击败。这就是所说的二忠一叛难题

### 2.2、解决办法一：口信消息型拜占庭问题之解

首先，三位将军都分拨一部分军队，由`D`率领，`D`参与作战计划讨论并执行作战指令。这样，3 位将军的作战讨论，就变为了 4 位将军的作战讨论，这能够增加讨论中忠诚将军的数量；4 位将军还约定了，如果没有收到命令，就执行预设的默认命令，比如“撤退”

### 2.3、解决办法二：签名消息型拜占庭问题之解

## 2、使用场景

- 在存在恶意节点行为的场景中（比如在数字货币的区块链技术中），必须使用拜占庭容错算法（Byzantine Fault Tolerance，BFT），常用的拜占庭容错算法还有：PBFT 算法，PoW 算法；
- 在计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（Crash Fault Tolerance，CFT）。CFT 解决的是分布式的系统中存在故障，但不存在恶意节点的场景下的共识问题。 也就是说，这个场景可能会丢失消息，或者有消息重复，但不存在错误消息，或者伪造消息的情况。常见的算法有 Paxos 算法、Raft 算法、ZAB 协议

## 3、对应计算机场景

回到计算机世界的分布式场景中：
- 故事里的各位将军，你可以理解为计算机节点；
- 忠诚的将军，你可以理解为正常运行的计算机节点；
- 叛变的将军，你可以理解为出现故障并会发送误导信息的计算机节点；
- 信使被杀，可以理解为通讯故障、信息丢失；
- 信使被间谍替换，可以理解为通讯被中间人攻击，攻击者在恶意伪造信息和劫持通讯；