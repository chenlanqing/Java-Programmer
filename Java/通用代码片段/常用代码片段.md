# 一、获取当前执行的方法名称

获取当前执行的方法名称，有四种方法：
- （1）使用 `Thread.currentThread().getStackTrace() `方法
- （2）使用异常对象的 `getStackTrace()` 方法
- （3）使用匿名内部类的 `getClass().getEnclosingMethod()` 方法
- （4）Java 9 的 `Stack-Walking API`

## 1、使用 Thread.currentThread().getStackTrace() 方法

```java
// 获取方法名:
Thread.currentThread().getStackTrace()[1].getMethodName();
```
- 优点：简单易用，不需要创建额外的对象。
- 缺点：性能较低，因为 `Thread.currentThread().getStackTrace(`) 方法获取堆栈跟踪信息需要遍历整个调用栈，而且需要保证线程安全性；

## 2、使用异常对象的 getStackTrace()方法

这种方法是通过创建一个新的异常对象，然后从其堆栈跟踪信息中提取出当前方法名和参数的：
```java
 // 获取当前方法名
String methodName = new Exception().getStackTrace()[0].getMethodName();
```
这种方法仍然需要获取堆栈跟踪信息，而且需要创建异常对象。

缺点是需要创建额外的对象，而且代码较为复杂，不太直观

## 3、匿名内部类的 getClass().getEnclosingMethod()方法

这种方法是通过创建一个匿名内部类的对象，然后从其类对象中获取当前方法的方法对象，再从方法对象中获取当前方法名和参数的：
```java
// 获取当前方法名
String methodName = new Object(){}.getClass().getEnclosingMethod().getName();
```
- 优点：不需要获取堆栈跟踪信息，而且不会创建异常对象，因此性能和可读性都较好。
- 缺点：需要创建额外的对象，而且代码较为复杂，不太直观。

## 4、Java 9 的 Stack-Walking API

Java 9 引入了 Stack-Walking API，以惰性且高效的方式遍历 JVM 堆栈帧：
```java
StackWalker walker = StackWalker.getInstance();
Optional<String> optional = walker.walk(frames -> frames
        .findFirst()
        .map(StackWalker.StackFrame::getMethodName));
System.out.println("当前方法名：" + optional.get());
```
首先，我们使用 StackWalker.getInstance() 工厂方法获取 StackWalker 实例。

然后我们使用 walk() 方法从上到下遍历栈帧：
- walk() 方法可以将堆栈帧转化为 Stream流
- findFirst() 方法从 Stream 流中的获取第一个元素，也就是堆栈的顶部帧，顶部帧就代表当前正在执行的方法
- map() 方法用于获取顶部帧 StackFrame 的当前方法名称

与以上方法相比，Stack-Walking API 有很多优点：
- 线程安全
- 无需创建匿名内部类实例 - `new Object().getClass(){}`
- 无需创建异常 - `new Throwable()`
- 无需急切地捕获整个堆栈跟踪，这可能成本很高 - `Thread.currentThread()`
- StackWalker 是以一种懒惰的方式逐一遍历堆栈。在需要获取当前方法名称时，可以只获取顶部帧，而不需要捕获整个堆栈跟踪。

## 5、Logback是如何获取当前方法名称的

比如配置的日志格式是：
```
%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{request_id}] [%thread] [%-5level] %logger{36}:%L %M - %msg%n
```
Logback 在打印日志时，会解析这个日志输出格式，最后将 %M 占位符替换为当前方法名称。

解析日志格式的源码就在 FormattingConverter 类的 write() 方法中，write() 方法中会执行 convert() 方法，这个方法就是执行占位符替换的：
```java
@Override
final public void write(StringBuilder buf, E event) {
    String s = convert(event);
    ...
}
// convert 方法是在类 MethodOfCallerConverter  中处理方法的：
public class MethodOfCallerConverter extends ClassicConverter {
    public String convert(ILoggingEvent le) {
        StackTraceElement[] cda = le.getCallerData(); // 获取当前堆栈顶部帧
        if (cda != null && cda.length > 0) {
            // 返回当前方法名称
            return cda[0].getMethodName(); // 根据顶部帧获取当前方法名称。
        } else {
            return CoreConstants.NA;
        }
    }
}
```
> Logback 日志框架中打印日志时，就是使用异常对象的 getStackTrace() 方法来获取当前执行方法的方法名称的

## 6、性能对比

四种方案中性能最好的方案是`基于匿名内部类的 getClass().getEnclosingMethod() 方案`，性能第二是的是`基于 Java 9 出现的 Stack-Walking API 方案`，其他两种性能过于低下了


# 二、根据Cron表达式获取下一次执行时间

参考代码：[CronExpression.java](source/CronExpression.java)

```java
private static List<String> calculateCronExpression(String expression) throws ParseException {
    CronExpression cronExpression = new CronExpression(expression);
    List<String> result = Lists.newArrayList();
    Date time = new Date();
    for (int i = 0; i < NEXT_N_TIMES; i++) {
        Date nextValidTime = cronExpression.getNextValidTimeAfter(time);
        if (nextValidTime == null) {
            break;
        }
        result.add(DateFormatUtils.format(nextValidTime.getTime(), OmsConstant.TIME_PATTERN));
        time = nextValidTime;
    }
    if (result.isEmpty()) {
        result.add("INVALID: no next validate schedule time");
    }
    return result;
}
```

# 三、集合操作

## 1、iterator 与 List转换

# 四、密码校验

可以参考[若依](https://gitee.com/y_project/RuoYi-Vue)

# 五、流的操作

## 1、InputStream转String

- [how-do-i-read-convert-an-inputstream-into-a-string-in-java](https://stackoverflow.com/questions/309424/how-do-i-read-convert-an-inputstream-into-a-string-in-java)
- [ConvertInputStreamToStringBenchmark](https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/ConvertInputStreamToStringBenchmark.java)

