# 一、获取当前执行的方法名称

获取当前执行的方法名称，有四种方法：
- （1）使用 `Thread.currentThread().getStackTrace() `方法
- （2）使用异常对象的 `getStackTrace()` 方法
- （3）使用匿名内部类的 `getClass().getEnclosingMethod()` 方法
- （4）Java 9 的 `Stack-Walking API`

## 1、使用 Thread.currentThread().getStackTrace() 方法

```java
// 获取方法名:
Thread.currentThread().getStackTrace()[1].getMethodName();
```
- 优点：简单易用，不需要创建额外的对象。
- 缺点：性能较低，因为 `Thread.currentThread().getStackTrace(`) 方法获取堆栈跟踪信息需要遍历整个调用栈，而且需要保证线程安全性；

## 2、使用异常对象的 getStackTrace()方法

这种方法是通过创建一个新的异常对象，然后从其堆栈跟踪信息中提取出当前方法名和参数的：
```java
 // 获取当前方法名
String methodName = new Exception().getStackTrace()[0].getMethodName();
```
这种方法仍然需要获取堆栈跟踪信息，而且需要创建异常对象。

缺点是需要创建额外的对象，而且代码较为复杂，不太直观

## 3、匿名内部类的 getClass().getEnclosingMethod()方法

这种方法是通过创建一个匿名内部类的对象，然后从其类对象中获取当前方法的方法对象，再从方法对象中获取当前方法名和参数的：
```java
// 获取当前方法名
String methodName = new Object(){}.getClass().getEnclosingMethod().getName();
```
- 优点：不需要获取堆栈跟踪信息，而且不会创建异常对象，因此性能和可读性都较好。
- 缺点：需要创建额外的对象，而且代码较为复杂，不太直观。

## 4、Java 9 的 Stack-Walking API

Java 9 引入了 Stack-Walking API，以惰性且高效的方式遍历 JVM 堆栈帧：
```java
StackWalker walker = StackWalker.getInstance();
Optional<String> optional = walker.walk(frames -> frames
        .findFirst()
        .map(StackWalker.StackFrame::getMethodName));
System.out.println("当前方法名：" + optional.get());
```
首先，我们使用 StackWalker.getInstance() 工厂方法获取 StackWalker 实例。

然后我们使用 walk() 方法从上到下遍历栈帧：
- walk() 方法可以将堆栈帧转化为 Stream流
- findFirst() 方法从 Stream 流中的获取第一个元素，也就是堆栈的顶部帧，顶部帧就代表当前正在执行的方法
- map() 方法用于获取顶部帧 StackFrame 的当前方法名称

与以上方法相比，Stack-Walking API 有很多优点：
- 线程安全
- 无需创建匿名内部类实例 - `new Object().getClass(){}`
- 无需创建异常 - `new Throwable()`
- 无需急切地捕获整个堆栈跟踪，这可能成本很高 - `Thread.currentThread()`
- StackWalker 是以一种懒惰的方式逐一遍历堆栈。在需要获取当前方法名称时，可以只获取顶部帧，而不需要捕获整个堆栈跟踪。

## 5、Logback是如何获取当前方法名称的

比如配置的日志格式是：
```
%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{request_id}] [%thread] [%-5level] %logger{36}:%L %M - %msg%n
```
Logback 在打印日志时，会解析这个日志输出格式，最后将 %M 占位符替换为当前方法名称。

解析日志格式的源码就在 FormattingConverter 类的 write() 方法中，write() 方法中会执行 convert() 方法，这个方法就是执行占位符替换的：
```java
@Override
final public void write(StringBuilder buf, E event) {
    String s = convert(event);
    ...
}
// convert 方法是在类 MethodOfCallerConverter  中处理方法的：
public class MethodOfCallerConverter extends ClassicConverter {
    public String convert(ILoggingEvent le) {
        StackTraceElement[] cda = le.getCallerData(); // 获取当前堆栈顶部帧
        if (cda != null && cda.length > 0) {
            // 返回当前方法名称
            return cda[0].getMethodName(); // 根据顶部帧获取当前方法名称。
        } else {
            return CoreConstants.NA;
        }
    }
}
```
> Logback 日志框架中打印日志时，就是使用异常对象的 getStackTrace() 方法来获取当前执行方法的方法名称的

## 6、性能对比

四种方案中性能最好的方案是`基于匿名内部类的 getClass().getEnclosingMethod() 方案`，性能第二是的是`基于 Java 9 出现的 Stack-Walking API 方案`，其他两种性能过于低下了


# 二、根据Cron表达式获取下一次执行时间

参考代码：[CronExpression.java](source/CronExpression.java)

```java
private static List<String> calculateCronExpression(String expression) throws ParseException {
    CronExpression cronExpression = new CronExpression(expression);
    List<String> result = Lists.newArrayList();
    Date time = new Date();
    for (int i = 0; i < NEXT_N_TIMES; i++) {
        Date nextValidTime = cronExpression.getNextValidTimeAfter(time);
        if (nextValidTime == null) {
            break;
        }
        result.add(DateFormatUtils.format(nextValidTime.getTime(), OmsConstant.TIME_PATTERN));
        time = nextValidTime;
    }
    if (result.isEmpty()) {
        result.add("INVALID: no next validate schedule time");
    }
    return result;
}
```

# 三、集合操作

## 1、iterator 与 List转换

# 四、密码校验

可以参考[若依](https://gitee.com/y_project/RuoYi-Vue)

# 五、流的操作

## 1、InputStream转String

- [how-do-i-read-convert-an-inputstream-into-a-string-in-java](https://stackoverflow.com/questions/309424/how-do-i-read-convert-an-inputstream-into-a-string-in-java)
- [ConvertInputStreamToStringBenchmark](https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/ConvertInputStreamToStringBenchmark.java)

# 六、IP地址

- **应用层**透传真实源 IP 的方法，是利用 `X-Forwarded-For` 这个头部，把真实源 IP 传递给后端服务器。这个场景对 HTTP 应用有效，但是对其他应用就不行了；
- 针对**传输层**主要是有三种方法：
    - 扩展 SYN 报文的 TCP Options，让它携带真实源 IP 信息。这个需要对中间的 LB 和后端服务器都进行小幅的配置改造。
    - 利用 Proxy Protocol。这是一个逐步被各种反向代理和 HTTP Server 软件接纳的方案，可以在不改动代码或者内核配置的情况下，只修改反向代理和 HTTP Server 软件的配置就能做到。
    - 利用特定厂商的方案，如果你用的也是 NetScaler，可以利用它的相关特性来实现 TCP 层面的真实源 IP 透传。不过这也需要你修改应用代码来读取这个信息
- 网络层，我们可以用隧道 +DSR 模式的方法，让真实源 IP 直接跟服务端“对话”

```java
public static String getIp() throws Exception{
	return InetAddress.getLocalHost().getHostAddress();
}

public static String getLocalIPAddress()throws Exception{
	String ipstr = null;
	Enumeration<NetworkInterface> allNetInterfaces = NetworkInterface.getNetworkInterfaces();
	InetAddress ip = null;
	while (allNetInterfaces.hasMoreElements()) {
		NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
		if(netInterface.getName().startsWith("eth")){
			Enumeration<InetAddress> addresses = netInterface.getInetAddresses();
			while (addresses.hasMoreElements()) {
				ip = (InetAddress) addresses.nextElement();
				if(ip != null && ip instanceof Inet4Address){
					ipstr = ip.getHostAddress();
				}
			}
		}
		
	}
	if(ipstr != null)
		return ipstr;
	else
		throw new Exception("Can not get local ip address!");
}
```

# 七、获取真实文件格式

- [Java File MIME Type](https://www.baeldung.com/java-file-mime-type)

## 1、使用Files.probeContentType(path) 

```java
@Test
public void whenUsingJava7_thenSuccess() {
    Path path = new File("product.png").toPath();
    String mimeType = Files.probeContentType(path);
    assertEquals(mimeType, "image/png");
}
```
如果文件被任何实现识别，内容类型就会返回。但如果没有，则会调用系统默认的文件类型检测器。不过，默认实现是操作系统特定的，可能会失败，这取决于我们使用的操作系统。

除此之外，还需要注意的是，如果文件不存在于文件系统中，该策略也会失败。此外，如果文件没有扩展名，也会导致失败。

## 2、使用URLConnection

```java
@Test
public void whenUsingGetContentType_thenSuccess(){
    File file = new File("product.png");
    URLConnection connection = file.toURL().openConnection();
    String mimeType = connection.getContentType();
    assertEquals(mimeType, "image/png");
}
```
不过，这种方法的一个主要缺点是速度非常慢。

第二种方法使用：guessContentTypeFromName，该方法利用内部 FileNameMap 从扩展名解析 MIME 类型
```java
@Test
public void whenUsingGuessContentTypeFromName_thenSuccess(){
    File file = new File("product.png");
    String mimeType = URLConnection.guessContentTypeFromName(file.getName());
    assertEquals(mimeType, "image/png");
}
```

第三种方法使用：getFileNameMap()
```java
@Test
public void whenUsingGetFileNameMap_thenSuccess(){
    File file = new File("product.png");
    FileNameMap fileNameMap = URLConnection.getFileNameMap();
    String mimeType = fileNameMap.getContentTypeFor(file.getName());
    assertEquals(mimeType, "image/png");
}
```
该方法返回 URLConnection 所有实例使用的 MIME 类型表。然后使用该表来解析输入文件类型。

当涉及 URLConnection 时，内置的 MIME 类型表非常有限。

默认情况下，该类使用 `JRE_HOME/lib` 中的 `content-types.properties` 文件。不过，我们可以使用 `content.types.user.table` 属性指定特定于用户的表，从而对其进行扩展：
```java
System.setProperty("content.types.user.table","<path-to-file>");
```

## 3、使用MimeTypesFileTypeMap

MimeTypesFileTypeMap 通过使用文件扩展名来解析 MIME 类型。该类是 Java 6 附带的，因此在使用 JDK 1.6 时非常方便。
```java
@Test
public void whenUsingMimeTypesFileTypeMap_thenSuccess() {
    File file = new File("product.png");
    MimetypesFileTypeMap fileTypeMap = new MimetypesFileTypeMap();
    String mimeType = fileTypeMap.getContentType(file.getName());
    assertEquals(mimeType, "image/png");
}
```

## 4、jMimeMagic

jMimeMagic 是一个限制许可的库，我们可以用它来获取文件的 MIME 类型：
```xml
<dependency>
    <groupId>net.sf.jmimemagic</groupId>
    <artifactId>jmimemagic</artifactId>
    <version>0.1.5</version>
</dependency>
```
代码：
```java
@Test    
public void whenUsingJmimeMagic_thenSuccess() {
    File file = new File("product.png");
    MagicMatch match = Magic.getMagicMatch(file, false);
    assertEquals(match.getMimeType(), "image/png");
}
```
该库可处理数据流，因此不要求文件存在于文件系统中。

## 5、Apache Tika

- [Apache Tika](https://tika.apache.org/)

```xml
<dependency>
    <groupId>org.apache.tika</groupId>
    <artifactId>tika-core</artifactId>
    <version>1.18</version>
</dependency>
```
基本代码：
```java
@Test
public void whenUsingTika_thenSuccess() {
    File file = new File("product.png");
    Tika tika = new Tika();
    String mimeType = tika.detect(file);
    assertEquals(mimeType, "image/png");
}
```
