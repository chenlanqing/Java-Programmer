# 一、问题排查案例

## 1、Docker上运行Java服务后发生OOM

详细描述：一个64g内存服务器，有一个总4g分配的docker运行Java服务，起始最大均为3g，服务器内不止运行一个服务，运行3个月后此Java服务发生OOM，给出至少6种可能情况，需要有具体场景（一共9种）

**（1）堆内存不足**
- Java 服务运行时，随着时间的推移，堆内存中的对象无法及时被 GC 回收，导致堆内存耗尽。堆中的对象包括常驻缓存、大型集合、或者存在内存泄漏；
- 例如，某个服务在内存中缓存了大量用户会话数据，但未及时清理无用的会话对象，导致堆内存逐渐耗尽；

**（2）非堆内存溢出（Metaspace）**
- Java 8 及以后的版本使用 Metaspace 存储类元数据。如果有大量类动态生成或者类加载器没有被正确卸载，Metaspace 的空间会耗尽。
- 例如，系统使用了某种动态代理框架（如 CGLIB 或 Hibernate），频繁生成新的类对象或动态加载类，但由于类加载器未正确回收，导致类占用了大量 Metaspace 空间

**（3）堆外内存泄漏**
- 一些 Java 应用通过 `ByteBuffer.allocateDirect()` 分配堆外内存（如网络传输和 NIO 操作），但没有正确释放内存，导致系统内存不足。
- 例如，某个 Java 应用使用 Netty 框架进行大量的网络 I/O 操作，频繁分配和使用 Direct ByteBuffer，但由于错误的内存管理（没有显式释放），导致堆外内存被耗尽

**（4）线程数过多导致的内存耗尽**
- 每个 Java 线程都会消耗一定的栈内存（默认 1MB）。如果服务中线程池管理不当或者使用大量并发线程（如未限制线程数量），会导致内存耗尽。
- 例如，一个服务使用了未正确配置的线程池或者创建了过多的并发任务，每个线程分配的栈内存累加，最终耗尽了内存。

**（5）GC 频率过高导致内存不足**
- Java 堆内存设置不合理或对象频繁创建，导致 GC 无法及时回收老年代内存，出现“GC thrashing”，即系统忙于垃圾回收而不能正常处理应用逻辑，最终导致 OOM。
- 例如，某个应用频繁创建短生命周期的对象，大量对象无法及时回收进入老年代，Full GC 持续占用 CPU 时间，最终导致服务无法正常工作并 OOM

**（6）内存泄漏**
- 应用程序中存在引用未释放、对象长时间保留在内存中或某些类缓存管理不当，导致对象无法被 GC 回收，逐渐耗尽堆内存。
- 例如，应用使用了缓存（如 LRU Cache）但未设定缓存大小上限，或使用静态变量持有大量引用，最终导致内存泄漏

**（7）Docker 容器内存限制导致 OOM**
- 容器的内存限制导致 JVM 无法获得足够的系统内存，即便堆内存设置为 3GB，其他内存开销（如栈内存、Metaspace、Direct Memory）也会导致总内存超出限制。
- 例如，某个 Java 应用的堆外内存和栈内存总和超出了 Docker 容器的 4GB 限制，尽管 JVM 堆内存没有耗尽，容器被 OOMKilled

**（8）操作系统层面内存不足**
- 服务器上运行了多个服务，所有服务的内存需求总和超出了 64GB 内存限制，操作系统为了回收内存，选择杀掉 Java 容器进程。
- 例如，服务器运行多个内存密集型服务，随着时间推移，内存使用持续增加，最终操作系统因为内存压力，杀掉了 Docker 中的 Java 服务

**（9）内存碎片化**
- Java 堆内存或 Direct Memory 中的内存碎片过多，导致应用需要大块连续内存时，虽然总内存还未耗尽，但无法获得足够的连续内存，触发 OOM。
- 例如，某个应用长期运行过程中，频繁的对象分配和释放导致内存碎片化，导致服务无法再分配大块内存

# 二、场景设计题

## 1、假如给你一个新产品，你将从哪些方面来保障它的质量？

## 2、场景设计：底层存储

nosql、数据冗余

设计一个高性能的文件写入系统：
- 使用缓冲区（Buffer）来减少磁盘I/O操作的次数。
- 采用异步I/O或者多线程/多进程来并行处理文件写入，提高吞吐量。
- 使用内存映射（Memory-Mapped Files）技术，减少数据在用户空间和内核空间之间的拷贝。
- 选择合适的文件系统和存储介质，例如使用SSD代替HDD，或者使用高速的NVMe存储。
- 对文件系统进行适当的配置，比如调整文件系统的缓存策略或者关闭文件系统的某些特性（如atime更新）

## 3、mysql的同步方式

binlog 方案

## 4、对于订单系统，如何应对突发的读写流量

- 读写分离：提升 MySQL 并发的首选方案，因为当单台 MySQL 无法满足要求时，就只能用多个具有相同数据的 MySQL 实例组成的集群来承担大量的读写请求；
- MySQL主从架构：MySQL 做读写分离的前提，是把 MySQL 集群拆分成“主 + 从”结构的数据集群，这样才能实现程序上的读写分离，并且 MySQL 集群的主库、从库的数据是通过主从复制实现同步的；
- 对于读：可以缓存用户最近的订单数据，比如最近一周、最近10笔订单等等；

## 5、聊聊你印象最深刻的项目，或者做了什么优化

比如缓存数据库相关的，查询为空，你设置了一个-1到缓存，代表数据库没记录。下次判断-1，就不查库了，以解决缓存穿透问题。

又比如你设置缓存过期时间比较分散，解决缓存击穿问题，都可以条理清晰写到简历去，这样面试官很可能会问你相关的问题，这时候就对答如流啦。

还有平时你做的项目，有一些比较好的设计，都可以说一下哈，比如你是如何保证数据一致性的，怎么优化接口性能的。

如果是讲优化接口这一块的话，其实就是缓存、分批、并发调用、异步等那几个关键知识点。

如果是代码优化细节，你可以挑个简单的来讲，比如复杂的if逻辑条件，可以调整顺序，让程序更高效，这样会让面试官眼前一亮哦。

## 6、如果应用经常请求超时，如何解决这个问题？如何做代码预热

主要是体现JVM层面上的能力，以Dubbo为例：

Dubbo 服务预热功能的核心代码：`org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance#calculateWarmupWeight`

https://juejin.cn/post/7134547114725965838

## 7、如果用redis来实现抢红包，比如10个红包，大家并发来抢，使用什么数据结构最合适

## 8、设计一个全局微观有序的发号机

## 9、场景题：设计一个抢红包系统

参考[红包业务](../实际业务/业务系统.md#十八红包业务)

## 10、场景题：设计一个im系统包括群聊单聊

## 11、场景题：设计数据库连接池

参考[池化技术设计](../软件工程/软件设计/设计案例.md#二池化技术设计)

## 12、场景题：秒杀场景的设计

参考[秒杀系统](../实际业务/业务系统.md#一秒杀系统)