# 一、问题排查案例

## 1、Docker上运行Java服务后发生OOM

详细描述：一个64g内存服务器，有一个总4g分配的docker运行Java服务，起始最大均为3g，服务器内不止运行一个服务，运行3个月后此Java服务发生OOM，给出至少6种可能情况，需要有具体场景（一共9种）

**（1）堆内存不足**
- Java 服务运行时，随着时间的推移，堆内存中的对象无法及时被 GC 回收，导致堆内存耗尽。堆中的对象包括常驻缓存、大型集合、或者存在内存泄漏；
- 例如，某个服务在内存中缓存了大量用户会话数据，但未及时清理无用的会话对象，导致堆内存逐渐耗尽；

**（2）非堆内存溢出（Metaspace）**
- Java 8 及以后的版本使用 Metaspace 存储类元数据。如果有大量类动态生成或者类加载器没有被正确卸载，Metaspace 的空间会耗尽。
- 例如，系统使用了某种动态代理框架（如 CGLIB 或 Hibernate），频繁生成新的类对象或动态加载类，但由于类加载器未正确回收，导致类占用了大量 Metaspace 空间

**（3）堆外内存泄漏**
- 一些 Java 应用通过 `ByteBuffer.allocateDirect()` 分配堆外内存（如网络传输和 NIO 操作），但没有正确释放内存，导致系统内存不足。
- 例如，某个 Java 应用使用 Netty 框架进行大量的网络 I/O 操作，频繁分配和使用 Direct ByteBuffer，但由于错误的内存管理（没有显式释放），导致堆外内存被耗尽

**（4）线程数过多导致的内存耗尽**
- 每个 Java 线程都会消耗一定的栈内存（默认 1MB）。如果服务中线程池管理不当或者使用大量并发线程（如未限制线程数量），会导致内存耗尽。
- 例如，一个服务使用了未正确配置的线程池或者创建了过多的并发任务，每个线程分配的栈内存累加，最终耗尽了内存。

**（5）GC 频率过高导致内存不足**
- Java 堆内存设置不合理或对象频繁创建，导致 GC 无法及时回收老年代内存，出现“GC thrashing”，即系统忙于垃圾回收而不能正常处理应用逻辑，最终导致 OOM。
- 例如，某个应用频繁创建短生命周期的对象，大量对象无法及时回收进入老年代，Full GC 持续占用 CPU 时间，最终导致服务无法正常工作并 OOM

**（6）内存泄漏**
- 应用程序中存在引用未释放、对象长时间保留在内存中或某些类缓存管理不当，导致对象无法被 GC 回收，逐渐耗尽堆内存。
- 例如，应用使用了缓存（如 LRU Cache）但未设定缓存大小上限，或使用静态变量持有大量引用，最终导致内存泄漏

**（7）Docker 容器内存限制导致 OOM**
- 容器的内存限制导致 JVM 无法获得足够的系统内存，即便堆内存设置为 3GB，其他内存开销（如栈内存、Metaspace、Direct Memory）也会导致总内存超出限制。
- 例如，某个 Java 应用的堆外内存和栈内存总和超出了 Docker 容器的 4GB 限制，尽管 JVM 堆内存没有耗尽，容器被 OOMKilled

**（8）操作系统层面内存不足**
- 服务器上运行了多个服务，所有服务的内存需求总和超出了 64GB 内存限制，操作系统为了回收内存，选择杀掉 Java 容器进程。
- 例如，服务器运行多个内存密集型服务，随着时间推移，内存使用持续增加，最终操作系统因为内存压力，杀掉了 Docker 中的 Java 服务

**（9）内存碎片化**
- Java 堆内存或 Direct Memory 中的内存碎片过多，导致应用需要大块连续内存时，虽然总内存还未耗尽，但无法获得足够的连续内存，触发 OOM。
- 例如，某个应用长期运行过程中，频繁的对象分配和释放导致内存碎片化，导致服务无法再分配大块内存

# 二、场景设计题

## 1、假如给你一个新产品，你将从哪些方面来保障它的质量？

### 1.1. **需求理解与沟通**
- **明确需求**：确保与产品经理、业务人员等充分沟通，明确产品的功能需求、边界条件和性能要求，避免误解导致功能错误或实现偏差。
- **功能文档**：建立详细的功能需求文档，列出核心功能、业务逻辑、用例和非功能性需求（如性能、可靠性等）。

### 1.2. **代码质量保障**
- **编码规范**：遵循标准的编码规范（如 Google Java Style Guide），确保代码清晰可读、可维护。可以使用工具如 Checkstyle 或 SonarLint 来自动化检查代码风格问题。
- **代码审查（Code Review）**：通过团队内部的代码审查，确保代码逻辑正确、实现方式合理、没有潜在的性能问题或安全漏洞。
- **单一职责原则**：采用面向对象设计原则（如 SOLID 原则），确保每个类和方法职责单一、模块化设计良好，增强代码的可维护性和扩展性。
- **重构**：定期对代码进行重构，消除重复代码、优化设计，确保代码质量随着项目规模增长仍能保持高水平。

### 1.3. **自动化测试**
- **单元测试**：为核心业务逻辑编写全面的单元测试，确保代码变更不会影响现有功能。常用的单元测试框架有 JUnit 和 TestNG。
- **测试覆盖率**：使用工具（如 JaCoCo）来监控测试覆盖率，确保关键逻辑部分有足够的测试覆盖。虽然 100% 的覆盖率不必要，但核心业务逻辑的覆盖率应尽可能高。
- **集成测试**：编写集成测试来验证不同模块间的交互是否正确，尤其是涉及数据库、第三方服务和外部API的部分。
- **UI 和端到端测试**：对于涉及用户界面的产品，可以使用 Selenium 或 Cypress 进行端到端测试，确保整个应用从用户输入到输出的流程无误。
- **Mock 测试**：对于依赖外部系统的部分（如数据库、第三方 API），使用 Mockito 或 WireMock 等工具进行 Mock 测试，避免外部依赖导致测试不稳定。

### 1.4. **持续集成和持续部署（CI/CD）**
- **自动化构建与测试**：集成 Jenkins、GitLab CI、Travis CI 等工具，确保每次代码提交后自动触发构建和测试，及时发现并解决问题。
- **自动化部署**：设置 CI/CD 流水线，将经过测试的代码自动部署到测试环境或生产环境，确保代码版本可控且发布过程一致。

### 1.5. **性能优化**
- **性能测试**：在开发过程中进行性能测试，使用工具如 JMeter 或 Gatling 模拟高并发负载，检测系统在大流量下的性能瓶颈。
- **内存与CPU分析**：使用 Profiling 工具（如 VisualVM、YourKit 或 Java Mission Control）分析应用的内存、CPU 和线程使用情况，排查内存泄漏、GC 问题或 CPU 占用过高等问题。
- **数据库优化**：确保 SQL 查询语句高效，避免全表扫描，适当地使用索引。对于数据库操作，可以引入缓存层（如 Redis）以减轻数据库负载。
- **线程池管理**：合理配置线程池的大小，避免线程池溢出或长时间阻塞，确保系统在高并发场景下也能保持响应能力。

### 1.6. **安全性**
- **输入验证**：确保对用户输入进行严格验证，防止 SQL 注入、跨站脚本攻击（XSS）等常见的安全漏洞。
- **身份认证和授权**：使用安全的身份验证机制（如 OAuth 2.0），确保用户访问控制的安全性。敏感信息的传输应使用 HTTPS。
- **加密数据**：敏感信息（如用户密码、支付信息等）需要加密存储，并确保安全传输（使用 SSL/TLS）。
- **安全扫描**：集成安全扫描工具（如 SonarQube、OWASP ZAP）到 CI/CD 流程，自动检测潜在的安全漏洞。

### 1.7. **日志和监控**
- **日志记录**：在应用中使用日志（如 Log4j、SLF4J）记录关键信息、错误和性能指标。确保日志级别分类合理，便于排查问题。
- **监控与告警**：集成监控系统（如 Prometheus、Grafana 或 ELK Stack），实时监控应用的健康状态、响应时间、内存/CPU 使用情况，及时发现异常。设置告警规则，一旦系统指标异常，自动通知相关人员。
- **可观测性**：引入分布式追踪系统（如 OpenTelemetry、Zipkin 或 Jaeger）来跟踪微服务之间的请求链路，分析延迟或瓶颈所在。

### 1.8. **用户反馈和异常处理**
- **用户反馈机制**：通过异常捕获（如全局异常处理器）以及用户反馈接口，及时收集用户在使用产品中的问题。将异常信息记录在日志中，确保开发团队能尽快修复问题。
- **健壮的异常处理**：确保系统对异常处理得当，使用 `try-catch` 和全局异常处理机制（如 Spring 的 `@ControllerAdvice`）来处理错误，避免程序崩溃。

### 1.9. **回归测试**
- **回归测试**：每次更新功能或修复 bug 后，进行全面的回归测试，确保新改动不会破坏现有功能。
- **版本控制与回滚**：确保每次部署都版本化，出现问题时能快速回滚到上一个稳定版本，减少对生产环境的影响。

### 1.10. **高可用与容灾**
- **高可用架构**：确保产品架构具有冗余设计，使用负载均衡、集群或多实例部署等方式，确保单点故障不会导致系统不可用。
- **备份与恢复**：设计良好的数据备份与恢复机制，确保出现故障或数据丢失时能够快速恢复数据。

### 总结

保障 Java 应用的产品质量需要从多个方面入手，包括需求理解、代码质量控制、自动化测试、持续集成、性能优化、安全性防护、日志监控等。通过构建稳健的开发和交付流程，及时发现和解决问题，确保产品的高质量和高可用性。

## 2、场景设计：底层存储

nosql、数据冗余

设计一个高性能的文件写入系统：
- 使用缓冲区（Buffer）来减少磁盘I/O操作的次数。
- 采用异步I/O或者多线程/多进程来并行处理文件写入，提高吞吐量。
- 使用内存映射（Memory-Mapped Files）技术，减少数据在用户空间和内核空间之间的拷贝。
- 选择合适的文件系统和存储介质，例如使用SSD代替HDD，或者使用高速的NVMe存储。
- 对文件系统进行适当的配置，比如调整文件系统的缓存策略或者关闭文件系统的某些特性（如atime更新）

## 3、mysql的同步方式

binlog 方案

## 4、对于订单系统，如何应对突发的读写流量

- 读写分离：提升 MySQL 并发的首选方案，因为当单台 MySQL 无法满足要求时，就只能用多个具有相同数据的 MySQL 实例组成的集群来承担大量的读写请求；
- MySQL主从架构：MySQL 做读写分离的前提，是把 MySQL 集群拆分成“主 + 从”结构的数据集群，这样才能实现程序上的读写分离，并且 MySQL 集群的主库、从库的数据是通过主从复制实现同步的；
- 对于读：可以缓存用户最近的订单数据，比如最近一周、最近10笔订单等等；

## 5、聊聊你印象最深刻的项目，或者做了什么优化

比如缓存数据库相关的，查询为空，你设置了一个-1到缓存，代表数据库没记录。下次判断-1，就不查库了，以解决缓存穿透问题。

又比如你设置缓存过期时间比较分散，解决缓存击穿问题，都可以条理清晰写到简历去，这样面试官很可能会问你相关的问题，这时候就对答如流啦。

还有平时你做的项目，有一些比较好的设计，都可以说一下哈，比如你是如何保证数据一致性的，怎么优化接口性能的。

如果是讲优化接口这一块的话，其实就是缓存、分批、并发调用、异步等那几个关键知识点。

如果是代码优化细节，你可以挑个简单的来讲，比如复杂的if逻辑条件，可以调整顺序，让程序更高效，这样会让面试官眼前一亮哦。

## 6、如果应用经常请求超时，如何解决这个问题？如何做代码预热

代码预热（Warm-up）是为了在系统启动时避免因 JIT（即时编译器）优化、类加载或资源初始化导致的性能波动。通过代码预热，确保系统在上线前已经经历过负载并准备好提供高效的服务

主要是体现JVM层面上的能力，以Dubbo为例：

Dubbo 服务预热功能的核心代码：`org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance#calculateWarmupWeight`

[Dubbo预热方式](https://juejin.cn/post/7134547114725965838)

JVM预热参考文档：[JVM预热](../Java/Java虚拟机/JVM-Java虚拟机.md#16JVM预热)

解决请求超时：需要通过性能分析工具找到瓶颈，优化数据库、线程池、缓存、异步处理等方面，并为不同的服务和操作设置合理的超时策略。

代码预热：包括 JIT 编译预热、类加载预热、资源预加载、以及使用模拟请求或自动化脚本来模拟实际负载，确保系统在实际使用前已经准备好最佳性能状态

## 7、如果用redis来实现抢红包，比如10个红包，大家并发来抢，使用什么数据结构最合适

## 8、设计一个全局微观有序的发号机

## 9、场景题：设计一个抢红包系统

参考[红包业务](../实际业务/业务系统.md#十八红包业务)

## 10、场景题：设计一个im系统包括群聊单聊

## 11、场景题：设计数据库连接池

参考[池化技术设计](../软件工程/软件设计/设计案例.md#二池化技术设计)

## 12、场景题：秒杀场景的设计

参考[秒杀系统](../实际业务/业务系统.md#一秒杀系统)