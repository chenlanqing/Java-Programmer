# 一、密码学

## 1、非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？ 
- 加密场景，那么肯定希望只有我才能解密，别人只能加密。即公钥加密，私钥解密。 
- 签名场景，既然是签名，就希望只能我才能签名，别人只能验证。即私钥签名，公钥验签

## 2、什么是数字签名，数字签名的作用是什么？ 

数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。 可以起到防篡改、防伪装、防否认的作用。 

## 3、为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？ 

数据可能比较大，签名是使用非对称加密算法，比较耗时防止第三方使用公钥解开签名后，拿到原始数据

## 4、什么是数字证书，数字证书存在解决了什么问题？ 

数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。 数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。

# 二、关于面试官

# 三、CodeReview问题

以下问题来自公众号[Qunar技术沙龙]，详细解答可以参考：[33个Bug](https://mp.weixin.qq.com/s/pnttvMX5MRCFPt3pYUGeGw)

## 1、数据库插入

业务背景：写压测 case 生成，简单来说就是一个插入数据库的操作，将参数中的 caseList 入库。
```java
public boolean batchInsert(List<Case> cazeList) {
    boolean result = false;
    Long start = System.currentTimeMillis();
    try {
        result = caseMapper.batchInsert(cazeList.get(0).getSceneId(), cazeList) == cazeList.size();
    } catch (Exception exp) {
        if (exp.getMessage() != null && exp.getMessage().contains("doesn't exist")) {
            caseMapper.createTable(cazeList.get(0).getSceneId());
            caseMapper.addIndex(cazeList.get(0).getSceneId());
            QMonitor.recordOne("db.case.createTable.success");
            result = caseMapper.batchInsert(cazeList.get(0).getSceneId(), cazeList) ==  cazeList.size();
        }
        log.warn(exp.getMessage() != null ? exp.getMessage() : "", exp);
    }
    if (result) {
        log.info("sceneId_{}_groupId_{}： 批量入库（batchInsert）count:{} ， 成功", 
        cazeList.get(0).getSceneId(), cazeList.get(0).getGroupId(), cazeList.size());
        QMonitor.recordOne("db.case.batchInsert.success", System.currentTimeMillis() - start);
    } else {
        log.info("sceneId_{}_groupId_{}： 批量入库（batchInsert）count:{} ， 失败", 
        cazeList.get(0).getSceneId(), cazeList.get(0).getGroupId(), cazeList.size());
        QMonitor.recordOne("db.case.batchInsert.failed", System.currentTimeMillis() - start);
    }
    return result;
}
```

## 2、事务问题

```java
public class SyncCreateT6OrderService
    protected void doRetry(SyncCreateOrderRequest syncCreateOrderRequest) {
        try {
            createT6OrderFromSyncOrder(syncCreateOrderRequest);
        } catch (Exception e) {
            // 此处省略一些异常处理细节，监控、日志等
            throw e; 
        }
    }
    @Transactional(rollbackFor = RuntimeException.class)
    private void createT6OrderFromSyncOrder(SyncCreateOrderRequest syncCreateOrderRequest) {
        ....
    }
}
```

