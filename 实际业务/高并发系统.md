

# 一、读多写少

读多写少的这类系统通过缓存能获得很好的性能提升；

## 1、梳理表结构

梳理数据库结构，再对系统进行高并发改造是很有帮助的。

**精简数据会有更好的性能**

长度小的数据在吞吐、查询、传输上都会很快，也会更好管理和缓存；

精简数据量虽然能换来更好的响应速度，但不提倡过度设计。因为表字段如果缺少冗余会导致业务实现更为繁琐；

有些查询往往会因为精简一两个字段就多查一次数据库，并且还要考虑缓存同步问题，得不偿失，因此我们要在`更多的字段`和`更少的职能`之间找到平衡；

**数据的归类及深入整理**

可以针对不同类型的表做不同方向的缓存优化；

一般来说，数据可分为四类：实体表、实体辅助表、关系表和历史表，而判断是否适合缓存的核心思路主要是以下几点：
- 能够通过 ID 快速匹配的实体，以及通过关系快速查询的数据，适合放在长期缓存当中；
- 通过组合条件筛选统计的数据，也可以放到临时缓存，但是更新有延迟；
- 数据增长量大或者跟设计初衷不一样的表数据，这种不适合、也不建议去做做缓存；

## 2、缓存一致性

- [分布式缓存-缓存一致性](../Java/分布式架构/分布式.md#六分布式缓存)

做缓存是要考虑性价比的，如果费时费力地把一些数据放到缓存当中，但并不能提高系统的性能，反倒浪费了大量的时间和金钱，那是不合适的。需要评估缓存是否有效，一般来说，只有热点数据放到缓存才更有价值；、

要从数据量、使用频率、缓存命中率三个角度去分析；

读多写少的数据做缓存虽然能降低数据层的压力，但要根据一致性需求对其缓存的数据做更新。其中，单条实体数据最容易实现缓存更新，但是有条件查询的统计结果并不容易做到实时更新

临时缓存+长期热点缓存解决思路
```go
// 尝试从缓存中直接获取用户信息
userinfo, err := Redis.Get("user_info_9527")
if err != nil {
  return nil, err
}
//缓存命中找到，直接返回用户信息
if userinfo != nil {
  return userinfo, nil
}
//set 检测当前是否是热数据
//之所以没有使用Bloom Filter是因为有概率碰撞不准
//如果key数量超过千个，建议还是用Bloom Filter
//这个判断也可以放在业务逻辑代码中，用配置同步做
isHotKey, err := Redis.SISMEMBER("hot_key", "user_info_9527")
if err != nil {
  return nil, err
}

//如果是热key
if isHotKey {
  //没有找到就认为数据不存在
  //可能是被删除了
  return "", nil
}
//没有命中缓存，并且没被标注是热点，被认为是临时缓存，那么从数据库中获取
//设置更新锁set user_info_9527_lock nx ex 5
//防止多个线程同时并发查询数据库导致数据库压力过大
lock, err := Redis.Set("user_info_9527_lock", "1", "nx", 5)
if !lock {
  //没抢到锁的直接等待1秒 然后再拿一次结果，类似singleflight实现
  //行业常见缓存服务，读并发能力很强，但写并发能力并不好
  //过高的并行刷新会刷沉缓存
  time.sleep( time.second)
  //等1秒后拿数据，这个数据是抢到锁的请求填入的
  //通过这个方式降低数据库压力
  userinfo, err := Redis.Get("user_info_9527")
  if err != nil {
    return nil, err
  }
  return userinfo,nil
}
//拿到锁的查数据库，然后填入缓存
userinfo, err := userInfoModel.GetUserInfoById(9527)
if err != nil {
  return nil, err
}
//查找到用户信息
if userinfo != nil {
  //将用户信息缓存，并设置TTL超时时间让其60秒后失效
  Redis.Set("user_info_9527", userinfo, 60)
  return userinfo, nil
}
// 没有找到，放一个空数据进去，短期内不再问数据库
Redis.Set("user_info_9527", "", 30)
return nil, nil
```
长期缓存需要特别注意缓存穿透问题；

# 二、强一致性

一般来说，强一致性的系统都会牵扯到“锁争抢”等技术点，有较大的性能瓶颈


# 三、写多读少


# 四、读多写多

