## 1、单向散列函数

单向散列函数是密码学的基础。

### 1.1、单向函数

单向函数（One-way Function）是正向计算容易，逆向运算困难的函数。也就是说，给定你一个输入，你很容易计算出输出；但是给定你一个输出，你却很难计算出输入是什么。

在数学领域，有很多函数看起来像是严格的单向函数，我们既证明不了它是单向函数，也暂时找不到逆向运算的办法。到底有没有逆向运算的办法，我们现在还不知道
- 一个更实用的单向函数，正向计算会更容易，容易程度就是这个函数的计算性能；
- 一个更实用的单向函数，逆向运算会更困难，困难程度就是这个函数的破解强度。

### 1.2、散列函数

散列函数（Hash Function）是一个可以把任意大小的数据，转行成固定长度的数据的函数。

把转换后的数据，叫做**散列值**。因为散列函数经常被人们直译为哈希函数，所以我们也可以称散列值为哈希值。通常的，对于给定的输入数据和散列函数，散列值是确定不变的。

**存在的问题**：既然输入数据的大小没有限制，而输出结果的数据长度固定，那么会不会存在散列值相同的两个或者多个数据呢？——是确定存在的，通常把这种情况称为**散列值碰撞**，即**哈希碰撞**

**如何避免碰撞**：
- 可以让数据变得更长，散列值越长，存在相同散列值的概率就越小，发生碰撞的可能性就越小。但从另一个角度来说，散列值越长，通常也就意味着计算越困难，计算性能越差。

### 1.3、单向散列函数

单向散列函数既是一个单向函数，也是一个散列函数。它不仅要满足单向函数的要求，还要满足散列函数的要求；

**雪崩效应**（Avalanche Effect）是密码学算法一个常见的特点，指的是输入数据的微小变换，就会导致输出数据的巨大变化。严格雪崩效应是雪崩效应的一个形式化指标，也
常用来衡量均匀分布。**严格雪崩效应**指的是，如果输入数据的一位反转，输出数据的每一位都有 50% 的概率会发生变化。

一个适用于密码学的单向散列函数，就要具有雪崩效应的特点，也就是说，如果一个单向散列函数具有雪崩效应，那么对于给定的数据，构造出一个新的、具有相同散列值的数据是困难的

### 1.4、完整性问题

如何解决完整性问题呢？完整性意味着什么？完整性的核心是**数据未经授权，不得更改**，如果数据有变动，能够被检测出来，就不采纳被篡改的数据。使用单向散列函数，就可以通过检查数据是否有变动，来解决数据完整性问题。

单向函数和散列函数的组合，单向散列函数，就可以帮助我们解决完整性问题；

假如我们收到了一段数据，我们就可以重新计算这段数据的散列值。如果我们还可以获得数据发送者计算的散列值，我们就可以对比新计算的散列值和接收到的散列值。如果两个散列值是相同的，我们就可以认为这段数据是完整的；否则，这段数据就是被篡改过的


### 1.5、常见单向散列函数算法

常见算法有:
- MD5
- SHA1
- SHA256
- SHA512

比如MD5实现参考：[MD5Utils.java](../Java/代码片段/source/DigestUtils.java)

一个应用程序，一般而言，应该选用现行的、流行的算法。现行推荐的算法，保证了算法的安全性。流行的算法，成熟的实现会考虑实现优化，包括 CPU 扩展指令的支持。选用流行的算法，也是获得较好计算性能的一个实践办法。
- SHA-256
- SHA-384
- SHA-512

### 1.6、长度延展攻击

假设我们有两段数据，S 和 M，以及一个单向散列函数 h。如果我们要把这两段数据合并起来，并且还要计算合并后的散列值，这就叫做单向散列函数的长度延展。

如果 S 和 M 都是公开的信息，顺序是不重要的。可如果 S 是机密信息，M 是公开信息，这两段数据的排列顺序就至关重要了。如果机密信息放在了前面，就存在“长度延展攻击”的风险。

可以利用已知数据的散列值，计算原数据外加一段延展数据后的散列值。也就是说，如果我们知道了 h(S|M)，我们就可以计算 h(S|M|N)。其中，数据 N 就是原数据追加的延展数据

**如何避免**：不要单纯使用单向散列函数来处理既包含机密信息、又包含公开信息的数据，如果需要使用机密数据产生数据的签名，应该使用设计好的、经过验证的算法，比如消息验证码（Message Authentication Code）和基于单向散列函数的消息验证码（Hash-based Message Authentication Code）

### 1.7、适用场景

典型的使用单向散列函数的场景：
- 校验数据完整性；
- 数字签名，和非对称密钥及其算法结合使用；
- 消息验证码，和对称密钥及其算法结合使用；
- 生成伪随机数；
- 生成对称密钥。

### 1.8、Base64编码

Base64是网络上最常见的用于传输8Bit字节码的可读性编码算法之一，该算法不是为了保护数据的安全性，而是为了可读性。可读性编码不改变信息内容，只改变信息内容的表现形式，所谓 Base64，即是说在编码过程中使用了64种字符，大写A到Z、小写a到z、数字0到9、“+”和“/”。Base58是Bitcoin（比特币）中使用的一种编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"i"，以及"+"和"/"符号；

base64原理：base64 是 3个字节为一组，一个字节 8位，一共 就是24位 ，然后，把3个字节转成4组，每组6位；$3 * 8 = 4 * 6 = 24$ ，每组6位，缺少的2位，会在高位进行补0 ，这样做的好处在于 ，base取的是后面6位，去掉高2位 ，那么base64的取值就可以控制在0-63位了，所以就叫base64，$111 111 = 32 + 16 + 8 + 4 + 2 + 1$ 

base64有个 `=` 号，但是在映射表里面没有发现 `=` 号 ， 这个地方需要注意，等号非常特殊，因为base64是三个字节一组 ，如果当我们的位数不够的时候，会使用等号来补齐：

## 2、对称加密

### 2.1、基本概念

一般来说，加密产生的那个难以解释的信息或者数据，我们把它叫做密文（Ciphertext）。对应的，加密前的数据，我们通常把它叫做明文（Plaintext）。

密钥是在加密和解密运算里，决定运算结果的一段信息。加密要使用密钥把明文信息转换为密文；解密要使用密钥把密文复原为明文。

现代密码学，加密数据的安全性依赖于 **加密算法的质量** 和 **密钥的保密性** 这两个因素。**密钥部分，是私有的部分，需要严格保密**；算法部分，变成了公开的部分，要接受公开讨论、评测，接受各种分析和攻击。**一个算法，如果在接受了公开的分析、评测和各种各样的攻击之后，还依然被认为是安全的，我们才能说，这个算法的安全性是真的经得起考验的**

密码分析，指的是分析、评测一个密码学算法，有没有安全缺陷和适用场景的限制。如果一个算法，没有人对它展开分析、评测，或者缺少足够的分析，它的安全性很难获得信任

对称密钥，顾名思义，就是每一个参与者都持有相同的密钥，使用相同的密钥。采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密

### 2.2、加密算法

常见的对称加密算法主要有 `DES`、`3DES`、`AES`、[Chacha20](https://en.wikipedia.org/wiki/ChaCha20-Poly1305)

加密算法分为序列算法与分组算法：
- 进行数据分组，然后按数据组运算，这就是**分组算法**；
- 不进行数据分组，按照原始数据的大小进行运算，这就是**序列算法**

#### 2.2.1、序列算法

-序列算法的基本思路，就是从对称密钥里推导出一段和明文数据相同长度的密钥序列，然后密钥序列和明文进行亦或运算得到密文，和密文进行异或运算得到明文；序列算法的关键，是怎么从固定长度的对称密钥推导出参与运算的任意长度的密钥序列。一般来说，密钥序列的推导和异或运算都是快速的运算。所以，序列算法通常被认为是更高效的算法。序列算法的安全性主要取决于**密钥序列的推导算法**

ChaCha20 算法就是序列算法，在类似的条件下，相同安全强度的对称密钥，ChaCha20 算法要比 AES 算法快四到六倍，比 Camellia 算法快近十倍；ChaCha20 是现代主流浏览器优先选择的加密算法

对比序列算法，按照良好性能，考虑安全强度，对称密钥算法优先级： ChaCha20 > AES-256 > AES-128

#### 2.2.2、分组算法

分组算法要对输入数据进行分组，然后按数据分组来进行运算。一个典型的分组算法，一般要由三个部分组成，数据分组、分组运算和链接模式
- 数据分组在加密时，会把明文的输入数据分割成加密函数能够处理的数据块。比如，AES算法能够处理的数据块大小是 128 位，那么，输入数据就要被分割成一个或者多个 128 位的小数据块。如果不能整分，就要把最后一个分组补齐成 128 位。这些分组数据的运算结果，组合起来就是密文数据。解密时，执行相反的操作，把补齐数据去掉，再把数据分组组合成完整的明文数据。
- 分组运算，意思就是把每一个明文数据分组通过加密函数，转换成密文数据分组
- 链接模式，指的是如何把上一个分组运算和下一个分组运算联系起来。

第一个分组运算并没有上一个分组运算可以使用，这时候，我们就需要引入一个初始化的数据，来承担“上一个分组运算”向下链接的功能。这个初始化的数据，我们一般称为**初始化向量**。

*影响分组算法安全性的因素：*
- 加密函数和解密函数：如果加密函数不安全，整个分组算法的安全性也就坍塌了；
- 密钥：如果密钥没有做好保密或者密钥质量不好，数据的保密性也就无从谈起
- 初始化向量：如果一个加密运算缺失初始化向量，相同的明文分组就会被加密成相同的密文分组
- 链接模式：链接模式的缺失，会让每一个分组运算都是独立的，密文数据当然也会是独立的，那么就可以重新编排数据，修改密文解密结果，实现`分组重放`
- 数据补齐方案。

**初始化向量：**

第一个数据块和初始化向量关系紧密。第一个数据块的计算，它的输入信息包括：密钥、初始化向量、第一个明文数据分组；如果能够确定这些输入信息，那么输出的第一个密文数据分组也就确定了；

一般来说，一个对称密钥要使用多次，对多个明文数据进行加密运算。如果存在第一个明文数据分组相同的两段数据，并且使用了相同的初始化向量，那么第一个密文数据分组就是相同的。也就是说，相同的输入，就会有相同的输出。

*在一个对称密钥的生命周期里，初始化向量不能重复，这是使用对称密钥算法的第一个要求。* 如何保证不重复，可以从下面两个方面考虑：
- 使用安全强度足够的随机数作为初始化向量；
- 使用序列数，下一次的初始化向量的数值，比上一次的数字自动加一或者自动减一；

JDK 中的 Cipher 中有使用AES和DES的方法，在线文档地址如下： [Cipher.java](https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html)

### 2.3、加密模式

有ECB和CBC两种

[ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB) : Electronic codebook, 电子密码本. 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密：
- 优点 : 可以并行处理数据
- 缺点 : 同样的原文生成同样的密文, 不能很好的保护数据
- 同时加密，原文是一样的，加密出来的密文也是一样的
- 不应该在一般的应用程序使用 ECB 模式，因为其存在安全缺陷，尤其是数据重放攻击

[CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)) : Cipher-block chaining, 密码块链接. 每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块，包括初始化向量
- 优点 : 同样的原文生成的密文不一样
- 缺点 : 串行处理数据.
- CBC 解决了 ECB 的数据重放攻击问题

加密过程的初始化向量和解密过程的初始化向量必须是一样的，否则，我们就没有办法得到第一个明文分组；

初始化向量只影响第一个明文分组，并不影响后续的解密过程和明文分组，一个密文分组，只影响它的下一个明文分组，并不影响更后面的解密过程和明文分组。

关于**异或运算**：相同的数据归零，不同的数据归一。
- 归零律：如果两段数据完全相同，它们的异或运算结果，就是每一位都是零的数据；
- 恒等律：如果一段数据和一段全是零的数据进行异或运算，前一段数据中是零的位运算后还是零，是一的位运算后还是一。也就是说，和零进行异或运算，不改变原数据的数值

正是异或运算的归零律和恒等律，CBC 模式才能成立，解密才能进行。这两个性质，还使得解密运算和加密运算具有相同的运算效率。然而，CBC 模式的主要安全问题，也来源于异或运算的这两个性质

### 2.4、填充模式

当需要按块处理的数据, 数据长度不符合块处理需求时，按照一定的方法填充满块长的规则。    
- *NoPadding：*不填充.
    - 在DES加密算法下, 要求原文长度必须是8byte的整数倍
    - 在AES加密算法下, 要求原文长度必须是16byte的整数倍
- *PKCS5Padding：*数据块的大小为8位, 不够就补足

默认情况下, 加密模式和填充模式为 : `ECB/PKCS5Padding`。如果使用CBC模式, 在初始化Cipher对象时, 需要增加参数, 初始化向量IV :
```java
IvParameterSpec iv = new IvParameterSpec(key.getBytes());
```
加密模式和填充模式有：
```
AES/CBC/NoPadding (128)
AES/CBC/PKCS5Padding (128)
AES/ECB/NoPadding (128)
AES/ECB/PKCS5Padding (128)
DES/CBC/NoPadding (56)
DES/CBC/PKCS5Padding (56)
DES/ECB/NoPadding (56)
DES/ECB/PKCS5Padding (56)
DESede/CBC/NoPadding (168)
DESede/CBC/PKCS5Padding (168)
DESede/ECB/NoPadding (168)
DESede/ECB/PKCS5Padding (168)
RSA/ECB/PKCS1Padding (1024, 2048)
RSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)
RSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)
```
默认情况下，如果没有写填充模式和加密模式，那么默认就使用`DES/ECB/PKCS5Padding`

### 2.5、[消息验证码](https://en.wikipedia.org/wiki/Message_authentication_code)

防止数据被掉包，即如何验证这段数据的有效性

**怎样有效地验证一段信息？**
- 第一个条件就是，**我们要有额外的信息**。只有要验证的信息本身，是没有办法验证这个信息的。也就是说，信息本身不能自己验证自己。这个额外的信息，暂且称之为验证信息；
- 第二个条件就是，**验证信息和待验证的消息之间要有关联**。如果没有关联，也就意味着如果我们替换掉待验证的信息，验证信息并不受影响，这显然起不到验证的作用；
- 第三个条件，就是**验证信息的计算要快，数据要小**。

有同时满足上述三个条件的一个方案吗？**消息验证码（Message AuthenticationCode, MAC）**就是最常用的满足上述三个条件的一个方案

**消息验证码如何工作？**
- 使用消息验证码的前提，就是信息的发送方和接收方要持有相同的密钥，能够使用对称密钥的场景，都能够满足这个前提。
- 信息的发送方和接收方要使用相同的消息验证函数。这个函数的输入数据就是对称密钥和待验证信息。信息的发送方使用消息验证函数，可以生成消息验证码；
- 信息发送方把待验证信息和消息验证码都发送给信息接收方。信息接收方使用相同的消息验证函数和对称密钥，以及接收到的待验证信息，生成消息验证码。
- 然后，信息接收方对比接收到的消息验证码和自己生成的消息验证码。如果两个消息验证码是一样的，就表明待验证信息不是伪造的信息。否则，待验证信息就是被篡改过的信息

通常的对称密钥算法，并不能当做消息验证函数使用

**如何选择消息验证函数**

最常见的方案就是[基于单向散列函数的消息验证码（Hash-based Message Authentication Code，HMAC）](https://en.wikipedia.org/wiki/HMAC)，通常使用它的简称 HMAC。在 HMAC 的算法里，单向散列函数的输入数据是由对称密钥和待验证消息构造出来的

**为什么需要对称密钥**

如果对称密钥参与了消息验证码的运算，由于中间攻击者并不知道对称密钥的数据，攻击者就很难伪造出一个能够通过验证的消息验证码。换一个说法，对称密钥的参与，是为了确保散列值来源于原始数据，而不是篡改的数据。

**怎么计算 HMAC 算法的强度**

HMAC 算法与对称密钥和单向散列函数息息相关，所以，对称密钥的安全强度和单向散列函数的安全强度，都会影响 HMAC 算法的安全强度。该怎么计算 HMAC 算法的安全强度
呢
对于流行的 HMAC 算法，我们只需要考虑对称密钥的安全强度。

**常见的 HMAC 算法**：HmacSHA256 和 HmacSHA384 是目前最流行的两个 HMAC 算法

### 2.6、使用HMAC构造可认证加密方案

分别是加密并验证、加密后验证以及验证后加密。其中，加密并验证以及验证后加密这两种方案存在安全缺陷；加密后验证是一个更安全的方案

**加密并验证**：第一种方案，就是加密明文数据，计算明文数据的消息验证码，输出密文数据和验证码。这种方案，简称为加密并验证。安全外壳协议（SSH）就是采用加密并验证的方案

这个方案的消息验证码，保护的是明文信息的完整性，而不是密文信息的完整性。如果明文信息相同，它的消息验证码也是相同的。从攻击者的角度看，如果发现两个相同的消息验证码，就可以猜测明文信息大概率是相同的

**加密后验证**：第二种方案，加密明文数据，计算加密数据的消息验证码，输出密文数据和验证码。这种方案，简称为加密后验证。IPSec 协议采用的就是加密后验证的方案。

这个方案的消息验证码，保护的是密文信息的完整性，而不是明文信息的完整性。由于密文是从明文演算过来的，也就间接地保护了明文的完整性。
另外，只要加密算法不把相同的明文信息加密成相同的密文信息，它的消息验证码也就是不同的。所以，这个方案没有上面的加密并验证方案的安全问题

**验证后加密**：第三种方案，则是计算明文数据的消息验证码，加密明文数据和验证码，输出密文数据。这种方案，简称为验证后加密。SSL 协议采用的就是验证后加密的方案

这个方案的消息验证码，保护的是明文信息的完整性，而不是密文信息的完整性。

**选用哪个方案**：如果我们只能从上述三个方案中间选择，加密后验证这个方案目前来说，是最安全的方案

### 2.7、带关联数据的加密

在解决公开信息的完整性问题的同时，一般的算法设计也会同时解决掉私密信息的完整性问题。所以，这一类算法，通常也叫做带关联的认证加密（Authenticated Encryption with Associated Data（AEAD））。

带关联的认证加密的加密函数需要三个输入数据：
- 加密密钥；
- 明文信息；
- 关联信息

输出结果包含两段信息：
- 密文信息；
- 验证标签

一般来说，验证标签可以看做是密文信息的一部分，需要和密文信息一起传输给信息接收方。

如果改变明文信息，密文信息和验证标签都会变化，这一点，就解决了明文信息的验证问题。如果改变关联信息，至少验证标签会不一样，这一点，解决了关联信息的验证问题。
对应地，带关联的认证加密的解密函数需要四个输入数据：
- 加密密钥；
- 明文信息；
- 关联信息。
- 密文信息；
- 验证标签。

而输出的是明文信息。在解密过程中，如果密文信息或者关联信息验证失败，明文信息不会输出。

## 3、非对称加密

- [Public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)
- [加密与解密算法](https://juejin.cn/post/6844903638117122056)

### 3.1、基础概念

非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。与对称加密算法不同，非对称加密算法需要两个密钥公开密钥(publickey)和私有密(privatekey)，公开密钥和私有密钥是一对：
- 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密
- 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密

因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法

- 加密：公钥加密，私钥解密的过程，称为「加密」<br/>
    因为公钥是公开的，任何公钥持有者都可以将想要发送给私钥持有者的信息进行加密后发送，而这个信息只有私钥持有者才能解密。
- 签名：私钥加密，公钥解密的过程，称为「签名」<br/>
    它和加密有什么区别呢？因为公钥是公开的，所以任何持有公钥的人都能解密私钥加密过的密文，所以这个过程并不能保证消息的安全性，但是它却能保证消息来源的准确性和不可否认性，也就是说，如果使用公钥能正常解密某一个密文，那么就能证明这段密文一定是由私钥持有者发布的，而不是其他第三方发布的，并且私钥持有者不能否认他曾经发布过该消息。故此将该过程称为「签名」

常见的 **非对称算法** 主要有 `RSA`、`DSA` 等

### 3.2、RSA加密算法

- [Wikipedia-RSA (cryptosystem)](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
- [Hutool-非对称加密算法](https://doc.hutool.cn/pages/AsymmetricCrypto/#ecies)

RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个相同的算法，但他的发现被列入机密，一直到1997年才被发表。

对极大整数做因数分解的难度决定了RSA算法的可靠性。 换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。 但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。

具体实现参考：[RSAUtils.java](../Java/代码片段/source/RSAUtils.java)

## 4、数字签名

## 5、bcrypt加密

- [bcrypt](https://en.wikipedia.org/wiki/Bcrypt)
- [Spring Security-BCryptPasswordEncoder]()

bcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。bcrypt 使用的是布鲁斯·施内尔在1993年发布的 Blowfish 加密算法。具体来说，bcrypt 使用保罗·柯切尔的算法实现

Java中使用bcrypt，可以使用 spring security：
```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

## 6、国密

- [国密算法标准文档](https://github.com/chenlanqing/GM-Standards)
- [支持国密SM2/SM3/SM4/SM9/ZUC/SSL的密码工具箱](http://gmssl.org/)
- [支持国密的密码工具箱](https://github.com/guanzhi/GmSSL)
- [Hutool-国密加密实现](https://doc.hutool.cn/pages/SmUtil/#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86sm4)

国密算法是国家商用密码算法的简称，由国家密码管理局管理和发布标准


## AI 与密码

- [使用自然语言处理和人工智能以及一些全自动解密/解码/破解工具](https://github.com/bee-san/Ares)-https://github.com/bee-san/Ciphey

## 参考资料

- [写给开发人员的密码学](https://thiscute.world/posts/practical-cryptography-basics-1/)
- [密码学简介](https://ctf-wiki.org/crypto/introduction/)
- [RSA加密算法原理](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)
- [深入浅出密码学](https://paper.bobylive.com/Science/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B.pdf)
- 国密算法
