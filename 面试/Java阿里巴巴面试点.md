#### 1.Java 的四个基本特性(抽象、封装、继承、多态),对多态的理解(多态的的实现方式)以及在项目中哪些地方使用多态?
	1.1.Java 的四个基本特性:
		(1).抽象:抽象是将一类对象的共同特征总结出来构造类的过程,包括数据抽象和行为抽象两方面.抽象只关注对象的有哪些属性和行为,
			并不关注这些行为的细节是什么.
		(2).继承:继承是从已有类中得到继承信息并创建新类的过程.提供继承信息的类被称为父类;得到继承信息的类被称为子类.
			继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的重要手段;
		(3).封装:通常认为封装是把数据和操作数据的方法绑定起来,对数据的访问只能通过已定义的接口;面向对象的本质就是:将现实世界
			描绘成一系列完全自然、封闭的对象.在类中的编写的方法就是对实现细节的一种封装;编写一个类就是对数据和数据操作的封装;
			可以说封装就是隐藏一切可以隐藏的东西,只向外界提供最简单的编程接口;
		(4).多态:指允许不同子类型的对象对同一消息作出不同的响应;
	1.2.多态:
		(1).方法重载:实现是编译时多态
		(2).方法重写:实现是运行时多态
			用父类型引用子类的子类型对象,同样的引用调用同样的方法会根据子类对象的不同而表现出不同的行为;
	1.3.多态的使用:
		工厂模式

#### 2.面向对象和面向过程的区别:
	/**
	 * 参考:http://www.cnblogs.com/fuleying/archive/2011/08/09/2131647.html
	 */
	(1).面向过程需要考虑整个过程的实现,面向对象只需要知道其工作原理;
	(2).面向过程是一种以事件为中心的编程思想,就是分析出解决问题所需的步骤,然后用函数把这些步骤实现并按顺序调用;
		面向对象是以对象为中心的编程思想;
	(3).简单的举个例子:汽车发动、汽车到站
        这对于“面向过程”来说,是两个事件,汽车启动是一个事件,汽车到站是另一个事件,面向过程编程的过程中我们关心的是事件,
		而不是汽车本身.针对上述两个事件,形成两个函数,之后依次调用;
		然而这对于面向对象来说,我们关心的是汽车这类对象,两个事件只是这类对象所具有的行为.而且对于这两个行为的顺序没有强制要求
	(4).面向过程就是分析出解决问题所需的步骤;面向对象则是把构成问题的事物分解成对象,抽象出对象的目的并不在于完成某个步骤,
		而是描述其再整个解决问题的步骤中的行为;
	(5).面向过程的思维方式是分析综合,面向对象的思维方式是构造;
	(6).对比 蛋炒饭 和 盖浇饭	

#### 3.面向对象开发的基本原则?如何使用这些原则?迪米特法则?
	3.1.五大基本原则:(S.O.L.I.D)
		(1).单一职责:The Single Responsibility Principle:
			一个类只做它该做的事情.在面向对象中,如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚原则
		(2).开放闭合原则:The Open Closed Principle
			对扩展开放,对修改封闭.抽象是关键:
			①.对扩展开放,意味着有新的需求或变化时,可以对现有代码进行扩展,以适应新的情况
			②.对修改封闭,意味着类一旦设计完成,就可以独立完成其工作,而不要对其进行任何尝试的修改
		(3).里氏替换:The Liskov Substitution Principle
			任何时候子类都可以替换掉父类型.子类一定是增加父类的行为.
		(4).依赖倒置:The Dependency Inversion Principle
			具体而言就是高层模块不依赖于底层模块,二者都同依赖于抽象;抽象不依赖于具体,具体依赖于抽象;
		(5).接口隔离:The Interface Segregation Principle
			使用多个小的专门的接口,而不要使用一个大的总接口
		(6).合成聚合复用:尽可能多的使用合成聚合,少用继承
	3.2.迪米特法则:一个对象应该对其他对象有尽可能少的了解
		(1).狭义的迪米特法则:
			如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用;
			如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用
		(2).广义的迪米特法则:
			对对象之间的信息流量、流向以及信息的影响进行控制
			充分体现封装的概念
			具体应用时,需注意
		
#### 4. static 和 final 的区别和用途:
	4.1.static:
		修饰变量:静态变量是随着类加载时完成初始化,内存中只有一个,且JVM只会为它分配一次内存,所有类共享静态变量;
		修饰方法:在类加载的时候就存在,不依赖任何实例;static 方法必须实现,不能使用 abstract 修饰;
		静态代码块:在类加载完之后就会执行代码块的内容
		父类静态代码块->子类静态代码块->父类非静态代码块->父类构造方法->子类非静态代码块->子类构造方法
	4.2.final:

#### 5.HashMap 和 HashTable 的区别? HashMap 中key可以是任何对象和数据类型吗?线程安全性呢?
	5.1.区别:
		(1).HashTable 使用 Enumeration, HashMap 使用 Iterator;
		(2).哈希值使用不同, HashTable 直接使用对象的 hashcode;而 HashMap 重写计算hash值,而且用于代替求模;
		(3).HashTable 中 hash数组默认大小是11,增加方式是 old*2+1.HashMap 中hash数组的默认大小是16,而且一定是2的指数;
		(4).HashTable 是基于 Dictionary 类,而 HashMap 是基于 AbstractMap
	5.2.可以是 null 类型,但不能是可变对象,如果是可变对象,当对象内的属性改变时,会重新计算 hashcode,导致无法查找对应的值

#### 6.HashMap 和 ConcurrentHashMap? ConcurrentHashMap 如何保证线程安全
	6.1.区别:
		(1).HashMap 不是线程安全的,ConcurrentHashMap 是线程安全的
		(2).ConcurrentHashMap 将整个 Hash 桶进行了分段 Segment,也就是将这个大的数组分成了几个 Segment,而且每个小的片段
			Segment 上面都有锁存在,那么在插入元素的时候需要找到应该插入哪一个片段 Segment,然后在这个片段上进行插入,
			而且这里需要获取 Segment 锁
	6.2.ConcurrentHashMap 如何保证线程安全:	(散列算法,链表数据结构)	
		// 参考:http://www.infoq.com/cn/articles/ConcurrentHashMap
		// https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/
		(1).HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁;
			那假如容器里有多把锁,每一把锁用于锁容器其中一部分数据,那么当多线程访问容器里不同数据段的数据时,线程间就
			不会存在锁竞争,从而可以有效的提高并发访问效率,这就是 ConcurrentHashMap 所使用的锁分段技术,首先将数据分成
			一段一段的存储,然后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问;
		(2).get操作的高效之处在于整个get过程不需要加锁,除非读到的值是空的才会加锁重读,
			它的get方法里将要使用的共享变量都定义成volatile,如用于统计当前 Segement 大小的count字段和用于存储值的
			HashEntry 的value.定义成volatile的变量,能够在线程之间保持可见性,能够被多线程同时读,并且保证不会读到
			过期的值,但是只能被单线程写(有一种情况可以被多线程写,就是写入的值不依赖于原值),在get操作里只需要读不
			需要写共享变量count和value,所以可以不用加锁
		(3).put方法首先定位到 Segment,然后在 Segment里进行插入操作.插入操作需要经历两个步骤:
			第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容,第二步定位添加元素的位置然后放在 HashEntry 数组里
	6.3.TreeMap、HashMap、LindedHashMap的区别:
		(1).Java为数据结构中的映射定义了一个接口java.util.Map;
			主要有四个实现类,分别是 HashMap Hashtable LinkedHashMap 和 TreeMap 
		(2).Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。 
		(3).Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，
			具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;
			允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;
			可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，
			或者使用ConcurrentHashMap
		(4).Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，
			即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。
		(5).LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.
			也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，
			实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，
			而HashMap的遍历速度和他的容量有关。
		(6).TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，
			当用Iterator 遍历TreeMap时，得到的记录是排过序的。 
		(7).一般情况下，我们用的最多的是HashMap,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,
			根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 
			TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 
			LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,
			它还可以按读取顺序来排列，像连接池中可以应用。
#### 7.如果别人知道源码是怎么实现的,故意构造相同的 hash 的字符串进行攻击,如何处理?在JDK7中如何处理?
	7.1.如何处理构造相同 hash 的字符串进行攻击:
		(1).当客户端提交一个请求并附带参数的时候,web应用服务器会把参数转换成一个 HashMap 存储,这个 HashMap 的逻辑结构:
			key1 -> value1
		(2).但是物理存储结构是不同的,key值会变转换成 hashcode,这个hashcode又会被转化成数组的下标: 0--> value1
		(3).不同的 string 就会产生相同的 hashcode而导致碰撞,碰撞后的物理存储结构可能如下: 0->value1->value2
		(4).所以:
			需要限制 post 和 get 的参数的个数,越少越好
			限制post数据包的大小
			WAF(Web Application Firewall)
	7.2.JDK7 的处理方式:
		HashMap 会动态的使用一个专门的 TreeMap 实现来替换它

#### 8.String,StringBuffer,StringBuilder 区别以及对 String 不变的理解:
	8.1.区别:
		(1).都是 final 类,不允许被继承
		(2).String 长度是不可变的, StringBuffer 和 StringBuilder 长度是可变的;
		(3).StringBuffer 是线程安全的,StringBuffer 和 StringBuilder 所有方法都是一样的,只是 StringBuffer 方法都加上了
			synchronized 修饰确保线程安全;
		(4).StringBuilder 性能优于 StringBuffer;
		(5).如果在编译期能确认是一个字符串常量,字符串会自动拼接成一个常量,此时 String 拥有更好的性能
	8.2.String不变性理解:
		(1).String 类是被 final 修饰的,不能被继承;
		(2).使用 + 连接字符串的时候会创建新的字符串;
		(3).String s = new String("Hello world"); 可能创建两个对象或一个对象;如果静态常量池中有"Hello world"的字符串常量的话,
			则仅仅在堆中创建一个对象;如果静态常量池中不存在"Hello world",则堆和静态常量池中都会创建对象;
		(4).使用 + 连接实际上是转换成 StringBuilder 的实例调用 append()方法来实现;	

#### 9.如果一个类重写了 equals 方法但没有重写 hashcode 会出现什么问题?
	在存储散列表时,如果原对象 equals 新对象,但没有对 hashcode 重写,即两个对象拥有不用的 hashcode,则在集合中将会存储
	两个值相同的对象,从而导致混淆;所以,如果重写 equals方法必须重写 hashcode方法
	public boolean equals(Object obj) {
        return (this == obj);
    }

#### 10.Java 序列化? 如何实现序列化与反序列化? 常见的序列化协议?
	10.1.Java 序列化:
		将实现了 Serializable 接口的对象转换成一个字节序列,并能够在以后将这个字节序列完全恢复成原来的对象,
		序列化可以弥补不同操作系统之间的差异;
	10.2.Java 序列化的作用:
		Java 远程方法的调用(RMI)
		对 JavaBeans 进行序列化
	10.3.实现序列化与反序列化:
		10.3.1.实现序列化:
			(1).实现 Serializable 接口,该接口是一个可序列化的标志,没有任何属性和方法;如果不在类中添加 
				readeObject()和writeObject()方法,则采用默认的序列化机制;如果添加了这两个方法,还想使用默认的序列化机制,
				则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()
			(2).为了保证安全性,可以使用 transient 关键字进行修饰不必序列化的对象,在序列化时,private 修饰的属性也能查看到;
			(3).实现 Externalizable,自己要对序列化内容进行控制,控制哪些属性可以被序列化,哪些不能被序列化
		10.3.2.反序列化:
			(1).实现 Serializable 接口的对象在反序列化时不需要调用对象所在类的构造方法,完全基于字节,
				如果是子类继承父类的序列化,那么将调用父类的构造方法;
			(2).实现 Externalizable  接口的对象在反序列化时会调用构造方法
	10.4.注意:
		(1).被 static ,final 修饰的属性不会被序列化;
		(2).对象的类名,属性都会被序列化;
		(3).如果父类实现了 Serializable 接口,子类但没有实现 Serializable 接口,子类拥有一切可序列化相关的特性,子类可以序列化;
		(4).如果子类实现 Serializable 接口,父类不实现,根据父类序列化规则,父类的字段数据将不被序列化,从而达到部分序列化的功能;
			在反序列化时仍会调用父类的构造器,只能调用父类的无参构造函数作为默认的父对象
		(5).当通过网络,文件进行序列化时,必须按照写入顺序读取对象;
		(6).反序列化时必须要有序列化对象时的class文件;
		(7).显示的声明 serialVersionUID,因为在不同的 jvm 之间,默认生成的 serialVersionUID 可能不同,造成反序列化失败;
	10.5.常見的序列化协议:
		// http://www.tuicool.com/articles/IVJFjiR
		(1).COM:主要用于windows 平台,并没有实现跨平台,其序列化原理是利用编译器中的虚表
		(2).CORBA:早期比较好的实现了跨平台,跨语言的序列化协议,COBRA 的主要问题是参与方过多带来的版本过多,
			版本之间兼容性较差,以及使用复杂晦涩;
		(3).XML&SOAP:
			XML 是一种常用的序列化和反序列化协议,具有跨机器,跨语言等优点;
			SOAP(Simple Object Access protocol)是一种被广泛应用的,基于XML为序列化和反序列化协议的结构化消息传递协议;
			SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议
		(4).JSON(Javascript Object Notation)
			①.这种Associative array格式非常符合工程师对对象的理解;
			②.它保持了XML的人眼可读(Human-readable)的优点;
			③.相对xml而言,序列化都的数据更简洁;
			④.它具备Javascript的先天性支持,所以被广泛应用于Web browser的应用常景中,是Ajax的事实标准协议;
			⑤.与XML相比，其协议比较简单，解析速度比较快;
			⑥.松散的Associative array使得其具有良好的可扩展性和兼容性
		(5).Thrift:是 Facebook 开源提供的一个高性能,轻量级 RPC 服务框架,其产生正是为了满足当前大数据量、分布式、跨语言、
			跨平台数据通讯的需求;其并不仅仅是序列化协议,而是一个 RPC 框架;
			由于Thrift的序列化被嵌入到Thrift框架里面,Thrift框架本身并没有透出序列化和反序列化接口,
			这导致其很难和其他传输层协议共同使用;		
		(6).Protobuf:
			①.标准的IDL和IDL编译器，这使得其对工程师非常友好;
			②.序列化数据非常简洁,紧凑,与XML相比,其序列化之后的数据量约为1/3到1/10;
			③.解析速度非常快，比对应的XML快约20-100倍;
			④.提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码;

#### 11.Java 创建线程的方式? 有什么不同之处?
	// http://blog.csdn.net/longshengguoji/article/details/41126119
	11.1.三种创建线程的方式:
		(1).继承 Thread 类创建线程类,实现 run 方法;
		(2).通过 Runnable 接口创建线程类,实现 run 方法;
			new Thread(new MyRunnable()).start();
		(3).实现 Callable 接口,实现call()方法,使用 FutureTask 类来包装 Callable 对象,FutureTask 对象封装了该 Callable 
			对象的call()方法的返回值;使用 FutureTask 对象作为 Thread 对象的target创建并启动新线程
			FutureTask<Integer> task = new FutureTask<>(new MyCallable());
	11.2.三种创建线程的不同之处:
		(1).实现 Runnable 或 Callable 接口可以避免 Java 中的单线程,代码块有被多个线程共享,代码与数据是独立的;
		(2).实现 Callable 要实现 call 方法,该方法在线程执行完成后有返回值;
	
#### 12.线程安全:
	12.1.定义:某个类的行为与其规范一致.不管多个线程怎样的执行顺序和优先级或是wait,sleep,join等控制方式,如果一个类在多线程
		访问下运转一切正常,并且访问类不需要进行额外的同步处理或者协调,那么我们认为它是线程安全的;
	12.2.保证线程安全:
		对变量使用 volatile,对程序段进行加锁:synchronized,lock
		非线程安全的集合在多线程环境下可以使用,但不能作为多个线程的共享变量,可以作为某个线程的独享属性;
	12.3.多线程中共用一个数据变量需要注意什么?
		(1).当我们在线程对象(Runnable)中定义了全局变量,run方法会修改该变量时,如果有多个线程同时使用该线程对象,那么就会造成
			全局变量的值被同时修改,造成错误;
		(2).ThreadLocal 是JDK引入的一种机制,它用于解决线程间共享变量,使用 ThreadLocal 声明的变量,即使在线程中属于全局变量,
			针对每个线程来说,这个变量是独立的;
		(3).volatile 变量每次被线程访问时,都被强迫线程从主内存中重新读该变量的最新值,而当该变量发生变化时,也会强迫线程
			将最新的值刷新回主内存中,这样不同的线程看到的值都是最新的值;

#### 13.什么是线程池?如果让你设计一个线程池,如何设计,应该有哪些方法?
	13.1.线程池:事先创建若干个可执行的线程放入一个池(容器)中,需要的时候从池中获取线程不用自行创建,使用完毕不用销毁而是
		放回池中,从而减少创建和销毁线程对象的开销
	13.2.设计一个动态大小的线程池:
		13.2.1.一个线程池包括四个基本组成部分:
			(1).线程管理器 ThreadPool:用于创建并管理线程,包括创建线程,销毁线程池,添加新任务;
			(2).工作线程 PoolWorker:线程池中线程,在没有任务时处于等待状态,可以循环执行任务;
			(3).任务接口 Task:每个任务必须实现的接口,以供工作线程调度任务的执行,主要规定任务的入口,任务执行完成的
				收尾工作,任务的执行状态等;
			(4).任务队列 TaskQueue:用于存放没有处理的任务,提供一种缓冲机制
		13.2.2.所包含的方法:
			private ThreadPool() 创建线程池
			public static ThreadPool getThreadPool()获得一个默认个数的线程池
			public void execute(Runnable task);执行任务,只是把任务加入任务队列
			public void execute(Runnable[] task);批量执行任务,只是批量加入到任务队列
			public void destroy()销毁线程池,该方法保证在所有任务都完成的情况下才能销毁所有线程,否则等待任务完成后销毁
			public int getWorkThreadNumber()返回工作线程的个数
			public int getFinishedTaskNumber()返回已完成的任务个数,只是出了任务队列,实际可能还没有完成
			public void addThread()在保证线程池中所有线程正在执行,并且要执行线程的个数大于某一值时,增加线程池中线程的个数
			public void reduceThread()在保证线程池中有很大一部分线程处于空闲状态,并且空闲状态线程在小于某个数时减少线程个数

#### 14.Java 的内存泄漏与内存溢出
	14.1.静态集合类,使用 Set,Vector,HashMap 等集合时需要特别注意,当这些类被定义成静态的时候,由于他们的生命周期跟应用程序
		一样,这时候可能发生内存泄漏
		private static Vector v = new Vector(10);
		public void init(){
			for (int i=1; i < 100 ; i++ ) {
				Object obj = new Object();
				v.add(obj);
				obj = null;
			}
		}
		在上面代码中,循环申请了 Object 对象,并添加到 Vector 中,然后设置为 null,可是这些对象被 Vector 引用,因此不能
		被GC回收,因此造成内存泄漏,需要释放这些对象,并将其从 Vector 中移出,最简单的方法就是 Vector 置为 null
	14.2.监听器:在编程中使用到很多监听器,如果增加监听器,在往往释放时没有删除这些监听器
	14.3.物理连接:数据库连接和网络连接,除非显示关闭了,否则是不会自动被GC回收的
		数据库连接 Connection 需要显示回收的,一旦回收,ResultSet 和 Statement 对象理解变为 null;
		如果使用连接池,情况就不一样了除了要显示地关闭连接,还必须显示的关闭 ResultSet 和 Statement,否则会造成大量的对象
		没有被关闭从而引起内存泄漏,一般在 try 代码里创建连接,在 finally 关闭连接
	14.4.内部类和外部模块的使用:内部类的引用一旦没释放可能导致一系列的后继对象没有释放.在调用外部模块的使用,持有被传入
		对象的引用,容易忽略;
	14.5.单例模式:
		单例对象初始化后将在JVM的整个生命周期内存在,如果持有一个外部对象(生命周期比较短)的引用,那么这个外部对象就不能
		被回收,从而导致内存泄漏,如果外部对象还持有其他对象的引用那么内存泄漏更严重;

#### 15.concurrent 包下面有哪些:
	Executor:用来创建线程池,在实现 Callable 接口时,添加线程
	FutureTask
	TimeUnit
	Semaphore
	LinkedBlockingQueue

#### 16.volatile 关键字如何保证内存可见性:
	16.1.volitile 关键字的作用:
		(1).保证内存的可见性
		(2).防止指令重排序
		(3).注意:volatile并不保证原子性
	16.2.内存可见性:每次访问变量时都会进行一次刷新,因此每次访问的都是主内存中最新的版本,保证变量修改的实时可见性
	16.3.当且仅当满足一下所有条件时,才应该使用 volatile 变量:
		(1).对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值
		(2).该变量没有包含在具有其他变量的不变式中;
	16.4.使用建议:
		(1).在两个或者更多的线程需要访问的成员变量上使用 volatile.当要访问的变量已在 synchronized 代码块中或者为常量时,
			没有必要使用 volatile;
		(2).由于使用volatile屏蔽掉了JVM中必要的代码优化,所以在效率上较低.
	16.5.volatile 和 synchronized 区别:
		(1).volatile 不会进行加锁操作:
			volatile 变量时一种稍弱的同步机制,在访问 volatile 变量时不会执行加锁操作,因此也不会使执行线程阻塞,因此
			volatile变量时一种比 synchronized 更轻量级的同步机制;
		(2).volatile 变量作用类似同步变量的读写操作:
			从内存可见性的角度看,写入 volatile 变量相当于退出同步代码块,而读取volatile变量相当于进入代码块
		(3).volatile 不如 synchronized 安全:
			在代码中如果过度依赖volatile变量来控制状态的可见性,通常会比使用锁的代码脆弱.仅当volatile变量能简化代码的实现
			以及对同步策略的验证时,才应该使用它
		(4).volatile 无法同时保证内存可见性和原子性
			加锁机制既可以确保可见性又可以确保原子性,而volatile只能确保可见性.原因是:声明为volatile的简单变量如果当前值
			与该变量以前的值相关,那么volatile关键字不起作用,如:count++,不是原子操作

#### 17.sleep 和 wait分别是哪个类的方法,有什么区别?
	(1).sleep: 是 Thread 类的静态方法
		调用此方法会让当前线程暂停执行指定的时间,将执行机会(CPU)让给其他线程,但是对象的锁依然保持,因此休眠结束后会自动恢复;
	(2).wait: 是 Object 类的方法
		调用对象的 wait 方法导致当前线程放弃对象的锁(线程暂停执行),进入对象的等待池,只有调用的对象的 notify(notifyAll)
		时才能唤醒等待池中的线程进入等锁池,如果线程重新获得对象的锁就可以进入就绪状态:
	==> 为什么 wait 方法要定义在 Object 类中?
		因为这些方法在操作同步线程时,都必须要标识它们操作线程的锁,只有同一个锁上的被等待线程,可以被同一个锁上的notify唤醒,
		不可以对不同锁中的线程进行唤醒,等待和唤醒必须是同一个锁.
		而锁可以是任意对象,所以可以被任意对象调用的方法是定义在 Object 类中.
		而:jdk1.5以后提供了 Lock 接口和 Condition 对象,Condition 中的await(), signal().signalAll()代替 
			Object 中的wait(),notify(),notifyAll()

#### 18.synchronized 与 Lock 的区别,使用场景.
	(1).用法-synchronized 隐式锁:在需要同步的对象中加入此控制,synchronized 可以加在方法上,也可以加在特定的代码块中,
		括号表示需要锁的对象;
	(2).用法-Lock(显示锁):需要显示指定起始位置和终止位置.一般使用 ReentrantLock 类作为锁,多个线程中必须要使用一个
		ReentrantLock 类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出,所以一般
		在 finally 中写 unlock(),以防死锁
	(3).性能:synchronized 是托管给 JVM 执行的,而 Lock 是Java写的控制锁的代码,在Java1.5中, synchronized 是低效的.
		因为这是一个重量级的操作,需要调用操作接口,导致有可能加锁消耗的时间比加锁以外的操作还多.相比之下使用 Java 提供的
		Lock 对象,性能更高一些.到了1.6之后,synchronized 在语义上很清晰,可以进行很多优化,有适应自旋、锁消除、锁粗化、轻量级锁、
		偏向锁等待,在JDK1.6后,synchronized 与 Lock 在性能上相当
	(4).机制:synchronized 原始采用的是 CPU 悲观锁机制,即线程获得是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁.
		Lock 用的是乐观锁方式.所谓乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,
		直到成功为止.乐观锁实现的机制就是CAS(Compare and Swap)操作

#### 19.synchronized 底层是如何实现的?用在代码块和方法上有什么区别?
	19.1.底层实现:
		
	19.2.用在代码块和方法上的区别:
		(1).synchronized 用在代码块锁的是调用该方法的对象(this),也可以选择锁任何一个对象;
		(2).synchronized 用在方法上锁的是调用该方法的对象
		(3).synchronized 用在代码块上可以减少锁的粒度,从而提高并发性能;
		(4).无论用在代码块上还是方法上,都是获取对象的锁,每一个对象只有一个锁与之相关联;实现同步需要很大的系统开销作为代价,
			甚至可能造成死锁,所以尽量避免无谓的同步控制;
	19.3.synchronized 和 static synchronized 的区别:
		(1).synchronized 是对类的当前实例进行加锁,防止其他线程同时访问该类的该实例的所有 synchronized 块,同一个类的两个不同
			实例就没有这种约束
		(2).static synchronized 恰好就是要控制类的所有实例的访问,static synchronized 是限制线程同时访问 jvm 中该类的所有实例
			同时访问对应的代码块

#### 20.Java 中的 BIO,NIO,AIO 分别是什么?
	(1).BIO:同步并阻塞,服务器实现模式为一个连接一个线程,即客户端有连接请求时服务器端就需要启动一个线程进行处理,如果这个连接
		不做任何事情会造成不必要的线程开销,当然可以通过线程池机制改善
		BIO 方式适用于连接数目比较小且固定的架构,这种方式对服务器资源要求比较高,并发局限于应用中,JDK1.4以前的唯一选择
	(2).NIO:同步非阻塞,服务器实现模式为一个请求一个线程,即客户端发送的连接请求都会注册到多路复用器上,多路复用器轮询到连接
		有 I/O 请求时才启动一个线程进行处理;
		NIO 方式适用于连接数多且连接比较短的架构,比如聊天服务器,并发局限于应用中,编程较复杂,JDK1.4后开始支持;
	(3).AIO:异步非阻塞,服务器实现模式为一个有效请求一个线程,客户端的 I/O 请求都是由OS先完成了在通知服务器应用去启动线程进行处理;
		AIO 的方式适用于连接数多且连接比较长的架构,JDK7 开始支持

#### 21.JDK 源码中使用到的设计模式:
	装饰器模式:IO 流
	迭代器模式:Iterator
	单例模式: java.lang.Runtime
	代码模式:RMI

#### 22.数据库索引的优缺点以及什么时候数据库索引失效?
	22.1.索引的特点:
		(1).可以加快数据库的检索速度;
		(2).降低数据库的插入,修改,删除等维护的速度;
		(3).只能创建到表上,不能创建到视图上;
		(4).既可以直接创建又可以间接创建;
		(5).可以在优化隐藏中使用索引
		(6).使用查询处理器知识SQL语句,在一个表上,一次只能使用一个索引;
	22.2.索引的有点:
		(1).创建唯一性索引,保证数据表中每一行数据的唯一性;
		(2).大大加快数据的检索速度,这是创建索引的最主要的原因;
		(3).加快数据库表之间的连接,特别是在实现数据的参考完整性方面有意义;
		(4).在使用分组和排序字句进行数据检索时,同样可以显著减少系统的查询中分组和排序的时间
	22.3.索引的缺点:
		(1).创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加;
		(2).索引需要占用物理空间,除了数据表占用数据空间之外,每个表还需要占用一定的物理空间;
		(3).当对表中的数据进行增删改时,索引也需要维护

#### 23.

#### 24.

#### 25.

#### 26.Mybatis 和 Hibernate 
    比较:http://www.cnblogs.com/inspurhaitian/p/4647485.html
	(1).开发效率



































