# 一、问题排查案例

## 1、Docker上运行Java服务后发生OOM

详细描述：一个64g内存服务器，有一个总4g分配的docker运行Java服务，起始最大均为3g，服务器内不止运行一个服务，运行3个月后此Java服务发生OOM，给出至少6种可能情况，需要有具体场景（一共9种）

**（1）堆内存不足**
- Java 服务运行时，随着时间的推移，堆内存中的对象无法及时被 GC 回收，导致堆内存耗尽。堆中的对象包括常驻缓存、大型集合、或者存在内存泄漏；
- 例如，某个服务在内存中缓存了大量用户会话数据，但未及时清理无用的会话对象，导致堆内存逐渐耗尽；

**（2）非堆内存溢出（Metaspace）**
- Java 8 及以后的版本使用 Metaspace 存储类元数据。如果有大量类动态生成或者类加载器没有被正确卸载，Metaspace 的空间会耗尽。
- 例如，系统使用了某种动态代理框架（如 CGLIB 或 Hibernate），频繁生成新的类对象或动态加载类，但由于类加载器未正确回收，导致类占用了大量 Metaspace 空间

**（3）堆外内存泄漏**
- 一些 Java 应用通过 `ByteBuffer.allocateDirect()` 分配堆外内存（如网络传输和 NIO 操作），但没有正确释放内存，导致系统内存不足。
- 例如，某个 Java 应用使用 Netty 框架进行大量的网络 I/O 操作，频繁分配和使用 Direct ByteBuffer，但由于错误的内存管理（没有显式释放），导致堆外内存被耗尽

**（4）线程数过多导致的内存耗尽**
- 每个 Java 线程都会消耗一定的栈内存（默认 1MB）。如果服务中线程池管理不当或者使用大量并发线程（如未限制线程数量），会导致内存耗尽。
- 例如，一个服务使用了未正确配置的线程池或者创建了过多的并发任务，每个线程分配的栈内存累加，最终耗尽了内存。

**（5）GC 频率过高导致内存不足**
- Java 堆内存设置不合理或对象频繁创建，导致 GC 无法及时回收老年代内存，出现“GC thrashing”，即系统忙于垃圾回收而不能正常处理应用逻辑，最终导致 OOM。
- 例如，某个应用频繁创建短生命周期的对象，大量对象无法及时回收进入老年代，Full GC 持续占用 CPU 时间，最终导致服务无法正常工作并 OOM

**（6）内存泄漏**
- 应用程序中存在引用未释放、对象长时间保留在内存中或某些类缓存管理不当，导致对象无法被 GC 回收，逐渐耗尽堆内存。
- 例如，应用使用了缓存（如 LRU Cache）但未设定缓存大小上限，或使用静态变量持有大量引用，最终导致内存泄漏

**（7）Docker 容器内存限制导致 OOM**
- 容器的内存限制导致 JVM 无法获得足够的系统内存，即便堆内存设置为 3GB，其他内存开销（如栈内存、Metaspace、Direct Memory）也会导致总内存超出限制。
- 例如，某个 Java 应用的堆外内存和栈内存总和超出了 Docker 容器的 4GB 限制，尽管 JVM 堆内存没有耗尽，容器被 OOMKilled

**（8）操作系统层面内存不足**
- 服务器上运行了多个服务，所有服务的内存需求总和超出了 64GB 内存限制，操作系统为了回收内存，选择杀掉 Java 容器进程。
- 例如，服务器运行多个内存密集型服务，随着时间推移，内存使用持续增加，最终操作系统因为内存压力，杀掉了 Docker 中的 Java 服务

**（9）内存碎片化**
- Java 堆内存或 Direct Memory 中的内存碎片过多，导致应用需要大块连续内存时，虽然总内存还未耗尽，但无法获得足够的连续内存，触发 OOM。
- 例如，某个应用长期运行过程中，频繁的对象分配和释放导致内存碎片化，导致服务无法再分配大块内存

# 二、场景设计题

- [高频场景面试题](https://www.yuque.com/snailclimb/tangw3)

## 1、假如给你一个新产品，你将从哪些方面来保障它的质量？

### 1.1. **需求理解与沟通**
- **明确需求**：确保与产品经理、业务人员等充分沟通，明确产品的功能需求、边界条件和性能要求，避免误解导致功能错误或实现偏差。
- **功能文档**：建立详细的功能需求文档，列出核心功能、业务逻辑、用例和非功能性需求（如性能、可靠性等）。

### 1.2. **代码质量保障**
- **编码规范**：遵循标准的编码规范（如 Google Java Style Guide），确保代码清晰可读、可维护。可以使用工具如 Checkstyle 或 SonarLint 来自动化检查代码风格问题。
- **代码审查（Code Review）**：通过团队内部的代码审查，确保代码逻辑正确、实现方式合理、没有潜在的性能问题或安全漏洞。
- **单一职责原则**：采用面向对象设计原则（如 SOLID 原则），确保每个类和方法职责单一、模块化设计良好，增强代码的可维护性和扩展性。
- **重构**：定期对代码进行重构，消除重复代码、优化设计，确保代码质量随着项目规模增长仍能保持高水平。

### 1.3. **自动化测试**
- **单元测试**：为核心业务逻辑编写全面的单元测试，确保代码变更不会影响现有功能。常用的单元测试框架有 JUnit 和 TestNG。
- **测试覆盖率**：使用工具（如 JaCoCo）来监控测试覆盖率，确保关键逻辑部分有足够的测试覆盖。虽然 100% 的覆盖率不必要，但核心业务逻辑的覆盖率应尽可能高。
- **集成测试**：编写集成测试来验证不同模块间的交互是否正确，尤其是涉及数据库、第三方服务和外部API的部分。
- **UI 和端到端测试**：对于涉及用户界面的产品，可以使用 Selenium 或 Cypress 进行端到端测试，确保整个应用从用户输入到输出的流程无误。
- **Mock 测试**：对于依赖外部系统的部分（如数据库、第三方 API），使用 Mockito 或 WireMock 等工具进行 Mock 测试，避免外部依赖导致测试不稳定。

### 1.4. **持续集成和持续部署（CI/CD）**
- **自动化构建与测试**：集成 Jenkins、GitLab CI、Travis CI 等工具，确保每次代码提交后自动触发构建和测试，及时发现并解决问题。
- **自动化部署**：设置 CI/CD 流水线，将经过测试的代码自动部署到测试环境或生产环境，确保代码版本可控且发布过程一致。

### 1.5. **性能优化**
- **性能测试**：在开发过程中进行性能测试，使用工具如 JMeter 或 Gatling 模拟高并发负载，检测系统在大流量下的性能瓶颈。
- **内存与CPU分析**：使用 Profiling 工具（如 VisualVM、YourKit 或 Java Mission Control）分析应用的内存、CPU 和线程使用情况，排查内存泄漏、GC 问题或 CPU 占用过高等问题。
- **数据库优化**：确保 SQL 查询语句高效，避免全表扫描，适当地使用索引。对于数据库操作，可以引入缓存层（如 Redis）以减轻数据库负载。
- **线程池管理**：合理配置线程池的大小，避免线程池溢出或长时间阻塞，确保系统在高并发场景下也能保持响应能力。

### 1.6. **安全性**
- **输入验证**：确保对用户输入进行严格验证，防止 SQL 注入、跨站脚本攻击（XSS）等常见的安全漏洞。
- **身份认证和授权**：使用安全的身份验证机制（如 OAuth 2.0），确保用户访问控制的安全性。敏感信息的传输应使用 HTTPS。
- **加密数据**：敏感信息（如用户密码、支付信息等）需要加密存储，并确保安全传输（使用 SSL/TLS）。
- **安全扫描**：集成安全扫描工具（如 SonarQube、OWASP ZAP）到 CI/CD 流程，自动检测潜在的安全漏洞。

### 1.7. **日志和监控**
- **日志记录**：在应用中使用日志（如 Log4j、SLF4J）记录关键信息、错误和性能指标。确保日志级别分类合理，便于排查问题。
- **监控与告警**：集成监控系统（如 Prometheus、Grafana 或 ELK Stack），实时监控应用的健康状态、响应时间、内存/CPU 使用情况，及时发现异常。设置告警规则，一旦系统指标异常，自动通知相关人员。
- **可观测性**：引入分布式追踪系统（如 OpenTelemetry、Zipkin 或 Jaeger）来跟踪微服务之间的请求链路，分析延迟或瓶颈所在。

### 1.8. **用户反馈和异常处理**
- **用户反馈机制**：通过异常捕获（如全局异常处理器）以及用户反馈接口，及时收集用户在使用产品中的问题。将异常信息记录在日志中，确保开发团队能尽快修复问题。
- **健壮的异常处理**：确保系统对异常处理得当，使用 `try-catch` 和全局异常处理机制（如 Spring 的 `@ControllerAdvice`）来处理错误，避免程序崩溃。

### 1.9. **回归测试**
- **回归测试**：每次更新功能或修复 bug 后，进行全面的回归测试，确保新改动不会破坏现有功能。
- **版本控制与回滚**：确保每次部署都版本化，出现问题时能快速回滚到上一个稳定版本，减少对生产环境的影响。

### 1.10. **高可用与容灾**
- **高可用架构**：确保产品架构具有冗余设计，使用负载均衡、集群或多实例部署等方式，确保单点故障不会导致系统不可用。
- **备份与恢复**：设计良好的数据备份与恢复机制，确保出现故障或数据丢失时能够快速恢复数据。

### 总结

保障 Java 应用的产品质量需要从多个方面入手，包括需求理解、代码质量控制、自动化测试、持续集成、性能优化、安全性防护、日志监控等。通过构建稳健的开发和交付流程，及时发现和解决问题，确保产品的高质量和高可用性。

## 2、场景设计：底层存储

nosql、数据冗余

设计一个高性能的文件写入系统：
- 使用缓冲区（Buffer）来减少磁盘I/O操作的次数。
- 采用异步I/O或者多线程/多进程来并行处理文件写入，提高吞吐量。
- 使用内存映射（Memory-Mapped Files）技术，减少数据在用户空间和内核空间之间的拷贝。
- 选择合适的文件系统和存储介质，例如使用SSD代替HDD，或者使用高速的NVMe存储。
- 对文件系统进行适当的配置，比如调整文件系统的缓存策略或者关闭文件系统的某些特性（如atime更新）

## 3、mysql的同步方式

binlog 方案

## 4、对于订单系统，如何应对突发的读写流量

- 读写分离：提升 MySQL 并发的首选方案，因为当单台 MySQL 无法满足要求时，就只能用多个具有相同数据的 MySQL 实例组成的集群来承担大量的读写请求；
- MySQL主从架构：MySQL 做读写分离的前提，是把 MySQL 集群拆分成“主 + 从”结构的数据集群，这样才能实现程序上的读写分离，并且 MySQL 集群的主库、从库的数据是通过主从复制实现同步的；
- 对于读：可以缓存用户最近的订单数据，比如最近一周、最近10笔订单等等；

## 5、聊聊你印象最深刻的项目，或者做了什么优化

比如缓存数据库相关的，查询为空，你设置了一个-1到缓存，代表数据库没记录。下次判断-1，就不查库了，以解决缓存穿透问题。

又比如你设置缓存过期时间比较分散，解决缓存击穿问题，都可以条理清晰写到简历去，这样面试官很可能会问你相关的问题，这时候就对答如流啦。

还有平时你做的项目，有一些比较好的设计，都可以说一下哈，比如你是如何保证数据一致性的，怎么优化接口性能的。

如果是讲优化接口这一块的话，其实就是缓存、分批、并发调用、异步等那几个关键知识点。

如果是代码优化细节，你可以挑个简单的来讲，比如复杂的if逻辑条件，可以调整顺序，让程序更高效，这样会让面试官眼前一亮哦。

## 6、如果应用经常请求超时，如何解决这个问题？如何做代码预热

### 6.1、应用超时

解决请求超时：需要通过性能分析工具找到瓶颈，优化数据库、线程池、缓存、异步处理等方面，并为不同的服务和操作设置合理的超时策略。

### 6.2、代码预热

代码预热（Warm-up）是为了在系统启动时避免因 JIT（即时编译器）优化、类加载或资源初始化导致的性能波动。通过代码预热，确保系统在上线前已经经历过负载并准备好提供高效的服务

主要是体现JVM层面上的能力，以Dubbo为例：

Dubbo 服务预热功能的核心代码：`org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance#calculateWarmupWeight`

[Dubbo预热方式](https://juejin.cn/post/7134547114725965838)

JVM预热参考文档：[JVM预热](../Java/Java虚拟机/JVM-Java虚拟机.md#16JVM预热)

代码预热：包括 JIT 编译预热、类加载预热、资源预加载、以及使用模拟请求或自动化脚本来模拟实际负载，确保系统在实际使用前已经准备好最佳性能状态

## 7、如果用redis来实现抢红包，比如10个红包，大家并发来抢，使用什么数据结构最合适

使用 Redis 来实现抢红包的场景，考虑到并发性和高效性，最合适的数据结构是 **List** 或 **Sorted Set**。以下是这两种数据结构的具体实现思路：

### 7.1、使用 List 数据结构

Redis 的 List 数据结构具有先进先出（FIFO）的特性，可以将每个红包的金额存储在 List 中，然后每个用户通过 `LPOP` 或 `RPOP` 操作抢红包。

**实现思路：**

1. **初始化红包**：将红包的金额依次放入 Redis 的 List 中，例如 key 为 `redpacket_list`。
```bash
RPUSH redpacket_list 10 20 30 40 50 60 70 80 90 100
```
这会将 10 个红包的金额放入 List 中。
   
2. **用户抢红包**：每个用户尝试通过 `LPOP` 或 `RPOP` 从 List 中取出一个红包。`LPOP` 操作是原子性的，多个用户并发时，Redis 可以确保只有一个用户能成功取到红包。
```bash
LPOP redpacket_list
```
该操作会从 List 左边弹出一个红包金额。List 是线程安全的，Redis 在并发场景下保证只有一个用户可以成功执行 `LPOP`。

3. **抢红包成功**：每个用户通过 `LPOP` 成功获得一个红包后，可以将金额记录到某个数据结构中（如用户的余额或抢红包记录）。

**优点**
- **简单易实现**：Redis 的 List 数据结构天然支持先进先出，`LPOP` 操作是原子性的，保证并发安全性。
- **性能高效**：抢红包操作的时间复杂度为 O(1)，非常高效。

**缺点**：**没有排序或优先级**，红包是按照先进先出的顺序抢到的，无法控制抢到的顺序或优先级。

### 7.2、使用 Sorted Set 数据结构

如果希望红包的分配有一定的优先级（例如按金额大小来抢），可以使用 Redis 的 Sorted Set（有序集合）数据结构。每个红包的金额可以作为 score，存入 Sorted Set 中。

**实现思路：**

1. **初始化红包**：将红包金额作为 score，红包的唯一标识作为 member，放入 Redis 的 Sorted Set 中，例如 key 为 `redpacket_sortedset`。
```bash
ZADD redpacket_sortedset 10 redpacket1 20 redpacket2 30 redpacket3
```
   
2. **用户抢红包**：每个用户通过 `ZRANGE` 或 `ZPOPMIN` 操作从 Sorted Set 中按顺序获取一个红包。`ZPOPMIN` 操作可以确保并发时只有一个用户成功抢到最小的红包金额。
```bash
ZPOPMIN redpacket_sortedset
```
该操作会取出并移除最小的红包金额。

3. **抢红包成功**：将抢到的红包金额分配给用户，并记录抢红包记录。

**优点：**
- **有序性**：Sorted Set 允许根据红包金额的大小进行有序的分配，保证红包按某种规则（如金额大小）抢到。
- **并发安全**：`ZPOPMIN` 操作也是原子性的，确保同一时间只有一个用户能成功抢到一个红包。

**缺点：**
- **复杂度较高**：相较于 List，Sorted Set 的操作复杂度稍高（一般为 O(logN)），但在大多数情况下性能仍然足够快。



### 3. **总结**
- 如果只是简单的并发抢红包，使用 **List** 是最简单、最高效的方式，使用 `LPOP` 或 `RPOP` 来实现并发安全的抢红包操作。
- 如果需要对红包的分配进行排序或优先级控制，使用 **Sorted Set** 可以确保按规则分配红包，但操作复杂度稍高。

这两种方案都能满足高并发抢红包场景，具体选择可以根据业务需求决定。

## 8、设计一个全局微观有序的发号机

## 9、场景题：设计一个抢红包系统

参考[红包业务](../软件工程/软件设计/实际业务/各种业务.md#十八红包业务)

## 10、场景题：设计一个im系统包括群聊单聊

## 11、场景题：设计数据库连接池

参考[池化技术设计](../软件工程/软件设计/设计案例.md#二池化技术设计)

## 12、场景题：秒杀场景的设计

参考[秒杀系统](../软件工程/软件设计/实际业务/各种业务.md#一秒杀系统)

## 13、场景题：如何设计一个动态线程池？

- [什么是线程池](../Java/源码分析/thread/线程池.md#7动态化线程池)
- [如何设计一个动态线程池？](https://www.yuque.com/snailclimb/tangw3/neiydtd79u8pgple)

主要思路是对线程池的核心参数实现自定义可配置。这三个核心参数是：
- corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。
- maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

这三个参数是 ThreadPoolExecutor 最重要的参数，它们基本决定了线程池对于任务的处理策略

要获取线程池的指标数据，可以使用以下方法：
- getCorePoolSize()：获取核心线程数。
- getMaximumPoolSize()：获取最大线程数。
- getPoolSize()：获取线程池中的工作线程数（包括核心线程和非核心线程）。
- getQueue()：获取线程池中的阻塞队列，可以从队列中获取任务的数量来了解队列积压情况。
- getActiveCount()：获取活跃线程数，也就是正在执行任务的线程。
- getLargestPoolSize()：获取线程池曾经到过的最大工作线程数。
- getTaskCount()：获取历史已完成以及正在执行的总的任务数量。

除了这些线程池指标相关的方法之外，还可以使用ThreadPoolExecutor的钩子方法进行扩展：
- beforeExecute(Thread t, Runnable r)：在执行每个任务之前调用，可以在此处记录任务开始执行时间。
- afterExecute(Runnable r, Throwable t)：在每个任务执行后调用，不论任务是否成功完成，可以用来记录任务执行结束时间。
- terminated()：当线程池进入 TERMINATED 状态时调用，可以在此时进行资源清理、统计汇总等操作。

如果想要实现一个支持可视化和告警的线程池监控，会比较麻烦，需要自己去写可视化界面和告警功能。Spring Boot 提供了 Actuator 模块来监控应用程序的运行状态，包括线程池的使用情况，通过定义自定义一个 Endpoint 类，手动暴露线程池相关指标信息，这样可以更加灵活和可控

## 14、场景题：设计埋点系统

- [埋点代码](https://github.com/pengxurui/EasyTrack)
- [西瓜视频埋点方案](https://mp.weixin.qq.com/s/iMn--4FNugtH26G90N1MaQ)
- [GrowingioSDK源码设计](https://mp.weixin.qq.com/s/ZRbfx3zWkFfjp91hbgRbVA)
- [百度的前端埋点实现：百度统计](https://tongji.baidu.com/web5/welcome/login)
- [高性能前端埋点上报系统的架构与实现:https://juejin.cn/post/7531640790898245670](https://github.com/JiMei-University-Zhuang/TraceFlow)

由面到点
- 后端埋点
- 可视化埋点
- 无痕埋点

埋点可以分为手动埋点和自动埋点：
- 手动埋点：开发者需要在代码中手动添加追踪代码，通常需要明确指定需要追踪的事件和数据。
- 自动埋点：使用第三方工具或库自动捕获用户行为，减少开发者的工作量，但可能会收集到大量不必要的数据。

埋点的设计和实施需要仔细规划，以确保收集到的数据准确且有用，同时也要注意用户隐私和数据安全。

## 15、场景题：设计一个权限系统

[权限设计](../软件工程/软件设计/实际业务/业务系统.md#二十三权限设计)

## 16、负载均衡架构设计

假设你来设计一个日活跃用户 1000 万的论坛的负载均衡集群，你的方案是什么？设计理由是什么？

- 首先，流量评估：1000万DAU，换算成秒级，平均约等于116。考虑每个用户操作次数，假定10，换算成平均QPS=1160。
    - 考虑峰值是均值倍数，假定10，换算成峰值QPS=11600。
    - 考虑静态资源、图片资源、服务拆分等，流量放大效应，假定10，QPS*10=116000。 
- 其次，容量规划。
    - 考虑高可用、异地多活，QPS*2=232000。
    - 考虑未来半年增长，QPS*1.5=348000。
- 最后，方案设计。三级导流。
    - 第一级，DNS，确定机房，以目前量级，可以不考虑。
    - 第二级，确定集群，扩展优先，则选Haproxy/LVS，稳定优先则选F5。
    - 第三级，Nginx+KeepAlived，确定实例。

# 参考资料

- [System Design Interviews 仓库](https://medium.com/javarevisited/10-best-github-repositories-to-prepare-for-system-design-interviews-6cc9d37d50f6)
