<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**目录**

- [一.链表](#%E4%B8%80%E9%93%BE%E8%A1%A8)
- [二.队列与栈](#%E4%BA%8C%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88)
- [三.树](#%E4%B8%89%E6%A0%91)
- [四.算法:](#%E5%9B%9B%E7%AE%97%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 一.链表
# 二.队列与栈
1.两个栈实现一个队列
# 三.树
#### 1.二叉树
	(1).求二叉树的最大距离(即相距最远的两个叶子节点)
	(2).求二叉树的宽度
	(3).什么是二叉平衡树,如何插入节点,删除节点,说出关键步骤.
	(4).二叉树遍历(先序、中序、后序)
	(5).求二叉树的深度,非递归
	(6).DFS,BFS 算法
#### 2.红黑树
	(1).B+/B-树,红黑树基本结构,复杂度,树结构在工程中的应用
	(2).什么地方有用到红黑树
#### 3.二分搜索树(二分查找)
# 四.算法:
#### 1.递归可能造成什么问题,为什么,怎么解决;
#### 2.二分查找
#### 3.动态规划
#### 4.排序算法:插入排序,选择排序,堆排序,冒泡排序,快速排序,归并排序
#### 5.常用的hash算法有哪些?什么是一致性哈希
#### 6.一个非常大(1000G)的文件每一行存放一个IP地址,求出现频次最高的一个IP
#### 7.10G文件的淘宝商品编号,只有512M内存,怎么判断究竟是不是合法编号
#### 8.k-means 算法
#### 9.贪心算法
#### 10.分治算法
#### 11.Hoffman 编码
#### 12.缓存调度算法:FIFO,LRU,LFU
	12.1.FIFO:First in First out,先进先出

	12.2.LRU:Least Recently Used,即最近最久未使用的意思.
		// http://blog.csdn.net/beiyeqingteng/article/details/7010411
		(1).算法根据数据的历史访问记录来进行淘汰数据,其核心思想是"如果数据最近被访问过,那么将来被访问的几率也更高"
		(2).实现1:使用 LinkedHashMap,
			一是它本身已经实现了按照访问顺序的存储.
			二是 LinkedHashMap 本身有一个方法用于判断是否需要移除最不常读取的数,原始方法默认不需要移除
		(3).实现2:链表+HashMap
	12.3.LFU:Least Frequently Used,最近最少使用算法










