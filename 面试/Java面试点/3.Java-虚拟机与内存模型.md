<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1.JVM 结构?运行时数据区域的包括哪些?](#1jvm-%E7%BB%93%E6%9E%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B)
- [2.Java 对象是如何访问的?](#2java-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%9A%84)
- [3.如何判断对象是可回收的? 引用计数法? 根搜索算法?](#3%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E5%9B%9E%E6%94%B6%E7%9A%84-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)
- [4.Java 的4种引用方式?强引用,软引用,弱引用,虚引用](#4java-%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8)
- [5.垃圾收集算法:标记清除,复制算法,标记整理,分代收集?有哪些收集器?](#5%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B6%E9%9B%86%E5%99%A8)
- [6.Minor GC 和 Full GC 有什么区别?](#6minor-gc-%E5%92%8C-full-gc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
- [7.Java 内存:为什么堆内存分区?堆内存分为哪几块?分代收集算法](#7java-%E5%86%85%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E5%9D%97%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95)
- [8.Class 字节码文件](#8class-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6)
- [9.类加载器:类加载器的作用?有哪些类加载器?](#9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8)
- [10.类加载机制:双亲委派模型?为什么要使用双亲委派模型?](#10%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B)
- [11.虚拟机和物理机的区别是什么?](#11%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
- [12.运行时栈桢结构](#12%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E6%A1%A2%E7%BB%93%E6%9E%84)
- [13.Java 方法调用:](#13java-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)
- [14.基于栈的指令集和基于寄存器的指令集](#14%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86)
- [15.Javac 编译过程分为哪些步骤?](#15javac-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4)
- [16.什么是即时编译器?](#16%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8)
- [17.解释器和编译器分别是什么?](#17%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
- [18.编译对象与触发条件:](#18%E7%BC%96%E8%AF%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6)
- [19.经典的优化技术](#19%E7%BB%8F%E5%85%B8%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF)
- [20.如果对象不会逃逸到方法或线程外,可以做什么优化?](#20%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BC%9A%E9%80%83%E9%80%B8%E5%88%B0%E6%96%B9%E6%B3%95%E6%88%96%E7%BA%BF%E7%A8%8B%E5%A4%96%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96)
- [21.Java与C/C++的编译器对比](#21java%E4%B8%8Ecc%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%AF%94)
- [22.物理机如何处理并发问题?](#22%E7%89%A9%E7%90%86%E6%9C%BA%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98)
- [23.Java 内存模型:什么是 Java 内存模型?Java 内存模型的目标?原子性,可见性,有序性](#23java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%80%E4%B9%88%E6%98%AF-java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjava-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7)
- [24.violate 关键字作用](#24violate-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8)
- [26.虚拟机性能监控命令](#26%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4)
- [27.虚拟机故障处理工具(可视化)](#27%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%8F%AF%E8%A7%86%E5%8C%96)
- [28.调优:Thread Dump,分析内存结构](#28%E8%B0%83%E4%BC%98thread-dump%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84)
- [29.JVM 各个版本的新特性](#29jvm-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7)
- [30.JVM 的启动参数](#30jvm-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0)
- [31.Java 的内存溢出与C++的内存溢出](#31java-%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8Ec%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA)
- [32.自动内存管理机制](#32%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6)
- [33.Java GC 是在什么时候,对什么东西,做了什么事情?](#33java-gc-%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AF%B9%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85)
- [34.内存泄露与内存溢出实例:](#34%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%AE%9E%E4%BE%8B)
- [35.描述下 JVM:(考验你对JVM整体的理解),可以从 javac 再到 GC](#35%E6%8F%8F%E8%BF%B0%E4%B8%8B-jvm%E8%80%83%E9%AA%8C%E4%BD%A0%E5%AF%B9jvm%E6%95%B4%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E4%BB%8E-javac-%E5%86%8D%E5%88%B0-gc)
- [36.画出 volatile 的内存模型](#36%E7%94%BB%E5%87%BA-volatile-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
- [37.如何排查 OOM 和内存泄漏](#37%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5-oom-%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

#### 1.JVM 结构?运行时数据区域的包括哪些?
	1.1.程序计数器:(PC 寄存器)
		(1).是一块较小的内存空间,可以看作是当前线程所执行字节码的行号指示器;
		(2).每条线程都需要一个独立的程序计数器.
		(3).如果线程正在执行的是一个 Java 方法,计数器记录的是正在执行的虚拟机字节码指令的地址;
			如果正在执行的是 Native 方法,这个计数器的值为空.
		(4).程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域
	1.2.Java 虚拟机栈:
		(1).是线程私有的,生命周期与线程相同.
		(2).虚拟机栈描述的是 Java 方法执行的内存模型:每个方法被执行的时候都会创建一个栈帧(Stack Frame)存储:
			局部变量表、操作栈、动态链接、方法出口.
			每一个方法被调用到执行完成的过程,就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程;
		(3).这个区域有两种异常情况:
			StackOverflowError-线程请求的栈深度大于虚拟机所允许的深度
			OutOfMemoryError-虚拟机栈扩展到无法申请足够的内存时
	1.3.本地方法栈:线程私有
		(1).虚拟机栈为虚拟机执行 Java 方法(字节码)服务.
		(2).本地方法栈(Native Method Stacks)为虚拟机使用到的 Native 方法服务
	1.4.Java 堆:线程共享
		(1).Java 堆(Java Heap)是 Java 虚拟机中内存最大的一块.Java 堆在虚拟机启动时创建,被所有线程共享;
		(2).作用:存放对象实例.垃圾收集器主要管理的就是 Java 堆.Java 堆在物理上可以不连续,只要逻辑上连续即可.
		Java 中设置最大堆和最小堆内存的参数: -Xmx -Xms
	1.5.方法区:线程共享,非堆
		(1).用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.
		(2).不需要连续的内存,可以选择固定的大小,更可以选择不实现垃圾收集;
	1.6.运行时常量池:
		是方法区的一部分.保存 Class 文件中的符号引用、翻译出来的直接引用.运行时常量池可以在运行期间将新的常量放入池中
	1.7.直接内存:
		其并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.它直接从操作系统中分配
#### 2.Java 对象是如何访问的?
	Object obj = new Object(); 最简单的访问,也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域
	Object obj => 如果出现在方法体中,则上述代码会反映到 Java 栈的本地变量表中,作为 reference 类型数据出现
	new Object() => 反映到 Java 堆中,形成一块存储了 Object 类型所有对象实例数据值的内存.Java 堆中还包
					含对象类型数据的地址信息,这些类型数据存储在方法区中
	(1).一个空Object对象的占多大空间？
#### 3.如何判断对象是可回收的? 引用计数法? 根搜索算法?
	3.1.判断一个对象可以回收:
		(1).引用计数法
		(2).GC Roots(根搜索,可达性分析)
	3.2.引用计数法:
		(1).给对象中添加一个引用计数器,每当有一个地方引用他时,计数器就加 1;当引用失效时,引用计时器就减 1;
			任何时刻计数器为 0 的对象就是不可能再被使用;
		(2).缺点:很难解决对象之间的循环引用问题
			如父对象有一个对子对象的引用,子对象反过来引用父对象.这样,他们的引用计数永远不可能为 0;
	3.3.根搜索算法:
		(1).基本思路:通过一系列的成为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径成为
			引用链(Reference Chain),当一个对象的 GC Roots 没有任何引用链相连(用图论的话说,就是从 GC Roots
			到这个对象不可达)时,证明此对象是不可用的;
		(2).GC Roots 对象:
			虚拟机栈中的引用的对象 
			方法区中静态属性引用的对象,常量引用的对象 
			本地方法栈中JNI(即一般说的Native方法)引用的对象
#### 4.Java 的4种引用方式?强引用,软引用,弱引用,虚引用
	4.1.Java 对引用的概念进行了扩充:
		强引用,软引用,弱引用,虚引用
	4.2.强引用(String Reference)
		Object obj = new Object();
		只要强引用还在,垃圾收集器永远不会回收掉被引用的对象.
	4.3.软引用(Soft Reference)
		用来描述一些还有用,但并非必须的对象.软引用所关联的对象,有在系统将要发生内存溢出异常之前
		将会把这些对象列进回收范围,并进行第二次回收
	4.4.弱引用(Weak Reference)
		描述非必须的对象,强度比软引用更弱一些,被弱引用关联的对象,只能生存到下一次垃圾收集发生前
	4.5.虚引用(Phantom Reference)
		它是最弱的一种引用关系;一个对象是否有虚引用的存在完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例;
		为一个对象设置虚引用关联的唯一目的:能在这个对象被垃圾收集器回收时收到一个系统通知;
#### 5.垃圾收集算法:标记清除,复制算法,标记整理,分代收集?有哪些收集器?
	5.1.垃圾收集算法:参考文件:/Java知识点/Java/JavaSE/Java-JVM/Java-GC垃圾回收机制.java
	5.2.垃圾收集器:内存回收的具体实现,参考文件:/Java知识点/Java/JavaSE/Java-JVM/Java-GC垃圾回收机制.java
	5.3.描述G1收集器,CMS垃圾收集器
#### 6.Minor GC 和 Full GC 有什么区别?
	6.1.Minor GC:从年轻代空间(包括 Eden 和 Survivor 区域)回收内存被称为 Minor GC.主要使用复制算法
		(1).当 JVM 无法为一个新的对象分配空间时会触发 Minor GC,比如当 Eden 区满了.所以分配率越高,越频繁执行 Minor GC;
		(2).执行 Minor GC 操作时,不会影响到永久代.从永久代到年轻代的引用被当成 GC roots,从年轻代到永久代的引用在标记阶段被直接忽略掉
		(3).所有的 Minor GC 都会触发"全世界的暂停(stop-the-world)"停止应用程序的线程.大部分 Eden 区中的对象都能被认为是垃圾,
			永远也不会被复制到 Survivor 区或者老年代空间.如果正好相反,Eden 区大部分新生对象不符合 GC 条件,
			Minor GC 执行时暂停的时间将会长很多;
	6.2.Full GC 和 Major GC --- Major GC 是清理永久代,Full GC 是清理整个堆空间—包括年轻代和永久代
		标记整理算法.
		速度一般比 Minor GC 慢10倍以上
#### 7.Java 内存:为什么堆内存分区?堆内存分为哪几块?分代收集算法
	7.1.为什么堆内存要分区?
		对于一个大型的系统,当创建的对象及方法变量比较多时,即堆内存中的对象比较多,如果逐一分析对象是否该回收,效率很低.
		分区是为了进行模块化管理,管理不同的对象及变量,以提高 JVM 的执行效率;
	7.2.堆内存分为哪几块:
		Young Generation Space 新生区(也称新生代)
		Tenure Generation Space 养老区(也称老生代)
		Permanent Space 永久代
			==> 方法区,方法区和"PermGen Space"又有着本质的区别.前者是 JVM 的规范,而后者则是 JVM 规范的一种实现.
				并且只有 HotSpot 才有"PermGen Space"
	7.3.内存分配有哪些原则:
		(1).对象优先分配在 Eden
		(2).大对象直接进入老年代
		(3).长期存活的对象将进入老年代
		(4).动态对象年龄判定
		(5).空间分配担保
	7.4.新生代和老年代的比例
#### 8.Class 字节码文件
	[/Java知识点/Java/JavaSE/Java-JVM/JVM-Java虚拟机.java]----5.Class 类文件结构
#### 9.类加载器:类加载器的作用?有哪些类加载器?
	[/Java知识点/Java/JavaSE/Java-JVM/JVM-Java虚拟机.java]----6.虚拟机类加载机制:
#### 10.类加载机制:双亲委派模型?为什么要使用双亲委派模型?
	[/Java知识点/Java/JavaSE/Java-JVM/JVM-Java虚拟机.java]----6.虚拟机类加载机制:
#### 11.虚拟机和物理机的区别是什么?
#### 12.运行时栈桢结构
#### 13.Java 方法调用:
#### 14.基于栈的指令集和基于寄存器的指令集
#### 15.Javac 编译过程分为哪些步骤?
#### 16.什么是即时编译器?
#### 17.解释器和编译器分别是什么?
#### 18.编译对象与触发条件:
#### 19.经典的优化技术
#### 20.如果对象不会逃逸到方法或线程外,可以做什么优化?
#### 21.Java与C/C++的编译器对比
#### 22.物理机如何处理并发问题?
#### 23.Java 内存模型:什么是 Java 内存模型?Java 内存模型的目标?原子性,可见性,有序性
#### 24.violate 关键字作用
#### 26.虚拟机性能监控命令
	jps:虚拟机进程状况工具
	jstat:虚拟机统计信息监视工具
	jinfo:Java 配置信息
	jmap:Java 内存映像工具
	jhat:虚拟机堆转储快照分析工具
	jstack:Java 堆栈跟踪工具
#### 27.虚拟机故障处理工具(可视化)
	JConsole:Java 监视与管理控制台 
	VisualVM:多合一故障处理工具
#### 28.调优:Thread Dump,分析内存结构
#### 29.JVM 各个版本的新特性
#### 30.JVM 的启动参数
#### 31.Java 的内存溢出与C++的内存溢出
#### 32.自动内存管理机制
#### 33.Java GC 是在什么时候,对什么东西,做了什么事情?
	33.1.什么时候:
		(1).系统空闲的时候
		(2).系统自身决定,不可预测的时间/调用 System.gc 的时候
		(3).说出新生代和老年代的结构,并说出MinorGC和FullGC
		(4).MinorGC 和 FullGC 触发的条件,OOM 触发的条件
	33.2.对什么东西:
		(1).不使用的对象
		(2).超出作用域的对象/引用计数为空的对象
		(3).从gc root开始搜索,搜索不到的对象
		(4).从root搜索不到,而且经过第一次标记、清理后,仍然没有复活的对象
	33.3.做了什么事情:
		(1).删除不使用的对象,释放内存空间
		(2).停止其他线程执行、运行finalize;
		(3).新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、
			复制清理和标记清理有有什么优劣势
		(4).
#### 34.内存泄露与内存溢出实例:
	(1).内存泄露:
		Vector v = new Vector(10);
        for (int i = 1; i < 10000000; i++) {
            Object o = new Object();
            v.add(o);
            o = null;
        }
    (2).内存溢出:
    	内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
    	集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
    	代码中存在死循环或循环产生过多重复的对象实体；
    	使用的第三方软件中的BUG；
    	启动参数内存值设定的过小；
    	ArrayList list=new ArrayList();
        while(true){
            list.add(new Heap());
        }
#### 35.描述下 JVM:(考验你对JVM整体的理解),可以从 javac 再到 GC
	(1).编译为.class文件阶段:
	(2).虚拟机的结构
	(3).GC
#### 36.画出 volatile 的内存模型
#### 37.如何排查 OOM 和内存泄漏?常见的jvm的问题排查步骤
#### 38.jstack,jmap,jutil分别的意义？如何线上排查JVM的相关问题？
#### 39.如何解决内存碎片的问题？
#### 40.如何解决同时存在的对象创建和对象回收问题？
#### 41.Java虚拟机中，数据类型可以分为哪几类？
#### 42.在Java中，什么是是栈的起始点，同是也是程序的起始点？
#### 43.为什么不把基本类型放堆中呢？
#### 44.吞吐量优先选择什么垃圾回收器？响应时间优先呢？
#### 45.如何进行JVM调优？有哪些方法？
#### 46.JVM的参数 -server 和 -client 有哪些区别?

