说明:以 MySQL 为主
1.怎么理解事务? 数据库事务特性(ACID)
	1.1.事务:
	1.2.事务特性:ACID
		(1).原子性-Atomicity:
			事务包含的所有操作要么全部成功,要么全部失败回滚
		(2).一致性-Consistency:
			事务必须使数据库从一个一致性状态变换到另一个一致性状态,
			也就是说一个事务执行之前和执行之后都必须处于一致性状态
		(3).隔离性-Isolation:多个并发事务之间要相互隔离,不能相互影响
		(4).持久性-Durability:一个事务一旦被提交了,那么对数据库中的数据的改变就是永久性的
2.数据库隔离级别介绍、举例说明:http://www.cnblogs.com/fjdingsd/p/5273008.html
	2.1.不考虑隔离性发生的问题:
		(1).脏读:指在一个事务处理过程里读取了另一个未提交的事务中的数据;
		(2).不可重复读:在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据值,
			这是由于在查询间隔,被另一个事务修改并提交了;
			==> 脏读是某一事务读取了另一个事务未提交的脏数据,而不可重复读则是读取了前一事务提交的数据
		(3).虚读(幻读):事务非独立执行时发生的一种现象
	2.2.事务隔离级别有4个,由低到高依次,级别越高执行效率越低
		(1).Read uncommitted(未授权读取、读未提交):
			如果一个事务已经开始写数据,则另外一个事务则不允许同时进行写操作,但允许其他事务读此行数据.
			该隔离级别可以通过“排他写锁”实现.最低级别,任何情况都无法保证
		(2).Read committed(授权读取、读提交):
			该隔离级别避免了脏读,但是却可能出现不可重复读
			读取数据的事务允许其他事务继续访问该行数据,但是未提交的写事务将会禁止其他事务访问该行
		(3).Repeatable read(可重复读取):可避免脏读、不可重复读的发生
			读取数据的事务将会禁止写事务(但允许读事务),写事务则禁止任何其他事务.
			避免了不可重复读取和脏读,但是有时可能出现幻读.这可以通过“共享读锁”和“排他写锁”实现
		(4).Serializable(序列化):
			提供严格的事务隔离.它要求事务序列化执行.事务只能一个接着一个地执行,但不能并发执行。
	2.3.隔离级别越高,越能保证数据的完整性和一致性,但是对并发性能的影响也越大.对于多数应用程序,
		可以优先考虑把数据库系统的隔离级别设为 Read Committed.它能够避免脏读取,而且具有较好的并发性能.
		可以通过悲观锁和乐观锁来控制不可重复读,幻读等并发问题.
	2.4.大多数数据库的默认级别就是 Read committed,比如 Sql Server , Oracle
		MySQL 的默认隔离级别就是 Repeatable read.
		mysql中查看事务隔离级别:select @@tx_isolation;
			set  [glogal | session]  transaction isolation level 隔离级别名称;
		    set tx_isolation=’隔离级别名称;’
3.海量数据,如何进行查询优化?方案
4.数据库中的范式有哪些
	4.1.范式:为了建立冗余较小、结构合理的数据库,设计数据库时必须遵循一定的规则.范式是符合某一种设计要求的总结
	4.2.三范式:
		4.2.1.第一范式:如果数据库表中的所有字段值都是不可分解的原子值,该数据库表满足了第一范式
		4.2.2.第二范式:需要确保数据库表中的每一列都和主键相关,而不能只与主键的某一部分相关(主要针对联合主键而言)
			也就是说在一个数据库表中,一个表中只能保存一种数据,不可以把多种数据保存在同一张数据库表中.
		4.2.3.需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关
5.索引入门:什么情况下适合创建索引?什么情况下设置了索引但无法使用?
	索引:是帮助Mysql高效获取数据的数据结构 ---> 索引是数据结构
	5.1.索引建立的原则:
		MySQL中,只有 InnoDB 的表是按照主键方式创建的索引组织表,而 MyISAM 还是按堆表方式组织的
		(1).使用区分度高的列作为索引:
			区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，区分度越高，
			索引树的分叉也就越多，一次性找到的概率也就越高;
		(2).尽量使用字段长度小的列作为索引
		(3).使用数据类型简单的列(int 型,固定长度)
		(4).尽量避免选用 NOT NULL 的列,在MySQL中,含有空值的列很难进行查询优化,因为它们使得索引、索引的统计信息以及比较
			运算更加复杂.你应该用0、一个特殊的值或者一个空串代替空值
		(5).尽量的扩展索引,不要新建索引.
			比如表中已经有a的索引,现在要加(a,b)的索引,那么只需要修改原来的索引即可.这样也可避免索引重复
		(6).选择合适的索引数据类型:
			越小的数据类型通常更好:越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间,处理起来更快
			简单的数据类型更好:整型数据比起字符,处理开销更小,因为字符串的比较更复杂
		(7).选择合适的标识符:
			①.整型:通常是作为标识符的最好选择,因为可以更快的处理,而且可以设置为 AUTO_INCREMENT
			②.字符串:尽量避免使用字符串作为标识符,它们消耗更好的空间,处理起来也较慢.而且,通常来说,字符串都是随机的,
				所以它们在索引中的位置也是随机的,这会导致页面分裂、随机访问磁盘,聚簇索引分裂(对于使用聚簇索引的存储引擎)
	5.2.创建索引的情况:
		(1).经常出现在关键字 order by,group by, distinct 后面的字段;
		(2).在 union 等集合操作的结果集上建立索引;
		(3).为经常用作查询选择的字段建立索引;
		(4).在经常考虑用作表连接的属性上建立索引;
		(5).考虑使用索引覆盖,对数据很少被更新的表,如果用户经常只查询其中的几个字段,
			可以考虑在这几个字段上建立索引,从而将表的扫描改变为索引的扫描
	5.3.索引失效:
		(1).如果条件中有or,即使其中有条件带索引,也不会使用(尽量少用or); 
		(2).Like 查询是以 %开头,例如SELECT * FROM mytable WHEREt Name like’%admin’,会导致全文搜索
		(3).如果列类型是字符串,那一定要在条件中使用引号引起来,否则不会使用索引;
		(4).应尽量避免在 where 子句中使用!=或<>操作符
		(5).in 和 not in 也要慎用，否则会导致全表扫描
		(6).如果第一个筛选条件是范围查询,MySQL 不再使用剩下的索引;
	5.4.索引的限度:
		索引并不是越多越好,索引固然可以提高相应的 select 的效率,但同时也降低了 insert 及 update 的效率,
		因为 insert 或 update 时有可能会重建索引,所以怎样建索引需要慎重考虑,视具体情况而定.
		一个表的索引数最好不要超过6个.
	5.5.索引的特点:
		(1).可以加快数据库的检索速度;
		(2).降低数据库的插入,修改,删除等维护的速度;
		(3).只能创建到表上,不能创建到视图上;
		(4).既可以直接创建又可以间接创建;
		(5).可以在优化隐藏中使用索引
		(6).使用查询处理器知识SQL语句,在一个表上,一次只能使用一个索引;
	5.6.索引的优点:
		(1).创建唯一性索引,保证数据表中每一行数据的唯一性;
		(2).大大加快数据的检索速度,这是创建索引的最主要的原因;
		(3).加快数据库表之间的连接,特别是在实现数据的参考完整性方面有意义;
		(4).在使用分组和排序字句进行数据检索时,同样可以显著减少系统的查询中分组和排序的时间
	5.7.索引的缺点:
		(1).创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加;
		(2).索引需要占用物理空间,除了数据表占用数据空间之外,每个表还需要占用一定的物理空间;
		(3).当对表中的数据进行增删改时,索引也需要维护,降低数据维护的速度
	5.8.索引分类:
		(1).普通索引(它没有任何限制.) 
		(2).唯一性索引(索引列的值必须唯一,但允许有空值.) 
		(3).主键索引(一种特殊的唯一索引,不允许有空值.一般是在建表的时候同时创建主键索引.) 
		(4).组合索引 
		(5).聚集索引 按照每张表的主键构造一颗B+树,并且叶节点中存放着整张表的行记录数据,因此也让聚集索引的叶节点成为数据页. 
		(6).非聚集索引(辅助索引)(页节点不存放一整行记录).
6.数据库中的索引的结构有哪些结构,索引底层是如何实现的?
	http://blog.codinglabs.org/articles/theory-of-mysql-index.html
	大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构
	6.1.索引的类型:	索引是在存储引擎中实现的而不是在服务器层中实现的.
		所以,每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型;
		6.1.1.B-Tree 索引:利用 B-Tree 索引进行全关键字、关键字范围和关键字前缀查询,保证按索引的最左边前缀来进行查询:
			(1)匹配全值(Match the full value):对索引中的所有列都指定具体的值。
			(2)匹配最左前缀(Match a leftmost prefix):你可以利用索引查找last name为Allen的人,仅仅使用索引中的第1列.
			(3)匹配列前缀(Match a column prefix):你可以利用索引查找last name以J开始的人,这仅仅使用索引中的第1列。
			(4)匹配值的范围查询(Match a range of values)：
				可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
			(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：
				可以利用索引查找last name为Allen，而first name以字母K开始的人。
			(6)仅对索引进行查询(Index-only queries):如果查询的列都位于索引中，则不需要读取元组的值。
		6.1.2.Hash 索引:建立在哈希表的基础上,它只对使用了索引中的每一列的精确查找有用
			在mysql中，只有memory存储引擎支持显式的哈希索引,是Memory表的默认索引类型
			Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。
			Hash 索引无法被用来避免数据的排序操作。
			Hash 索引不能利用部分索引键查询。
			Hash 索引在任何时候都不能避免表扫描。
			Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
		6.1.4.空间索引(R-树)索引:
			MyISAM支持空间索引,主要用于GIS中空间数据的存储，但是MySQL的空间索引支持并不好，现在多使用PostgreSQL
		6.1.5.全文索引(Full-text)索引:
			文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作
	6.2.
	6.3.
	6.4.各引擎支持的索引:MyISAM,InnoDB,Memonry 三个常用MySQL引擎类型比较
		|索引 			|MyISAM 索引 |InnoDB 索引 |Memonry 索引|
		|------------------------------------------------------|
		|B-tree索引 	|支持		 |支持		  |支持        |
		|Hash索引   	|不支持		 |不支持	  |支持        |
		|R-tree索引 	|支持		 |不支持	  |不支持      |
		|Full-text索引 	|不支持		 |暂不支持	  |不支持      |
		+------------------------------------------------------+
7.MySQL 的explain 分析函数,数据库慢执行的指标;
8.ER 模型是怎么样的
9.MySQL 的数据库引擎:MyISAM 和 InnoDB 引擎的区别:
	9.1.主要区别:
		(1).MyISAM 是非事务安全型的, InnoDB 是事务安全型的;
		(2).MyISAM 锁的粒度是表级锁, InnoDB 是支持行级锁的;
		(3).MyISAM 支持全文本索引,而InnoDB不支持全文索引
		(4).MyISAM 相对简单,所以在效率上要优于 InnoDB,小型应用可以考虑使用 MyISAM;
		(5).MyISAM 表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦;
		(6).InnoDB 表比 MyISAM 表更安全,可以在保证数据不丢失的情况下,切换非事务表到事务表；
	9.2.适用场景:
		(1).MyISAM 管理非事务表,它提供高速存储和检索,以及全文搜索能力,如果应用中需要执行大量的select查询,那么MyISAM是更好的选择
		(2).InnoDB 用于事务处理应用程序,具有众多特性,包括ACID事务支持.如果应用中需要执行大量的insert或update操作,
			则应该使用 InnoDB,这样可以提高多用户并发操作的性能
10.MySQL 主从与读写分离技术
11.数据库的连接池
	11.1.什么是数据库连接池:
		数据库连接池(Connection pooling)是程序启动时建立足够的数据库连接,并将这些连接组成一个连接池,
		由程序动态地对池中的连接进行申请、使用、释放.
		因为创建数据库连接是一个很耗时的操作.也容易对数据库造成安全隐患

12.如何设计数据库表字段?从哪些方面考虑
13.表分区? 
	13.1.表分区:
		是指根据一定规则,将数据库中的一张表分解成多个更小的,容易管理的部分.
		从逻辑上看,只有一张表,但是底层却是由多个物理分区组成.
		子分区:分区表中对每个分区再次分割，又成为复合分区
	13.2.与分表的区别:
		(1).分表:指的是通过一定规则,将一张表分解成多张不同的表
		(2).表与分区的区别在于:分区从逻辑上来讲只有一张表,而分表则是将一张表分解成多张表
	13.3.表分区的优点:
		(1).分区表的数据可以分布在不同的物理设备上,从而高效地利用多个硬件设备.
		(2).和单个磁盘或者文件系统相比,可以存储更多数据.
		(3).优化查询.在where语句中包含分区条件时,可以只扫描一个或多个分区表来提高查询效率.
			涉及sum和count语句时,也可以在多个分区上并行处理,最后汇总结果. 
		(4).分区表更容易维护.例如:想批量删除大量数据可以清除整个分区. 
		(5).可以使用分区表来避免某些特殊的瓶颈.例如InnoDB的单个索引的互斥访问,ext3问价你系统的inode锁竞争等;
	13.4.表分区的限制因素:
		(1).一个表最多只能有1024个分区;
		(2).MySQL5.1中,分区表达式必须是整数,或者返回整数的表达式.在MySQL5.5中提供了非整数表达式分区的支持.
		(3).如果分区字段中有主键或者唯一索引的列,那么多有主键列和唯一索引列都必须包含进来.
			即:分区字段要么不包含主键或者索引列,要么包含全部主键和索引列.
		(4).分区表中无法使用外键约束.
		(5).MySQL 的分区适用于一个表的所有数据和索引,不能只对表数据分区而不对索引分区,也不能只对索引分区而不对表分区,
			也不能只对表的一部分数据分区;
	13.5.查看分区:判断 MySQL 是否支持表分区:
			mysql> show variables like '%partition%';
			+-------------------+-------+
			| Variable_name     | Value |
			+-------------------+-------+
			| have_partitioning | YES   |
			+-------------------+-------+
			1 row in set (0.00 sec)
	13.6.MySQL 支持的分区类型:
		(1).RANGE分区:按照数据的区间范围分区;
		(2).LIST分区:按照List中的值分区,与 RANGE的区别是,range分区的区间范围值是连续的;
		(3).HASH分区
		(4).KEY分区
		说明:在MySQL5.1版本中,RANGE,LIST,HASH 分区要求分区键必须是 int 类型,或者通过表达式返回INT类型.
			但KEY分区的时候,可以使用其他类型的列(BLOB，TEXT类型除外)作为分区键;
	13.7.RANGE分区:
		(1).利用取值范围进行分区,区间要连续并且不能互相重叠.语法如下:
			partition by range(exp)( --exp可以为列名或者表达式，比如to_date(created_date)
			    partition p0 values less than(num)
			)
			例子:
				create table emp (
				  	id       int not null,
				  	store_id int not null
				)
				partition by range (store_id) (
					partition p0 values less than (10),
					partition p1 values less than (20)
				);
				上面的语句创建了emp表,并根据store_id字段进行分区,小于10的值存在分区p0中,大于等于10,小于20的值存在分区p1中.
			==> 注意:每个分区都是按顺序定义的,从最低到最高.
				上面的语句,如果将less than(10) 和less than (20)的顺序颠倒过来,那么将报错,如下:
				ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
		(2).RANGE分区存在问题:	
			A.range 范围覆盖问题:当插入的记录中对应的分区键的值不在分区定义的范围中的时候,插入语句会失败.
				上面的例子,如果我插入一条store_id = 30的记录会怎么样呢?我们上面分区的时候,最大值是20,如果插入一条超过20的记录,会报错:
				mysql> insert into emp value(30,30);
				ERROR 1526 (HY000): Table has no partition for value 30.
			==> 解决方案:
				①.预估分区键的值,及时新增分区.
				②.设置分区的时候,使用 values less than maxvalue 子句,MAXVALUE表示最大的可能的整数值.
				③.尽量选择能够全部覆盖的字段作为分区键,比如一年的十二个月等
			B.Range分区中,分区键的值如果是NULL,将被作为一个最小值来处理
	13.8.LIST分区:
		List分区是建立离散的值列表告诉数据库特定的值属于哪个分区,语法:
		partition by list(exp)( --exp为列名或者表达式
	        partition p0 values in (3,5)  --值为3和5的在p0分区
	    )
		例子:
			create table emp1 (
			  id       int not null,
			  store_id int not null
			)
			  partition by list (store_id) (
			    partition p0 values in (3, 5),
			    partition p1 values in (2, 6, 7, 9)
			  )
		==> 注意:如果插入的记录对应的分区键的值不在list分区指定的值中,将会插入失败.并且,list不能像range分区那样提供maxvalue.
	13.9.Columns分区:MySQL5.5中引入的分区类型,解决了5.5版本之前range分区和list分区只支持整数分区的问题
		Columns分区可以细分为 range columns分区和 list columns分区,他们都支持整数、日期时间、字符串三大数据类型.
		-- http://www.cnblogs.com/chenmh/p/5630834.html
		(1).与 RANGE分区 和 LIST分区区别:
			针对日期字段的分区就不需要再使用函数进行转换了,例如针对date字段进行分区不需要再使用YEAR()表达式进行转换;
			COLUMN分区支持多个字段作为分区键但是不支持表达式作为分区键;
		(2).COLUMNS支持的类型:
			整形支持:tinyint,smallint,mediumint,int,bigint;不支持decimal和float
			时间类型支持:date,datetime
			字符类型支持:char,varchar,binary,varbinary;不支持text,blob
		13.9.1.RANGE COLUMNS分区:
			(1).日期字段分区:
				create table members(
				  id int,
				  joined date not NULL
				)
				  partition by range columns(joined)(
				    partition a values less than('1980-01-01'),
				    partition b values less than('1990-01-01'),
				    partition c values less than('2000-01-01'),
				    partition d values less than('2010-01-01'),
				    partition e values less than MAXVALUE
				  );
			(2).多个字段组合分区:
				CREATE TABLE rcx (
				    a INT,
				    b INT
				    )
				PARTITION BY RANGE COLUMNS(a,b) (
				     PARTITION p0 VALUES LESS THAN (5,10),
				     PARTITION p1 VALUES LESS THAN (10,20),
				     PARTITION p2 VALUES LESS THAN (15,30),
				     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
				);
				注意:多字段的分区键比较是基于数组的比较.
					①.它先用插入的数据的第一个字段值和分区的第一个值进行比较,如果插入的第一个值小于分区的第一个值
						那么就不需要比较第二个值就属于该分区
					②.如果第一个值等于分区的第一个值,开始比较第二个值同样如果第二个值小于分区的第二个值那么就属于该分区.
			==> RANGE COLUMN的多列分区第一列的分区值一定是顺序增长的,不能出现交叉值,第二列的值随便,例如以下分区就会报错:
				PARTITION BY RANGE COLUMNS(a,b) (
				     PARTITION p0 VALUES LESS THAN (5,10),
				     PARTITION p1 VALUES LESS THAN (10,20),
				     PARTITION p2 VALUES LESS THAN (8,30), -- p2 中第一列比p1第一列的要小,所以报错
				     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
				);
		13.9.2.LIST COLUMNS分区:
			(1).非整型字段分区:
				create table listvar (
				  id    int      not null,
				  hired datetime not null
				)
				  partition by list columns (hired)
				  (
				  	partition a values in ('1990-01-01 10:00:00', '1991-01-01 10:00:00'),
				  	partition b values in ('1992-01-01 10:00:00'),
				  	partition c values in ('1993-01-01 10:00:00'),
				  	partition d values in ('1994-01-01 10:00:00')
				  );
				LIST COLUMNS分区对分整形字段进行分区就无需使用函数对字段处理成整形,所以对非整形字段进行分区建议选择COLUMNS分区
			(2).多字段分区:
				create table listvardou (
				  id    int      not null,
				  hired datetime not null
				)
				  partition by list columns (id, hired)
				  (
					  partition a values in ( (1, '1990-01-01 10:00:00'), (1, '1991-01-01 10:00:00') ),
					  partition b values in ( (2, '1992-01-01 10:00:00') ),
					  partition c values in ( (3, '1993-01-01 10:00:00') ),
					  partition d values in ( (4, '1994-01-01 10:00:00') )
				  );

	13.10.HASH分区:
		(1).主要用来分散热点读,确保数据在预先确定个数的分区中尽可能平均分布.
		(2).MySQL支持两种Hash分区:常规Hash分区和线性Hash分区
		A.常规Hash分区-使用取模算法,语法如下:
			partition by hash(store_id) partitions 4;
			上面的语句,根据store_id对4取模,决定记录存储位置.比如store_id = 234的记录,
			MOD(234,4)=2,所以会被存储在第二个分区.
		==> 常规Hash分区的优点和不足-优点:能够使数据尽可能的均匀分布;缺点:不适合分区经常变动的需求.
			如果需要增加两个分区变成6个分区,大部分数据都要重新计算分区.线性Hash分区可以解决.
		B.线性Hash分区-分区函数是一个线性的2的幂的运算法则,语法如下:
			partition by LINER hash(store_id) partitions 4;
			算法介绍:假设要保存记录的分区编号为N,num为一个非负整数,表示分割成的分区的数量,那么N可以通过以下步骤得到：
			Step 1. 找到一个大于等于num的2的幂，这个值为V，V可以通过下面公式得到：
				V = Power(2,Ceiling(Log(2,num)))
				例如:刚才设置了4个分区，num=4，Log(2,4)=2,Ceiling(2)=2,power(2,2)=4,即V=4
			Step 2. 设置N=F(column_list)&(V-1)
				例如:刚才V=4，store_id=234对应的N值，N = 234&(4-1) =2
			Step 3. 当N>=num,设置V=Ceiling(V/2),N=N&(V-1)
				例如:store_id=234,N=2<4,所以N就取值2,即可.
				假设上面算出来的N=5,那么V=Ceiling(2.5)=3,N=234&(3-1)=1,即在第一个分区.
		==> 线性Hash的优点和不足-优点:在分区维护(增加,删除,合并,拆分分区)时,MySQL能够处理得更加迅速;
			缺点:与常规Hash分区相比,线性Hash各个分区之间的数据分布不太均衡
	13.11.KEY分区:
		(1).类似Hash分区,Hash分区允许使用用户自定义的表达式,但Key分区不允许使用用户自定义的表达式.
			Hash仅支持整数分区,而Key分区支持除了Blob和text的其他类型的列作为分区键.
			partition by key(exp) partitions 4; --exp是零个或多个字段名的列表
		==> key分区的时候,exp可以为空,如果为空,则默认使用主键作为分区键,没有主键的时候,会选择非空惟一键作为分区键;
	13.12.分区对于NULL值的处理:
		MySQ允许分区键值为NULL,分区键可能是一个字段或者一个用户定义的表达式.
		一般情况下,MySQL在分区的时候会把 NULL 值当作零值或者一个最小值进行处理.
		注意:
			Range分区中:NULL 值被当作最小值来处理
			List分区中:NULL 值必须出现在列表中,否则不被接受
			Hash/Key分区中:NULL 值会被当作零值来处理
	13.13.分区管理:
		13.13.1.增加分区:
			(1).RANGE分区和LIST分区:
				alter table table_name add partition (partition p0 values ...(exp))
				values后面的内容根据分区的类型不同而不同
			(2).Hash分区和Key分区:
				alter table table_name add partition partitions 8; -- 指的是新增8个分区
		13.13.2.删除分区:
			(1).RANGE分区和LIST分区:
				alter table table_name drop partition p0; --p0为要删除的分区名称
			==> 删除了分区,同时也将删除该分区中的所有数据.
				同时,如果删除了分区导致分区不能覆盖所有值,那么插入数据的时候会报错.
			(2).Hash分区和Key分区:
				alter table table_name coalesce partition 2; --将分区缩减到2个
		13.13.3.移出分区:
			alter table members remove partitioning;
			使用remove移除分区是仅仅移除分区的定义.并不会删除数据和 drop PARTITION 不一样,后者会连同数据一起删除
	13.14.分区查询:
		(1).查询某张表一共有多少个分区:
			SELECT
			  partition_name                   part,
			  partition_expression             expr,
			  partition_description            descr,
			  FROM_DAYS(partition_description) lessthan_sendtime,
			  table_rows
			FROM 
				INFORMATION_SCHEMA.partitions
			WHERE
				TABLE_SCHEMA = SCHEMA ()
				AND TABLE_NAME = 'emp';
		(2).查看执行计划,判断查询数据是否进行了分区过滤
			mysql> explain partitions select * from emp where store_id=5;
			+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+
			| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | Extra       |
			+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+
			|  1 | SIMPLE      | emp   | p1         | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |
			+----+-------------+-------+------------+------+---------------+------+---------+------+------+-------------+
			1 row in set
			上面的结果:partitions:p1 表示数据在p1分区进行检索
14.数据库水平拆分和垂直拆分、分库/分表? 分库/分表中主键问题? 
	-- Cobar:http://blog.csdn.net/shagoo/article/details/8191346

15.纵表的用途
16.锁.
	(1).表级锁:开销小,加锁快; 不会出现死锁; 锁定粒度大,发生锁冲突的概率最高,并发度最低.
		MyISAM和MEMORY存储引擎采用表级锁
	(2).行级锁:开销大,加锁慢; 会出现死锁; 锁定粒度最小,发生锁冲突的概率最低,并发度也最高.
		InnoDB存储引擎既支持行级锁,也支持表级锁,默认情况下为行级锁
	(3).页面锁:开销和加锁时间界于表锁和行锁之间; 会出现死锁; 锁定粒度界于表锁和行锁之间,并发度一般.
		BDB存储引擎采用的是页面锁,但也支持表级锁
17.死锁:
	17.1.什么是死锁:
		是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.
		此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.
		表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.
		==> 死锁的关键在于:两个(或以上)的Session加锁的顺序不一致.
	17.2.死锁产生原因:
		死锁一般是事务相互等待对方资源,最后形成环路造成的
	17.3.分析死锁日志:SHOW ENGINE INNODB STATUS;
	17.4.死锁案例:
		-- http://blog.jobbole.com/99208/
		(1).不同表相同记录行锁冲突:事务A和事务B操作两张表，但出现循环等待锁情况
		(2).相同表记录行锁冲突.这种情况比较常见:
			遇到两个job在执行数据批量更新时,jobA处理的的id列表为[1,2,3,4],
			而job处理的id列表为[8,9,10,4,2],这样就造成了死锁
		(3).不同索引锁冲突:
			事务A在执行时,除了在二级索引加锁外,还会在聚簇索引上加锁,在聚簇索引上加锁的顺序是[1,4,2,3,5],
			而事务B执行时,只在聚簇索引上加锁,加锁顺序是[1,2,3,4,5],这样就造成了死锁的可能性.	
		(4).gap锁冲突:
			innodb在RR级别下,如下的情况也会产生死锁	
	17.5.避免死锁:
		(1).以固定的顺序访问表和行.比如两个job批量更新的情形,简单方法是对id列表先排序,后执行,这样就避免了交叉等待锁的情形;
			又比如将两个事务的sql顺序调整为一致,也能避免死锁.
		(2).大事务拆小.大事务更倾向于死锁,如果业务允许,将大事务拆小.
		(3).在同一个事务中,尽可能做到一次锁定所需要的所有资源,减少死锁概率
		(4).降低隔离级别.如果业务允许,将隔离级别调低也是较好的选择,比如将隔离级别从RR调整为RC,可以避免掉很多因为gap锁造成的死锁
		(5).为表添加合理的索引.可以看到如果不走索引将会为表的每一行记录添加上锁,死锁的概率大大增大
	17.6.定位死锁问题:
		(1).通过应用业务日志定位到问题代码,找到相应的事务对应的sql;
		(2).确定数据库隔离级别
18.



