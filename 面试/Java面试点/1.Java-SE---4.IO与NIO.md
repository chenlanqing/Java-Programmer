<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1.序列化与反序列化:](#1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)
- [2.InputStream、OutputStream、Reader、Writer 的继承体系](#2inputstreamoutputstreamreaderwriter-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB)
- [3.IO 框架主要用到什么设计模式:装饰模式](#3io-%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F)
- [4.NIO 包有哪些结构?分别起到的作用?](#4nio-%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%93%E6%9E%84%E5%88%86%E5%88%AB%E8%B5%B7%E5%88%B0%E7%9A%84%E4%BD%9C%E7%94%A8)
- [5.NIO 针对什么情景会比 IO 有更好的优化?为什么使用NIO? NIO 有什么优势?](#5nio-%E9%92%88%E5%AF%B9%E4%BB%80%E4%B9%88%E6%83%85%E6%99%AF%E4%BC%9A%E6%AF%94-io-%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8nio-nio-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF)
- [6.String 编码UTF-8 和GBK的区别?](#6string-%E7%BC%96%E7%A0%81utf-8-%E5%92%8Cgbk%E7%9A%84%E5%8C%BA%E5%88%AB)
- [7.什么时候使用字节流、什么时候使用字符流?](#7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E6%B5%81)
- [8.Java 中的 BIO,NIO,AIO 分别是什么?](#8java-%E4%B8%AD%E7%9A%84-bionioaio-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

#### 1.序列化与反序列化:
	1.1.ArrayList 如何实现序列化
		(1).为什么 transient Object[] elementData;
			ArrayList 实际上是动态数组，每次在放满以后自动增长设定的长度值,如果数组自动增长长度
			设为100,而实际只放了一个元素,那就会序列化 99 个 null 元素.为了保证在序列化的时候不
			会将这么多 null 同时进行序列化,	ArrayList 把元素数组设置为 transient
		(2).为什么要写方法:writeObject and readObject
			前面提到为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList 
			使用 transient 来声明elementData
			作为一个集合,在序列化过程中还必须保证其中的元素可以被持久化下来，
			所以,通过重写writeObject 和 readObject方法的方式把其中的元素保留下来
			writeObject方法把elementData数组中的元素遍历的保存到输出流（ObjectOutputStream）中。
			readObject方法从输入流（ObjectInputStream）中读出对象并保存赋值到elementData数组中
	1.2
#### 2.InputStream、OutputStream、Reader、Writer 的继承体系
#### 3.IO 框架主要用到什么设计模式:装饰模式
#### 4.NIO 包有哪些结构?分别起到的作用?
#### 5.NIO 针对什么情景会比 IO 有更好的优化?为什么使用NIO? NIO 有什么优势?
#### 6.String 编码UTF-8 和GBK的区别?
#### 7.什么时候使用字节流、什么时候使用字符流?
#### 8.Java 中的 BIO,NIO,AIO 分别是什么?
	(1).BIO:同步并阻塞,服务器实现模式为一个连接一个线程,即客户端有连接请求时服务器端就需要启动一个线程进行处理,如果这个连接
		不做任何事情会造成不必要的线程开销,当然可以通过线程池机制改善
		BIO 方式适用于连接数目比较小且固定的架构,这种方式对服务器资源要求比较高,并发局限于应用中,JDK1.4以前的唯一选择
	(2).NIO:同步非阻塞,服务器实现模式为一个请求一个线程,即客户端发送的连接请求都会注册到多路复用器上,多路复用器轮询到连接
		有 I/O 请求时才启动一个线程进行处理;
		NIO 方式适用于连接数多且连接比较短的架构,比如聊天服务器,并发局限于应用中,编程较复杂,JDK1.4后开始支持;
	(3).AIO:异步非阻塞,服务器实现模式为一个有效请求一个线程,客户端的 I/O 请求都是由OS先完成了在通知服务器应用去启动线程进行处理;
		AIO 的方式适用于连接数多且连接比较长的架构,JDK7 开始支持
