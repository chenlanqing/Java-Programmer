<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [1.OSI 七层模型,包括 TCP/IP 的一些基本知识](#1osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC-tcpip-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86)
- [2.TCP 协议](#2tcp-%E5%8D%8F%E8%AE%AE)
- [3.TCP 三次握手和四次挥手](#3tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
- [4.http是无状态通信,http的请求方式有哪些,可以自己定义新的请求方式么:](#4http%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E9%80%9A%E4%BF%A1http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%B9%88)
- [5.长连接与短连接? 分包如何处? 连接异常.](#5%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E5%88%86%E5%8C%85%E5%A6%82%E4%BD%95%E5%A4%84-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8)
- [6.socket通信模型的使用，AIO 和 NIO。](#6socket%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8aio-%E5%92%8C-nio)
- [7.socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。](#7socket%E6%A1%86%E6%9E%B6netty%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Anio%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E)
- [8.同步和异步,阻塞和非阻塞。](#8%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E)
- [9.http中,GET POST 的区别:](#9http%E4%B8%ADget-post-%E7%9A%84%E5%8C%BA%E5%88%AB)
- [10.说说 HTTP,UDP,TCP 之间关系和区别.](#10%E8%AF%B4%E8%AF%B4-httpudptcp-%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB)
- [11.说说浏览器访问www.taobao.com，经历了怎样的过程.](#11%E8%AF%B4%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEwwwtaobaocom%E7%BB%8F%E5%8E%86%E4%BA%86%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%87%E7%A8%8B)
- [12.HTTP 协议,HTTPS 协议,SSL 协议及完整交互过程；](#12http-%E5%8D%8F%E8%AE%AEhttps-%E5%8D%8F%E8%AE%AEssl-%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%8C%E6%95%B4%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B)
- [13.tcp的拥塞，快回传，ip的报文丢弃](#13tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E5%BF%AB%E5%9B%9E%E4%BC%A0ip%E7%9A%84%E6%8A%A5%E6%96%87%E4%B8%A2%E5%BC%83)
- [14.https处理的一个过程，对称加密和非对称加密](#14https%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86)
- [15.head各个特点和区别](#15head%E5%90%84%E4%B8%AA%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB)
- [16.DNS 解析:主要是将域名解析成IP地址](#16dns-%E8%A7%A3%E6%9E%90%E4%B8%BB%E8%A6%81%E6%98%AF%E5%B0%86%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%88%90ip%E5%9C%B0%E5%9D%80)
- [17.在不使用WebSocket情况下怎么实现服务器推送的一种方法:心跳检测](#17%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8websocket%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B)
- [18.浏览器缓存机制[](#18%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)
- [19.CDN 工作机制](#19cdn-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6)
- [20.负载均衡](#20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)
- [21.HTTP code:](#21http-code)
- [22.跨域问题:](#22%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1.OSI 七层模型,包括 TCP/IP 的一些基本知识
## 2.TCP 协议
## 3.TCP 三次握手和四次挥手
## 4.http是无状态通信,http的请求方式有哪些,可以自己定义新的请求方式么:
	GET,POST,PUT,DELETE
## 5.长连接与短连接? 分包如何处? 连接异常.
	// http://www.cnblogs.com/0201zcr/p/4694945.html
	// http://www.cnblogs.com/cswuyg/p/3653263.html
## 6.socket通信模型的使用，AIO 和 NIO。
## 7.socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。
## 8.同步和异步,阻塞和非阻塞。
## 9.http中,GET POST 的区别:
	// http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html
	(1).一般而言,GET 用于获取/查询数据,而 POST 用于更新资源信息;
	(2).根据HTTP规范,GET 用于信息获取,而且应该是安全的和幂等的,安全的意味着该操作用于获取信息而非修改信息.
		幂等的意味着对同一URL的多个请求应该返回同样的结果
	(3).根据HTTP规范,POST 表示可能修改变服务器上的资源的请求.
	(4).GET 请求的数据会附在URL之后,就是把数据放置在HTTP协议头中,以?分割URL和传输数据,参数之间以&相连;
		POST 把提交的数据则放置在是HTTP包的包体中
	(5).GET 是通过URL提交数据,那么GET可提交的数据量就跟URL的长度有直接关系了.实际上,URL 不存在参数上限的问题,
		HTTP 协议规范没有对URL长度进行限制.这个限制是特定的浏览器及服务器对它的限制.
		IE 对URL长度的限制是2083字节(2K+35);
	(6).POST 是没有大小限制的,HTTP 协议规范也没有进行大小限制;
	(7).POST 的安全性要比GET的安全性高
## 10.说说 HTTP,UDP,TCP 之间关系和区别.
## 11.说说浏览器访问www.taobao.com，经历了怎样的过程.
## 12.HTTP 协议,HTTPS 协议,SSL 协议及完整交互过程；
## 13.tcp的拥塞，快回传，ip的报文丢弃
## 14.https处理的一个过程，对称加密和非对称加密
## 15.head各个特点和区别
## 16.DNS 解析:主要是将域名解析成IP地址
	
## 17.在不使用WebSocket情况下怎么实现服务器推送的一种方法:心跳检测

## 18.浏览器缓存机制[
	http://blog.csdn.net/longxibendi/article/details/41630389]
	18.1.浏览器缓存控制机制有两种:HTML Meta 标签 vs. HTTP 头信息
		(1).HTML Meta 标签控制缓存:
			浏览器缓存机制,其实主要就是HTTP协议定义的缓存机制,如:Expires, Cache-control等
			但是也有非HTTP协议定义的缓存机制,如使用HTML Meta 标签,Web 开发者可以在HTML页面的<head>节点中加入<meta>标签
			<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
		(2).HTTP 头信息控制缓存:
			浏览器第一次请求:/Java知识点/Java/JavaEE/浏览器第一次请求流程图.png
			浏览器再次请求时:/Java知识点/Java/JavaEE/浏览器请求流程.png
	18.2.几个重要概念:
		(1).Expires 策略:
			Expires 是Web服务器响应消息头字段,在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而无需再次请求
			Expires 是HTTP 1.0的东西,现在默认浏览器均默认使用HTTP 1.1,所以它的作用基本忽略;
			Expires 的一个缺点就是:返回的到期时间是服务器端的时间;
			在HTTP 1.1版开始,使用 Cache-Control: max-age=秒替代;
		(2).Cache-control策略:
			Cache-Control与 Expires的作用一致,都是指明当前资源的有效期,控制浏览器是否直接从浏览器缓存取数据还是重新发
				请求到服务器取数据.如果同时设置的话,其优先级高于Expires;
			值可以是:public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age
			各个消息中的指令含义如下:
				A.public:指示响应可被任何缓存区缓存.
				B.private:指示对于单个用户的整个或部分响应消息.不能被共享缓存处理.
					这允许服务器仅仅描述当用户的部分响应消息.此响应消息对于其他用户的请求无效。
				C.no-cache:指示请求或响应消息不能缓存,该选项并不是说可以设置"不缓存".容易望文生义.
				D.no-store:用于防止重要的信息被无意的发布.在请求消息中发送将使得请求和响应消息都不使用缓存,完全不存下來.
				E.max-age:指示客户机可以接收生存期不大于指定时间(以秒为单位)的响应.
				F.min-fresh:指示客户机可以接收响应时间小于当前时间加上指定时间的响应.
				G.max-stale:指示客户机可以接收超出超时期间的响应消息.如果指定max-stale消息的值,
					那么客户机可以接收超出超时期指定值之内的响应消息
		(3).Last-Modified/If-Modified-Since:Last-Modified/If-Modified-Since 要配合 Cache-Control 使用.
			Last-Modified:标示这个响应资源的最后修改时间.web服务器在响应请求时,告诉浏览器资源的最后修改时间.
			If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)发现资源具有 Last-Modified声明,则再次向web服务器请求
				时带上头 If-Modified-Since,表示请求时间.web服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修改时
				间进行比对.若最后修改时间较新,说明资源又被改动过,则响应整片资源内容(写在响应消息包体内)HTTP 200;
				若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包体，节省浏览),告知浏览器继续使用所保存的cache;
		(4).Etag(实体标识):使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新,为什么还需要Etag?
			HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题:
				Last-Modified 标注的最后修改只能精确到秒级,如果某些文件在1秒钟以内,被修改多次的话,它将不能准确标注文件的修
				改时间如果某些文件会被定期生成,当有时内容并没有任何变化,但 Last-Modified 却改变了,导致文件没法使用缓存
				有可能存在服务器没有准确获取文件修改时间,或者与代理服务器时间不一致等情形
			Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符,能够更加准确的控制缓存.
			Last-Modified 与 ETag一起使用时,服务器会优先验证ETag
	18.3.几种状态码的区别:
		(1).200 状态:当浏览器本地没有缓存或者下一层失效时,或者用户点击了 CTRL+F5 时,浏览器直接去服务器下载最新数据;
		(2).304 状态:这一层由 Last-Modified/ETag 控制.当下一层失效时或用户点击refresh,F5时,浏览器就会发送请求给服务器,
			如果服务器端没有变化,则返回304给浏览器;
		(3).200 (form cache):这一层由 expire/cache-control 控制,expires(http1.0有效)是绝对时间,cache-control(http1.1)相对时间,
			两者都存在时,cache-control 覆盖 expires,只要没有失效,浏览器只访问自己的缓存.
	18.4.用户行为与缓存:
		用户行为 	|Expires/Cache-Control| Last-Modified/Etag	
		地址栏回车		有效					有效
		页面链接跳转	有效					有效
		新开窗口		有效					有效
		前进/后退		有效					有效
		F5刷新			无效(BR重置max-age=0)	有效
		Ctrl+F5刷新		无效(重置CC=no-cache)	无效
## 19.CDN 工作机制

## 20.负载均衡

## 21.HTTP code	
## 22.跨域问题
	


