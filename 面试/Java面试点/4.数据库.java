说明:以 MySQL 为主
1.怎么理解事务? 数据库事务特性(ACID)
	1.1.事务:
	1.2.事务特性:ACID
		(1).原子性-Atomicity:
			事务包含的所有操作要么全部成功,要么全部失败回滚
		(2).一致性-Consistency:
			事务必须使数据库从一个一致性状态变换到另一个一致性状态,
			也就是说一个事务执行之前和执行之后都必须处于一致性状态
		(3).隔离性-Isolation:多个并发事务之间要相互隔离,不能相互影响
		(4).持久性-Durability:一个事务一旦被提交了,那么对数据库中的数据的改变就是永久性的
2.数据库隔离级别介绍、举例说明:http://www.cnblogs.com/fjdingsd/p/5273008.html
	2.1.不考虑隔离性发生的问题:
		(1).脏读:指在一个事务处理过程里读取了另一个未提交的事务中的数据;
		(2).不可重复读:在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据值,
			这是由于在查询间隔,被另一个事务修改并提交了;
			==> 脏读是某一事务读取了另一个事务未提交的脏数据,而不可重复读则是读取了前一事务提交的数据
		(3).虚读(幻读):事务非独立执行时发生的一种现象
	2.2.事务隔离级别有4个,由低到高依次,级别越高执行效率越低
		(1).Read uncommitted(未授权读取、读未提交):
			如果一个事务已经开始写数据,则另外一个事务则不允许同时进行写操作,但允许其他事务读此行数据.
			该隔离级别可以通过“排他写锁”实现.最低级别,任何情况都无法保证
		(2).Read committed(授权读取、读提交):
			该隔离级别避免了脏读,但是却可能出现不可重复读
			读取数据的事务允许其他事务继续访问该行数据,但是未提交的写事务将会禁止其他事务访问该行
		(3).Repeatable read(可重复读取):可避免脏读、不可重复读的发生
			读取数据的事务将会禁止写事务(但允许读事务),写事务则禁止任何其他事务.
			避免了不可重复读取和脏读,但是有时可能出现幻读.这可以通过“共享读锁”和“排他写锁”实现
		(4).Serializable(序列化):
			提供严格的事务隔离.它要求事务序列化执行.事务只能一个接着一个地执行,但不能并发执行。
	2.3.隔离级别越高,越能保证数据的完整性和一致性,但是对并发性能的影响也越大.对于多数应用程序,
		可以优先考虑把数据库系统的隔离级别设为 Read Committed.它能够避免脏读取,而且具有较好的并发性能.
		可以通过悲观锁和乐观锁来控制不可重复读,幻读等并发问题.
	2.4.大多数数据库的默认级别就是 Read committed,比如 Sql Server , Oracle
		MySQL 的默认隔离级别就是 Repeatable read.
		mysql中查看事务隔离级别:select @@tx_isolation;
			set  [glogal | session]  transaction isolation level 隔离级别名称;
		    set tx_isolation=’隔离级别名称;’
3.海量数据,如何进行查询优化?方案
4.数据库中的范式有哪些
5.什么情况下适合创建索引?什么情况下设置了索引但无法使用?
	5.1.创建索引的情况:
		(1).经常出现在关键字 order by,group by, distinct 后面的字段;
		(2).在 union 等集合操作的结果集上建立索引;
		(3).为经常用作查询选择的字段建立索引;
		(4).在经常考虑用作表连接的属性上建立索引;
		(5).考虑使用索引覆盖,对数据很少被更新的表,如果用户经常只查询其中的几个字段,
			可以考虑在这几个字段上建立索引,从而将表的扫描改变为索引的扫描
	5.2.索引失效:
		(1).如果条件中有or,即使其中有条件带索引,也不会使用(尽量少用or); 
		(2).Like 查询是以 %开头,例如SELECT * FROM mytable WHEREt Name like’%admin’,会导致全文搜索
		(3).如果列类型是字符串,那一定要在条件中使用引号引起来,否则不会使用索引;
		(4).应尽量避免在 where 子句中使用!=或<>操作符
		(5).in 和 not in 也要慎用，否则会导致全表扫描
	5.3.索引的限度:
		索引并不是越多越好,索引固然可以提高相应的 select 的效率,但同时也降低了 insert 及 update 的效率,
		因为 insert 或 update 时有可能会重建索引,所以怎样建索引需要慎重考虑,视具体情况而定.
		一个表的索引数最好不要超过6个.
	5.4.索引的特点:
		(1).可以加快数据库的检索速度;
		(2).降低数据库的插入,修改,删除等维护的速度;
		(3).只能创建到表上,不能创建到视图上;
		(4).既可以直接创建又可以间接创建;
		(5).可以在优化隐藏中使用索引
		(6).使用查询处理器知识SQL语句,在一个表上,一次只能使用一个索引;
	5.5.索引的优点:
		(1).创建唯一性索引,保证数据表中每一行数据的唯一性;
		(2).大大加快数据的检索速度,这是创建索引的最主要的原因;
		(3).加快数据库表之间的连接,特别是在实现数据的参考完整性方面有意义;
		(4).在使用分组和排序字句进行数据检索时,同样可以显著减少系统的查询中分组和排序的时间
	5.6.索引的缺点:
		(1).创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加;
		(2).索引需要占用物理空间,除了数据表占用数据空间之外,每个表还需要占用一定的物理空间;
		(3).当对表中的数据进行增删改时,索引也需要维护,降低数据维护的速度
	5.7.索引分类:
		(1).普通索引(它没有任何限制.) 
		(2).唯一性索引(索引列的值必须唯一,但允许有空值.) 
		(3).主键索引(一种特殊的唯一索引,不允许有空值.一般是在建表的时候同时创建主键索引.) 
		(4).组合索引 
		(5).聚集索引 按照每张表的主键构造一颗B+树,并且叶节点中存放着整张表的行记录数据,因此也让聚集索引的叶节点成为数据页. 
		(6).非聚集索引(辅助索引)(页节点不存放一整行记录).
6.数据库中的索引的结构有哪些结构,索引底层是如何实现的?
	http://blog.codinglabs.org/articles/theory-of-mysql-index.html
	6.1.索引的结构:
		因为在使用二叉树的时候,由于二叉树的深度过大而造成I/O 读写过去频繁,进而导致查询效率低下.因此采用多路数据结构,
		B 树的各种操作能使B树保持低的高度
	6.2.
	6.3.
	6.4.各引擎支持的索引:MyISAM,InnoDB,Memonry 三个常用MySQL引擎类型比较
		|索引 			|MyISAM 索引 |InnoDB 索引 |Memonry 索引|
		|------------------------------------------------------|
		|B-tree索引 	|支持		 |支持		  |支持        |
		|Hash索引   	|不支持		 |不支持	  |支持        |
		|R-tree索引 	|支持		 |不支持	  |不支持      |
		|Full-text索引 	|不支持		 |暂不支持	  |不支持      |
		+------------------------------------------------------+
6.MySQL 的explain 分析函数,数据库慢执行的指标;
7.数据库水平拆分和垂直拆分、分库/分表;分库/分表中主键问题
8.纵表的用途
9.ER 模型是怎么样的
10.锁:共享锁,互斥锁,死锁.如何会发生死锁,如何解决死锁问题
11.MySQL 的数据库引擎:MyISAM 和 InnoDB 引擎的区别:
	11.1.主要区别:
		(1).MyISAM 是非事务安全型的, InnoDB 是事务安全型的;
		(2).MyISAM 锁的粒度是表级锁, InnoDB 是支持行级锁的;
		(3).MyISAM 支持全文本索引,而InnoDB不支持全文索引
		(4).MyISAM 相对简单,所以在效率上要优于 InnoDB,小型应用可以考虑使用 MyISAM;
		(5).MyISAM 表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦;
		(6).InnoDB 表比 MyISAM 表更安全,可以在保证数据不丢失的情况下,切换非事务表到事务表；
	11.2.适用场景:
		(1).MyISAM 管理非事务表,它提供高速存储和检索,以及全文搜索能力,如果应用中需要执行大量的select查询,那么MyISAM是更好的选择
		(2).InnoDB 用于事务处理应用程序,具有众多特性,包括ACID事务支持.如果应用中需要执行大量的insert或update操作,
			则应该使用 InnoDB,这样可以提高多用户并发操作的性能
12.MySQL 主从与读写分离技术
13.数据库的连接池原理