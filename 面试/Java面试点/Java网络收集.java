1.Java 的四个基本特性(抽象、封装、继承、多态),对多态的理解(多态的的实现方式)以及在项目中哪些地方使用多态?
	1.1.Java的四个基本特性:
		(1).抽象:抽象是将一类对象的共同特征总结出来构造类的过程,包括数据抽象和行为抽象两方面.抽象只关注对象的有哪些属性和行为,
			并不关注这些行为的细节是什么.
		(2).继承:继承是从已有类中得到继承信息并创建新类的过程.提供继承信息的类被称为父类;得到继承信息的类被称为子类.
			继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的重要手段;
		(3).封装:通常认为封装是把数据和操作数据的方法绑定起来,对数据的访问只能通过已定义的接口;面向对象的本质就是:将现实世界
			描绘成一系列完全自然、封闭的对象.在类中的编写的方法就是对实现细节的一种封装;编写一个类就是对数据和数据操作的封装;
			可以说封装就是隐藏一切可以隐藏的东西,只向外界提供最简单的编程接口;
		(4).多态:指允许不同子类型的对象对同一消息作出不同的响应;
	1.2.多态:
		(1).方法重载:实现是编译时多态
		(2).方法重写:实现是运行时多态
			用父类型引用子类的子类型对象,同样的引用调用同样的方法会根据子类对象的不同而表现出不同的行为;
	1.3.多态的使用:
		工厂模式

2.面向对象和面向过程的区别:
	/**
	 * 参考:http://www.cnblogs.com/fuleying/archive/2011/08/09/2131647.html
	 */
	(1).面向过程需要考虑整个过程的实现,面向对象只需要知道其工作原理;
	(2).面向过程是一种以事件为中心的编程思想,就是分析出解决问题所需的步骤,然后用函数把这些步骤实现并按顺序调用;
		面向对象是以对象为中心的编程思想;
	(3).简单的举个例子:汽车发动、汽车到站
        这对于“面向过程”来说,是两个事件,汽车启动是一个事件,汽车到站是另一个事件,面向过程编程的过程中我们关心的是事件,
		而不是汽车本身.针对上述两个事件,形成两个函数,之后依次调用;
		然而这对于面向对象来说,我们关心的是汽车这类对象,两个事件只是这类对象所具有的行为.而且对于这两个行为的顺序没有强制要求
	(4).面向过程就是分析出解决问题所需的步骤;面向对象则是把构成问题的事物分解成对象,抽象出对象的目的并不在于完成某个步骤,
		而是描述其再整个解决问题的步骤中的行为;
	(5).面向过程的思维方式是分析综合,面向对象的思维方式是构造;
	(6).对比 蛋炒饭 和 盖浇饭	

3.面向对象开发的基本原则?如何使用这些原则?迪米特法则?
	3.1.五大基本原则:(S.O.L.I.D)
		(1).单一职责:The Single Responsibility Principle:
			一个类只做它该做的事情.在面向对象中,如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚原则
		(2).开放闭合原则:The Open Closed Principle
			对扩展开放,对修改封闭.抽象是关键:
			①.对扩展开放,意味着有新的需求或变化时,可以对现有代码进行扩展,以适应新的情况
			②.对修改封闭,意味着类一旦设计完成,就可以独立完成其工作,而不要对其进行任何尝试的修改
		(3).里氏替换:The Liskov Substitution Principle
			任何时候子类都可以替换掉父类型.子类一定是增加父类的行为.
		(4).依赖倒置:The Dependency Inversion Principle
			具体而言就是高层模块不依赖于底层模块,二者都同依赖于抽象;抽象不依赖于具体,具体依赖于抽象;
		(5).接口隔离:The Interface Segregation Principle
			使用多个小的专门的接口,而不要使用一个大的总接口
		(6).合成聚合复用:尽可能多的使用合成聚合,少用继承
	3.2.迪米特法则:一个对象应该对其他对象有尽可能少的了解
		(1).狭义的迪米特法则:
			如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用;
			如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用
		(2).广义的迪米特法则:
			对对象之间的信息流量、流向以及信息的影响进行控制
			充分体现封装的概念
			具体应用时,需注意
		
4. static 和 final 的区别和用途:
	4.1.static:
		修饰变量:静态变量是随着类加载时完成初始化,内存中只有一个,且JVM只会为它分配一次内存,所有类共享静态变量;
		修饰方法:在类加载的时候就存在,不依赖任何实例;static 方法必须实现,不能使用 abstract 修饰;
		静态代码块:在类加载完之后就会执行代码块的内容
		父类静态代码块->子类静态代码块->父类非静态代码块->父类构造方法->子类非静态代码块->子类构造方法
	4.2.final:

5.HashMap 和 HashTable 的区别? HashMap 中key可以是任何对象和数据类型吗?线程安全性呢?
	5.1.区别:
		HashMap 是非线程安全的,HashTable 是线程安全的
		(1).HashTable 使用 Enumeration, HashMap 使用 Iterator;
		(2).哈希值使用不同, HashTable 直接使用对象的 hashcode;而 HashMap 重写计算hash值,而且用于代替求模;
		(3).HashTable 中 hash数组默认大小是11,增加方式是 old*2+1.HashMap 中hash数组的默认大小是16,而且一定是2的指数;
		(4).HashTable 是基于 Dictionary 类,而 HashMap 是基于 AbstractMap
	5.2.可以是 null 类型,但不能是可变对象,如果是可变对象,当对象内的属性改变时,会重新计算 hashcode,导致无法查找对应的值

6.HashMap 和 ConcurrentHashMap? ConcurrentHashMap 如何保证线程安全
	6.1.区别:
		(1).HashMap 不是线程安全的,ConcurrentHashMap 是线程安全的
		(2).ConcurrentHashMap 将整个 Hash 桶进行了分段 Segment,也就是将这个大的数组分成了几个 Segment,而且每个小的片段
			Segment 上面都有锁存在,那么在插入元素的时候需要找到应该插入哪一个片段 Segment,然后在这个片段上进行插入,
			而且这里需要获取 Segment 锁
	6.2.ConcurrentHashMap 如何保证线程安全:	(散列算法,链表数据结构)	
		// 参考:http://www.infoq.com/cn/articles/ConcurrentHashMap
		// https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/
		(1).HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁;
			那假如容器里有多把锁,每一把锁用于锁容器其中一部分数据,那么当多线程访问容器里不同数据段的数据时,线程间就
			不会存在锁竞争,从而可以有效的提高并发访问效率,这就是 ConcurrentHashMap 所使用的锁分段技术,首先将数据分成
			一段一段的存储,然后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问;
		(2).get操作的高效之处在于整个get过程不需要加锁,除非读到的值是空的才会加锁重读,
			它的get方法里将要使用的共享变量都定义成volatile,如用于统计当前 Segement 大小的count字段和用于存储值的
			HashEntry 的value.定义成volatile的变量,能够在线程之间保持可见性,能够被多线程同时读,并且保证不会读到
			过期的值,但是只能被单线程写(有一种情况可以被多线程写,就是写入的值不依赖于原值),在get操作里只需要读不
			需要写共享变量count和value,所以可以不用加锁
		(3).put方法首先定位到 Segment,然后在 Segment里进行插入操作.插入操作需要经历两个步骤:
			第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容,第二步定位添加元素的位置然后放在 HashEntry 数组里
	
7.如果别人知道源码是怎么实现的,故意构造相同的 hash 的字符串进行攻击,如何处理?在JDK7中如何处理?
	7.1.如何处理构造相同 hash 的字符串进行攻击:
		(1).当客户端提交一个请求并附带参数的时候,web应用服务器会把参数转换成一个 HashMap 存储,这个 HashMap 的逻辑结构:
			key1 -> value1
		(2).但是物理存储结构是不同的,key值会变转换成 hashcode,这个hashcode又会被转化成数组的下标: 0--> value1
		(3).不同的 string 就会产生相同的 hashcode而导致碰撞,碰撞后的物理存储结构可能如下: 0->value1->value2
		(4).所以:
			需要限制 post 和 get 的参数的个数,越少越好
			限制post数据包的大小
			WAF(Web Application Firewall)
	7.2.JDK7的处理方式:
		HashMap 会动态的使用一个专门的 TreeMap 实现来替换它

8.String,StringBuffer,StringBuilder区别以及对 String 不变的理解:
	8.1.区别:
		(1).都是 final 类,不允许被继承
		(2).String 长度是不可变的, StringBuffer 和 StringBuilder 长度是可变的;
		(3).StringBuffer 是线程安全的,StringBuffer 和 StringBuilder 所有方法都是一样的,只是 StringBuffer 方法都加上了
			synchronized 修饰确保线程安全;
		(4).StringBuilder 性能优于 StringBuffer;
		(5).如果在编译期能确认是一个字符串常量,字符串会自动拼接成一个常量,此时 String 拥有更好的性能
	8.2.String 不变性理解:
		(1).String 类是被 final 修饰的,不能被继承;
		(2).使用 + 连接字符串的时候会创建新的字符串;
		(3).String s = new String("Hello world"); 可能创建两个对象或一个对象;如果静态常量池中有"Hello world"的字符串常量的话,
			则仅仅在堆中创建一个对象;如果静态常量池中不存在"Hello world",则堆和静态常量池中都会创建对象;
		(4).使用 + 连接实际上是转换成 StringBuilder 的实例调用 append()方法来实现;	

9.如果一个类重写了 equals 方法但没有重写 hashcode 会出现什么问题?
	在存储散列表时,如果原对象 equals 新对象,但没有对 hashcode 重写,即两个对象拥有不用的 hashcode,则在集合中将会存储
	两个值相同的对象,从而导致混淆;所以,如果重写 equals方法必须重写 hashcode方法
	public boolean equals(Object obj) {
        return (this == obj);
    }

10.Java 序列化? 如何实现序列化与反序列化? 常见的序列化协议?
	10.1.Java 序列化:
		将实现了 Serializable 接口的对象转换成一个字节序列,并能够在以后将这个字节序列完全恢复成原来的对象,
		序列化可以弥补不同操作系统之间的差异;
	10.2.Java 序列化的作用:
		Java 远程方法的调用(RMI)
		对 JavaBeans 进行序列化
	10.3.实现序列化与反序列化:
		10.3.1.实现序列化:
			(1).实现 Serializable 接口,该接口是一个可序列化的标志,没有任何属性和方法;如果不在类中添加 
				readeObject()和writeObject()方法,则采用默认的序列化机制;如果添加了这两个方法,还想使用默认的序列化机制,
				则在这两个方法中分别调用defaultReadObject()和defaultWriteObject()
			(2).为了保证安全性,可以使用 transient 关键字进行修饰不必序列化的对象,在序列化时,private 修饰的属性也能查看到;
			(3).实现 Externalizable,自己要对序列化内容进行控制,控制哪些属性可以被序列化,哪些不能被序列化
		10.3.2.反序列化:
			(1).实现 Serializable 接口的对象在反序列化时不需要调用对象所在类的构造方法,完全基于字节,
				如果是子类继承父类的序列化,那么将调用父类的构造方法;
			(2).实现 Externalizable  接口的对象在反序列化时会调用构造方法
	10.4.注意:
		(1).被 static ,final 修饰的属性不会被序列化;
		(2).对象的类名,属性都会被序列化;
		(3).如果父类实现了 Serializable 接口,子类但没有实现 Serializable 接口,子类拥有一切可序列化相关的特性,子类可以序列化;
		(4).如果子类实现 Serializable 接口,父类不实现,根据父类序列化规则,父类的字段数据将不被序列化,从而达到部分序列化的功能;
			在反序列化时仍会调用父类的构造器,只能调用父类的无参构造函数作为默认的父对象
		(5).当通过网络,文件进行序列化时,必须按照写入顺序读取对象;
		(6).反序列化时必须要有序列化对象时的class文件;
		(7).显示的声明 serialVersionUID,因为在不同的 jvm 之间,默认生成的 serialVersionUID 可能不同,造成反序列化失败;
	10.5.常見的序列化协议:
		// http://www.tuicool.com/articles/IVJFjiR
		(1).COM:主要用于windows 平台,并没有实现跨平台,其序列化原理是利用编译器中的虚表
		(2).CORBA:早期比较好的实现了跨平台,跨语言的序列化协议,COBRA 的主要问题是参与方过多带来的版本过多,
			版本之间兼容性较差,以及使用复杂晦涩;
		(3).XML&SOAP:
			XML 是一种常用的序列化和反序列化协议,具有跨机器,跨语言等优点;
			SOAP(Simple Object Access protocol)是一种被广泛应用的,基于XML为序列化和反序列化协议的结构化消息传递协议;
			SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议
		(4).JSON(Javascript Object Notation)
			①.这种Associative array格式非常符合工程师对对象的理解;
			②.它保持了XML的人眼可读(Human-readable)的优点;
			③.相对xml而言,序列化都的数据更简洁;
			④.它具备Javascript的先天性支持,所以被广泛应用于Web browser的应用常景中,是Ajax的事实标准协议;
			⑤.与XML相比，其协议比较简单，解析速度比较快;
			⑥.松散的Associative array使得其具有良好的可扩展性和兼容性
		(5).Thrift:是 Facebook 开源提供的一个高性能,轻量级 RPC 服务框架,其产生正是为了满足当前大数据量、分布式、跨语言、
			跨平台数据通讯的需求;其并不仅仅是序列化协议,而是一个 RPC 框架;
			由于Thrift的序列化被嵌入到Thrift框架里面,Thrift框架本身并没有透出序列化和反序列化接口,
			这导致其很难和其他传输层协议共同使用;		
		(6).Protobuf:
			①.标准的IDL和IDL编译器，这使得其对工程师非常友好;
			②.序列化数据非常简洁,紧凑,与XML相比,其序列化之后的数据量约为1/3到1/10;
			③.解析速度非常快，比对应的XML快约20-100倍;
			④.提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码;

11.Java 创建线程的方式? 有什么不同之处?
	// http://blog.csdn.net/longshengguoji/article/details/41126119
	11.1.三种创建线程的方式:
		(1).继承 Thread 类创建线程类,实现 run 方法;
		(2).通过 Runnable 接口创建线程类,实现 run 方法;
			new Thread(new MyRunnable()).start();
		(3).实现 Callable 接口,实现call()方法,使用 FutureTask 类来包装 Callable 对象,FutureTask 对象封装了该 Callable 
			对象的call()方法的返回值;使用 FutureTask 对象作为 Thread 对象的target创建并启动新线程
			FutureTask<Integer> task = new FutureTask<>(new MyCallable());
	11.2.三种创建线程的不同之处:
		(1).实现 Runnable 接口可以避免Java单继承特性而带来的局限性;增强程序的健壮性,代码能够被多个线程共享,代码与数据是独立的;
			适合多个相同程序代码的线程去处理同一资源的情况;
		(2).继承 Thread 类和实现 Runnable 方法启动线程都是使用 start 方法;
		(3).实现 Callable 接口要实现 call 方法,并且线程执行完毕后会有返回值,其他的两种都是重写run方法,没有返回值;

12.线程安全:
	12.1.定义:
		(1).某个类的行为与其规范一致;
		(2).不管多个线程是怎样的执行顺序和优先级,或是 wait,sleep,join等控制方式,如果一个类在多线程访问下运转一切正常,
			并且访问类不需要进行额外的同步处理或者协调,那么认为其就是线程安全的;
	12.2.如何保证线程安全:
		对变量使用 volitale
		对程序进行加锁

13.多线程共用一个数据变量需要注意什么?
	(1).当我们在线程对象中定义了全局变量,run 方法会修改变量时,如果有多个线程同时使用该线程对象,那么就会造成全局变量的
		值被同时修改,造成错误;
	(2).ThreadLocal 是JDK引入的一种机制,它用于解决线程间共享变量,使用 ThreadLocal 声明的变量,即使在线程中属于全局变量,
		针对每个线程来说,这个变量也是独立的;
	(3).volatile 变量每次被线程访问时,都强迫线程从主内存中重读该变量的最新值,而当该变量发生变化时,也会强迫线程将最新的
		值刷新回主内存中.这样一来,不同的线程都能及时看到该变量的最新值;

14.什么是线程池?如何设计一个动态大小的线程池?
	14.1.线程池:事先创建若干个可执行的线程放入一个池中,需要的时候从池中获取线程而不用自行创建
		使用完毕不要销毁线程而是放回池中,从而减少创建和销毁线程对象的开销
	14.2.设计一个动态大小的线程池:
		14.2.1.一个线程池包括以下四个基本组成部分:
			(1).线程管理器(ThreadPool):用于创建并管理线程池,包括:创建线程,销毁线程,添加新任务
			(2).工作线程(PoolWorker):线程池中的线程,在没有任务时处于等待状态,可以循环的执行任务;
			(3).任务接口(Task):每个任务必须实现的接口,以供工作线程调度任务的执行,它规定了主要任务的入口,任务执行完后的
				收尾工作,任务的执行状态等;
			(4).任务队列(TaskQueue):用于存放没有处理的任务,提供一种缓冲机制
		14.2.2.包含的方法:
			(1).private ThreadPool():创建线程池
			(2).public static ThreadPool getThreadPool():获取一个默认线程个数的线程池
			(3).public void execute(Runnable task):执行任务,其实只是把任务加入任务队列,什么时候执行由线程池管理器决定
			(4).public void execute(Runnable[] task):批量执行任务,其实只是把任务加入任务队列,什么时候执行由线程池管理器决定
			(5).public void destroy():销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有的线程,否则等待任务完成才销毁
			(6).public int getWorkThreadNumber():返回工作线程的个数;
			(7).public int getFinishedTaskNumber():返回已完成任务的个数.这里已完成只是出了任务队列的任务个数,可能实际还没完成;
			(8).public void addThread():在保证线程池中所有线程正在执行,并且要执行线程的个数大于某一值时,增加线程池中线程的个数;
			(9).public void reduceThread():在保证线程池中有很大一部分线程处于空闲状态,并且空闲状态的线程小于某个值时,减少线程;

15.java.util.concurrent 包下类:
	Executor
	FutureTask
	TimeUnit
	Semaphore
	LinkedBlockingQueue

16.volatile 关键字如何保证内存可见性:
	16.1.volitile 关键字的作用:
		(1).保证内存的可见性
		(2).防止指令重排序
		(3).注意:volatile并不保证原子性
	16.2.内存可见性:每次访问变量时都会进行一次刷新,因此每次访问的都是主内存中最新的版本,保证变量修改的实时可见性
	16.3.当且仅当满足一下所有条件时,才应该使用 volatile 变量:
		(1).对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值
		(2).该变量没有包含在具有其他变量的不变式中;
	16.4.使用建议:
		(1).在两个或者更多的线程需要访问的成员变量上使用 volatile.当要访问的变量已在 synchronized 代码块中或者为常量时,
			没有必要使用 volatile;
		(2).由于使用volatile屏蔽掉了JVM中必要的代码优化,所以在效率上较低.
	16.5.volatile 和 synchronized 区别:
		(1).volatile 不会进行加锁操作:
			volatile 变量时一种稍弱的同步机制,在访问 volatile 变量时不会执行加锁操作,因此也不会使执行线程阻塞,因此
			volatile变量时一种比 synchronized 更轻量级的同步机制;
		(2).volatile 变量作用类似同步变量的读写操作:
			从内存可见性的角度看,写入 volatile 变量相当于退出同步代码块,而读取volatile变量相当于进入代码块
		(3).volatile 不如 synchronized 安全:
			在代码中如果过度依赖volatile变量来控制状态的可见性,通常会比使用锁的代码脆弱.仅当volatile变量能简化代码的实现
			以及对同步策略的验证时,才应该使用它
		(4).volatile 无法同时保证内存可见性和原子性
			加锁机制既可以确保可见性又可以确保原子性,而volatile只能确保可见性.原因是:声明为volatile的简单变量如果当前值
			与该变量以前的值相关,那么volatile关键字不起作用,如:count++,不是原子操作

17.sleep 和 wait分别是哪个类的方法,有什么区别?
	(1).sleep: 是 Thread 类的静态方法
		调用此方法会让当前线程暂停执行指定的时间,将执行机会(CPU)让给其他线程,但是对象的锁依然保持,因此休眠结束后会自动恢复;
	(2).wait: 是 Object 类的方法
		调用对象的 wait 方法导致当前线程放弃对象的锁(线程暂停执行),进入对象的等待池,只有调用的对象的 notify(notifyAll)
		时才能唤醒等待池中的线程进入等锁池,如果线程重新获得对象的锁就可以进入就绪状态:
	==> 为什么 wait 方法要定义在 Object 类中?
		因为这些方法在操作同步线程时,都必须要标识它们操作线程的锁,只有同一个锁上的被等待线程,可以被同一个锁上的notify唤醒,
		不可以对不同锁中的线程进行唤醒,等待和唤醒必须是同一个锁.
		而锁可以是任意对象,所以可以被任意对象调用的方法是定义在 Object 类中.
		而:jdk1.5以后提供了 Lock 接口和 Condition 对象,Condition 中的await(), signal().signalAll()代替 
			Object 中的wait(),notify(),notifyAll()

18.synchronized 与 Lock 的区别,使用场景.
	(1).用法-synchronized 隐式锁:在需要同步的对象中加入此控制,synchronized 可以加在方法上,也可以加在特定的代码块中,
		括号表示需要锁的对象;
	(2).用法-Lock(显示锁):需要显示指定起始位置和终止位置.一般使用 ReentrantLock 类作为锁,多个线程中必须要使用一个
		ReentrantLock 类作为对象才能保证锁的生效.且在加锁和解锁处需要通过lock()和unlock()显示指出,所以一般
		在 finally 中写 unlock(),以防死锁
	(3).性能:synchronized 是托管给 JVM 执行的,而 Lock 是Java写的控制锁的代码,在Java1.5中, synchronized 是低效的.
		因为这是一个重量级的操作,需要调用操作接口,导致有可能加锁消耗的时间比加锁以外的操作还多.相比之下使用 Java 提供的
		Lock 对象,性能更高一些.到了1.6之后,synchronized 在语义上很清晰,可以进行很多优化,有适应自旋、锁消除、锁粗化、轻量级锁、
		偏向锁等待,在JDK1.6后,synchronized 与 Lock 在性能上相当
	(4).机制:synchronized 原始采用的是 CPU 悲观锁机制,即线程获得是独占锁.独占锁意味着其他线程只能依靠阻塞来等待线程释放锁.
		Lock 用的是乐观锁方式.所谓乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,
		直到成功为止.乐观锁实现的机制就是CAS(Compare and Swap)操作

19.synchronized 底层是如何实现的?用在代码块和方法上有什么区别?
	19.1.底层实现:

	19.2.用在代码块和方法上的区别:
		(1).synchronized 用在代码块锁的是调用该方法的对象(this),也可以选择锁任何一个对象;
		(2).synchronized 用在方法上锁的是调用该方法的对象
		(3).synchronized 用在代码块上可以减少锁的粒度,从而提高并发性能;
		(4).无论用在代码块上还是方法上,都是获取对象的锁,每一个对象只有一个锁与之相关联;实现同步需要很大的系统开销作为代价,
			甚至可能造成死锁,所以尽量避免无谓的同步控制;
	19.3.synchronized 和 static synchronized 的区别:
		(1).synchronized 是对类的当前实例进行加锁,防止其他线程同时访问该类的该实例的所有 synchronized 块,同一个类的两个不同
			实例就没有这种约束
		(2).static synchronized 恰好就是要控制类的所有实例的访问,static synchronized 是限制线程同时访问 jvm 中该类的所有实例
			同时访问对应的代码块

20.Java 中的 BIO,NIO,AIO 分别是什么?
	(1).BIO:同步并阻塞,服务器实现模式为一个连接一个线程,即客户端有连接请求时服务器端就需要启动一个线程进行处理,如果这个连接
		不做任何事情会造成不必要的线程开销,当然可以通过线程池机制改善
		BIO 方式适用于连接数目比较小且固定的架构,这种方式对服务器资源要求比较高,并发局限于应用中,JDK1.4以前的唯一选择
	(2).NIO:同步非阻塞,服务器实现模式为一个请求一个线程,即客户端发送的连接请求都会注册到多路复用器上,多路复用器轮询到连接
		有 I/O 请求时才启动一个线程进行处理;
		NIO 方式适用于连接数多且连接比较短的架构,比如聊天服务器,并发局限于应用中,编程较复杂,JDK1.4后开始支持;
	(3).AIO:异步非阻塞,服务器实现模式为一个有效请求一个线程,客户端的 I/O 请求都是由OS先完成了在通知服务器应用去启动线程进行处理;
		AIO 的方式适用于连接数多且连接比较长的架构,JDK7 开始支持

21.JDK 源码中使用到的设计模式:
	装饰器模式:IO 流
	迭代器模式:Iterator
	单例模式: java.lang.Runtime
	代码模式:RMI

22.数据库索引的优缺点以及什么时候数据库索引失效?
	22.1.索引的特点:
		(1).可以加快数据库的检索速度;
		(2).降低数据库的插入,修改,删除等维护的速度;
		(3).只能创建到表上,不能创建到视图上;
		(4).既可以直接创建又可以间接创建;
		(5).可以在优化隐藏中使用索引
		(6).使用查询处理器知识SQL语句,在一个表上,一次只能使用一个索引;
	22.2.索引的有点:
		(1).创建唯一性索引,保证数据表中每一行数据的唯一性;
		(2).大大加快数据的检索速度,这是创建索引的最主要的原因;
		(3).加快数据库表之间的连接,特别是在实现数据的参考完整性方面有意义;
		(4).在使用分组和排序字句进行数据检索时,同样可以显著减少系统的查询中分组和排序的时间
	22.3.索引的缺点:
		(1).创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加;
		(2).索引需要占用物理空间,除了数据表占用数据空间之外,每个表还需要占用一定的物理空间;
		(3).当对表中的数据进行增删改时,索引也需要维护,降低数据维护的速度
	22.4.索引分类:
		(1).普通索引(它没有任何限制.) 
		(2).唯一性索引(索引列的值必须唯一,但允许有空值.) 
		(3).主键索引(一种特殊的唯一索引,不允许有空值.一般是在建表的时候同时创建主键索引.) 
		(4).组合索引 
		(5).聚集索引 按照每张表的主键构造一颗B+树,并且叶节点中存放着整张表的行记录数据,因此也让聚集索引的叶节点成为数据页. 
		(6).非聚集索引(辅助索引)(页节点不存放一整行记录).
	22.5.索引失效:
		(1).如果条件中有or,即使其中有条件带索引,也不会使用(尽量少用or); 
		(2).Like查询是以%开头,例如SELECT * FROM mytable WHEREt Name like’%admin’; 
		(3).如果列类型是字符串,那一定要在条件中使用引号引起来,否则不会使用索引;
	22.6.各引擎支持的索引:MyISAM,InnoDB,Memonry 三个常用MySQL引擎类型比较
		|索引 			|MyISAM 索引 |InnoDB 索引 |Memonry 索引|
		|------------------------------------------------------|
		|B-tree索引 	|支持		 |支持		  |支持        |
		|Hash索引   	|不支持		 |不支持	  |支持        |
		|R-tree索引 	|支持		 |不支持	  |不支持      |
		|Full-text索引 	|不支持		 |暂不支持	  |不支持      |
		+------------------------------------------------------+

23.数据库中索引的结构是什么?什么情况下适合创建索引?
	23.1.索引的结构:
		因为在使用二叉树的时候,由于二叉树的深度过大而造成I/O 读写过去频繁,进而导致查询效率低下.因此采用多路数据结构,
		B 树的各种操作能使B树保持低的高度,
	23.2.什么情况下适合建立索引?
		(1).经常出现在关键字 order by,group by, distinct 后面的字段;
		(2).在 union 等集合操作的结果集上建立索引;
		(3).为经常用作查询选择的字段建立索引;
		(4).在经常考虑用作表连接的属性上建立索引;
		(5).考虑使用索引覆盖,对数据很少被更新的表,如果用户经常只查询其中的几个字段,
			可以考虑在这几个字段上建立索引,从而将表的扫描改变为索引的扫描

24.MyISAM 和 InnoDB 引擎的区别:
	24.1.主要区别:
		(1).MyISAM 是非事务安全型的, InnoDB 是事务安全型的;
		(2).MyISAM 锁的粒度是表级锁, InnoDB 是支持行级锁的;
		(3).MyISAM 支持全文本索引,而InnoDB不支持全文索引
		(4).MyISAM 相对简单,所以在效率上要优于 InnoDB,小型应用可以考虑使用 MyISAM;
		(5).MyISAM 表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦;
		(6).InnoDB 表比 MyISAM 表更安全,可以在保证数据不丢失的情况下,切换非事务表到事务表；
	24.2.适用场景:
		(1).MyISAM 管理非事务表,它提供高速存储和检索,以及全文搜索能力,如果应用中需要执行大量的select查询,那么MyISAM是更好的选择
		(2).InnoDB 用于事务处理应用程序,具有众多特性,包括ACID事务支持.如果应用中需要执行大量的insert或update操作,
			则应该使用 InnoDB,这样可以提高多用户并发操作的性能

25.脏读、不可重复读和幻读
	(1)脏读(针对回滚的操作):事务T1更新了一行记录的内容,但是并没有提交所做的修改,事务T2读取更新后的行,
		然后T1执行了回滚操作,取消了刚才所做的修改.现在T2读取的行数就无效了(一个事务读取了另一个事务);
	(2)不可重复读(针对修改的操作):事务T1读取了一行记录,紧接着T2修改了T1刚才读取的那一行记录,然后T1又
		再次读取这行记录,发现与刚才读取的结果不同.
	(3)幻读(针对更新的操作):事务T1读取一条指定的where子句所返回的结果集,然后T2事务新插入一行记录,
		这行记录恰好可以满足T1所使用的查询条件.然后T1再次对表进行检索,
		但又看到了T2插入的数据.(第一次没看到,第二次看到了)

26.

27.

































