# 1、基本概念

在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的，C++用运算符`&`获取变量在内存中的起始地址。

语法：`&变量名`

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。

语法：`数据类型 *变量名;`

数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。`*`与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
- 用整型指针存放整数型变量的地址；
- 用字符型指针存放字符型变量的地址；
- 用浮点型指针存放浮点型变量的地址
- 用自定义数据类型指针存放自定义数据类型变量的地址。

语法：`指针=&变量名;`

注意
- 对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
- 如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型

# 2、内存占用

指针也是变量，是变量就要占用内存空间。

在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。

在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，`int*`是整型指针类型，`int*`可以用于声明变量，可以用于`sizeof`运算符，可以用于数据类型的强制转换，总的来说，把`int*`当成一种数据类型就是了

# 3、指针引用

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。

指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

`*`运算符被称为**间接值**或**解除引用**（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，`*`也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
- 声明一个普通变量，声明时指出数据类型和变量名（符号名），系统在内部跟踪该内存单元。
- 声明一个指针变量，存储的值是地址，而不是值本身，程序直接访问该内存单元

```c++
int a = 10;
int *p = &a; // 声明指针变量
cout << "a = " << a << endl;
cout << "*p = " << *p << endl; 
```
上面的 `p` 是一个指针变量，那么 `*p` 就是解引用，跟 a 是一样的；

# 4、使用指针

如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。

值传递：函数的形参是普通变量。传地址的意义如下：
- 可以在函数中修改实参的值。
- 减少内存拷贝，提升性能。

```c++
void print(string *str, int *no) {
  cout << "no= " << *no << ", str = " << *str << endl;
  *str = "张三";
  *no = 20;
}
int main() {

  string str = "李四";
  int no = 10;
  print(&str, &no);
  cout << "no= " << no << ", str = " << str << endl;
  return 0;
}
```

# 5、const与指针

## 5.1、常量指针

语法：`const 数据类型 *变量名;`

不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。

注意：
- 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
- 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
- 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
- 如果形参的值不需要改变，建议加上const修饰，程序可读性更好

```c++
int main() {
  int a = 10;
  int b = 20;
  const int *p = &a;
  cout << "*p=" << *p << endl;
  // *p = 30; 编译报错 read-only variable is not assignable
  p = &b;
  cout << "*p=" << *p << endl;
  return 0;
}
```
上面代码中，`*p = 30` 编译会报错，即不能通过解引用的方式修改值；

`p = &b;` 表示可以指向变量 b

## 5.2、指针常量

语法：`数据类型 * const 变量名;`，指向的变量（对象）不可改变。

注意：
- 在定义的同时必须初始化，否则没有意义。
- 可以通过解引用的方法修改内存地址中的值。
- C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。
```c++
int main() {
  int a = 10;
  int b = 20;
  int *const p = &a;
  cout << "*p=" << *p << endl;
  // p = &b;
  *p = b;
  return 0;
}
```
上面 `p=&b;` 报错：cannot assign to variable 'p' with const-qualified type 'int *const'，但是可以通过 `*p = b;`，即解引用来给指针常量赋值；

## 5.3、常指针常量

语法：`const 数据类型 * const 变量名;`，指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值，即常引用
```c++
const int* const pp = &a;
*pp = b;
pp = &a;
```

## 5.4、比较

- 常量指针：指针指向可以改，指针指向的值不可以更改。
- 指针常量：指针指向不可以改，指针指向的值可以更改。
- 常指针常量：指针指向不可以改，指针指向的值不可以更改。

记忆秘诀：**`*`表示指针，指针在前先读指针；指针在前指针就不允许改变。**
- 常量指针：`const 数据类型 *变量名`
- 指针常量：`数据类型 * const 变量名`

# 6、void

在C++中，void表示为无类型，主要有三个用途：

（1）函数的返回值用void，表示函数没有返回值：
```c++
void func(int a,int b){
    // 函数体代码。
    return;
}
```
（2）函数的参数填void，表示函数不需要参数（或者让参数列表空着）
```c++
int func(void){
    // 函数体代码。
    return 0;
}
```
（3）形参用`void *`，表示接受任意数据类型的指针，是一种通用指针类型，可以指向任意类型的数据
```c++
// 只关心地址本身，不关心里面的内容，用void *可以存放任意类型的地址。
void func(string varname, void* p){
	cout << varname<< "的地址是：" << p << endl;
	cout << varname << "的值是：" << *(char *)p << endl;
}
int main(){
	int  a=89;
	char b='X';
	
	cout << "a的地址是：" <<  & a << endl;
	cout << "b的地址是：" <<  & b << endl;

	func("a", &a);
	func("b", & b);
}
```

注意点：
- 不能用`void`声明变量，它不能代表一个真实的变量，但是，用`void *`可以；
- 不能对`void *`指针直接解引用（需要转换成其它类型的指针）；
- 把其它类型的指针赋值给`void*`指针不需要转换；
- 把`void *`指针赋值给把其它类型的指针需要转换；

> 注意：在C++中应优先使用类型安全的替代方案（如new、模板或智能指针），仅在需要与C交互或处理底层内存时使用void*，并确保类型转换的安全性

# 7、C++内存布局

在 C++ 中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段
- 栈：存储局部变量、函数参数和返回值。
- 堆：存储动态开辟内存的变量。
- 数据段：存储全局变量和静态变量。
- 代码段：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。

栈和堆的主要区别：
- 管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。
- 空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。
- 分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。
- 分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。
- 是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。
- 增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址；

# 8、分配内存

动态分配内存`new`和`delete`，使用堆区的内存有四个步骤：
- 声明一个指针；
- 用`new`运算符向系统申请一块内存，让指针指向这块内存；
- 通过对指针解引用的方法，像使用变量一样使用这块内存；
- 如果这块内存不用了，用`delete`运算符释放它。

申请内存的语法：`new 数据类型(初始值);`   // C++11支持{}

如果申请成功，返回一个地址；如果申请失败，返回一个空地址（暂时不考虑失败的情况）。

释放内存的语法：`delete 地址;`，释放内存不会失败（还钱不会失败）。

注意：
- 动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
- **如果动态分配的内存不用了，必须用`delete`释放它，否则有可能用尽系统的内存。**
- 动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
- 就算指针的作用域已失效，所指向的内存也不会释放。
- 用指针跟踪已分配的内存时，不能跟丢。
```c++
int* p = new int(5);
cout << "*p=" << *p << endl;
*p = 8;
cout << "*p=" << *p << endl;
delete p;
```

# 9、二级指针

指针是指针变量的简称，也是变量，是变量就有地址。指针用于存放普通变量的地址。**二级指针用于存放指针变量的地址。**

声明二级指针的语法：`数据类型** 指针名;`

使用指针有两个目的：
- 传递地址；
- 存放动态分配的内存的地址。

在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。

把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中指针的值。
```c++
void func(int **pp)
{
	*pp = new int(3);
	cout << "pp=" << pp << ",*pp=" << *pp << endl;
}
int main()
{
	int ii = 8;         cout << "ii=" << ii << ", ii的地址是：" << &ii << endl;
	int* pii = &ii;     cout << "pii=" << pii << ", pii的地址是：" << &pii << ",*pii=" << *pii << endl;
	int** ppii = &pii;  cout << "ppii=" << ppii << ", ppii的地址是：" << &ppii << ",*ppii=" << *ppii << endl;
	cout << "**ppii=" << **ppii << endl;
	int* p=0;
	func(&p);
	cout << "p=" << p << ",*p=" << *p << endl;
}
```

# 10、空指针

在C和C++中，用0或NULL都可以表示空指针。声明指针后，在赋值之前，让它指向空，表示没有指向任何地址

## 10.1、使用空指针产生的问题

- 如果对空指针解引用，程序会崩溃。(exited with code=3221225477)
- 如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。
- 在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性；

**为什么空指针访问会出现异常？**

NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。这段空间是空闲的，对于空闲的空间而言，没有相应的物理存储器与之相对应，所以对这段空间来说，任何读写操作都是会引起异常的。**空指针**是程序无论在何时都没有物理存储器与之对应的地址。为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区

## 10.2、C++11的nullptr

用0和`NULL`表示空指针会产生歧义，C++11建议用`nullptr`表示空指针，也就是`(void *)0`。

`NULL`在C++中就是 0，这是因为在C++中`void*` 类型是不允许隐式转换成其他类型的，所以之前C++中用`0`来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了`nullptr`，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用`nullptr`替代`NULL`吧，而`NULL`就当做`0`使用。

注意：在Linux平台下，如果使用`nullptr`，编译需要加`-std=c++11`参数

# 11、野指针

野指针就是指针指向的不是一个有效（合法）的地址。在程序中，如果访问野指针，可能会造成程序的崩溃。指向非法的内存地址指针叫作野指针（Wild Pointer），也叫悬挂指针（Dangling Pointer），意为无法正常使用的指针

出现野指针的情况主要有三种：
- 指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。
- 如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。
- 指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。

规避方法：
- 指针在定义的时候，如果没地方指，就初始化为nullptr。
- 动态分配的内存被释放后，将其置为nullptr。
- 函数不要返回局部变量的地址。

注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度

# 12、函数指针

函数的二进制代码存放在内存中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。

使用函数指针的三个步骤：
- 声明函数指针；
- 让函数指针指向函数的地址；
- 通过函数指针调用函数。

（1）声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）
```c++
int  (*pfa)(int, string);
bool (*pfb)(int, string);
bool (*pfc)(int);
```
说明：pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数

（2）函数指针的赋值

函数名就是函数的地址。函数指针的赋值：`函数指针名=函数名;`

（3）函数指针的调用
- `(*函数指针名)(实参);`
- `函数指针名(实参);`

```c++
void func(int no, string str){
	cout << "亲爱的" << no << "号：" << str << endl;
}
int main(){
	int bh = 3;                                                 
	string message = "我是一只傻傻鸟。";    
	func(bh, message);
	void (*pfunc)(int, string);          // 声明func函数的函数指针。
	pfunc = func;                        // 对函数指针赋值，语法是函数指针名=函数名。
	pfunc(bh, message);                  // 用函数指针名调用函数。 C++
	(*pfunc)(bh, message);               // 用函数指针名调用函数。 C语言
}
```
函数指针有两个用途：调用函数和做函数的参数。

# 13、数组基本操作

**数组创建**

声明数组的语法：`数据类型 数组名[数组长度];`

注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。

C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。

**数组访问**

可以通过下标访问数组中元素，数组下标从0开始。

数组中每个元素的特征和使用方法与单个变量完全相同。

语法：`数组名[数组下标]`

注意：
- 数组下标也必须是整数，可以是常量，也可以是变量。
- 合法的数组下标取值是：0~(数组长度-1)。

**数组内存占用**

数组在内存中占用的空间是连续的。

用`sizeof(数组名)`可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）

**数组的初始化**

```c++
数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};
数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};
数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。
数据类型 数组名[数组长度] = { };    // 把全部的元素初始化为0。
```
> 注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是不建议这么使用

**设置值**

用`memset()`函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）

函数原型：
```c++
#include <cstring>  // 必须包含的头文件
void* memset(void* ptr, int value, size_t num);
```
- 参数说明：
  - ptr: 指向要填充的内存块的指针。
  - value: 要设置的字节值（实际使用时会被转换为 unsigned char）。
  - num: 要填充的字节数。
- 返回值：返回原始指针 ptr。

> 注意，在Linux下，使用`memset()`函数需要包含头文件`#include <string.h>` 或者 `#include <cstring>`

也可以使用 `std::fill` 
```c++
#include <algorithm>
int arr[10];
std::fill(arr, arr + 10, 42);  // 所有元素设为 42
```
使用 memset() 的场景：
- 初始化字符数组。
- 清零 POD 类型内存。

避免使用的情况：
- 非字节级别的值设置（如初始化 int 数组为非 0 值）。
- 包含虚函数、动态内存或复杂对象的类型。

替代方案：优先使用 `std::fill` 或构造函数确保类型安全

**数组复制**

用`memcpy()`函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）

函数原型：`void *memcpy(void *dest, const void *src, size_t n);`
- `dest`是目标内存块的指针；
- `src`是源内存块的指针；
- `count`是要复制的字节数
- 函数返回目标指针`dest`。
```c++
int src[5] = {1, 2, 3, 4, 5};
int dest[5];
memcpy(dest, src, sizeof(src));
```

注意事项：
- 禁止源和目标内存区域重叠，否则行为未定义。需改用 memmove()：
```c++
char str[] = "Hello, World!";
memmove(str + 7, str, 7); // 正确：允许重叠
// 结果为 "Hello, Hello!"
```
- 目标内存必须足够大，目标内存不足会导致缓冲区溢出：
```cpp
char dest[5];
char src[] = "Hello World";
memcpy(dest, src, sizeof(src)); // 错误：dest 仅能容纳5字节
// 'void* memcpy(void*, const void*, size_t)' writing 12 bytes into a region of size 5 overflows the destination
```

> 注意，在Linux下，使用`memcpy()`函数需要包含头文件`#include <string.h>` 或者 `#include <cstring>`

可以使用 `std::copy` 来实现复制，其实类型安全的
```cpp
#include <algorithm>
int src[5] = {1, 2, 3, 4, 5};
int dest[5];
std::copy(src, src + 5, dest); // 更安全的复制方式
```

适用场景：
- 复制POD类型（如数组、结构体）的内存块。
- 需要高性能的内存操作（如处理二进制数据）。

# 14、数组与指针

## 14.1、指针运算

将一个整型变量加1后，其值将增加1。

但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。
```cpp
int main()
{
    int i = 0;
    char c = 'a';
    string s = "a";
    double d = 1.0;
    cout << "i的地址    = " << (void *)&i << endl;      // 0x6e901ffc90
    cout << "&i+1的地址 = " << (void *)(&i + 1) << endl;// 0x6e901ffc94 整数占用4个字节，地址+4，偏移为4个字节
    cout << "c的地址    = " << (void *)&c << endl;      // 0x6e901ffc8f
    cout << "&c+1的地址 = " << (void *)(&c + 1) << endl;// 0x6e901ffc90 字符占用一个字节，地址+1，偏移为1个字节
    cout << "s的地址    = " << (void *)&s << endl;      // 0x6e901ffc60
    cout << "&s+1的地址 = " << (void *)(&s + 1) << endl;// 0x6e901ffc80
    cout << "d的地址    = " << (void *)&d << endl;      // 0x6e901ffc58
    cout << "&d+1的地址 = " << (void *)(&d + 1) << endl;// 0x6e901ffc60
}
```
> 说明：只有char型指针在使用 std::cout 时需要(void *) 进行强制类型转换，如果不转换，其会尝试输出 尝试输出 `char*` 字符串	

## 14.2、数组的地址

- 数组在内存中占用的空间是连续的。
- C++将数组名解释为数组第`0`个元素的地址。
- 数组第`0`个元素的地址和数组首地址的取值是相同的。
- 数组第`n`个元素的地址是：`数组首地址+n`
- C++编译器把：`数组名[下标]` 解释为 `*(数组首地址+下标)`
- C++编译器把: `地址[下标]` 解释为 `*(地址+下标)`
```cpp
int a[] = {1, 2, 3, 4, 5};
cout << "a的地址    =   " << a << endl;
int *p = a;
for (size_t i = 0; i < 5; i++){
    // 下面三个获取数组元素地址的方式是等价的
    cout << "&a[" << i << "]     =   " << &a[i] << endl;
    cout << "a + " << i << "     =   " << a + i << endl;
    cout << "p + " << i << "     =   " << p + i << endl;
    // 下面三个获取数据元素的方式是等价的
    cout << "a[" << i << "]     =   " << a[i] << endl;
    cout << "p[" << i << "]     =   " << p[i] << endl;
    cout << "*(p+" << i << ")     =   " << *(p + i) << endl;
}
```
总结：数组是占用连续空间的一块内存，**数组名** 被解释为数组第`0`个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的

**数组名** 不一定会被解释为地址，在多数情况下，C++将`数组名`解释为`数组的第0个元素的地址`，但是，将`sizeof`运算符用于数据名时，将返回整个数组占用内存空间的字节数。可以修改指针的值，但数组名是常量，不可修改

> 说明：地址默认输出是16进制的，可以将其转换为十进制输出：`(long long)&a[i]`

## 14.3、数组用于函数的参数

一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。

书写方法有两种： 
```cpp
void func(int* arr, int len);
void func(int arr[], int len);
```
注意：在函数中，不要对指针名用`sizeof`运算符，它不是数组名，它只是一个指针，指向数组的首地址，也就是说实际传递的都是指针，而非完整的数组类型，sizeof(arr) 返回指针的大小（通常4或8字节）

## 14.4、new创建数组

普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。
- 动态创建一维数组的语法：`数据类型 *指针=new 数据类型[数组长度];`
- 释放一维数组的语法：`delete[] 指针;`

注意：
- 动态创建的数组没有数组名，不能用`sizeof`运算符。
- 可以用数组表示法和指针表示法两种方式使用动态创建的数组。
- 必须使用`delete[]`来释放动态数组的内存（不能只用delete）。
- 不要用`delete[]`来释放不是`new[]`分配的内存：`'void operator delete [](void*)' called on unallocated object 'a' [-Wfree-nonheap-object]`
- 不要用`delete[]`释放同一个内存块两次（否则等同于操作野指针）。
- 对空指针用`delete[]`是安全的（释放内存后，应该把指针置空`nullptr`）。
- 声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。
- 如果内存不足，调用`new`会产生异常，导致程序中止；如果在`new`关键字后面加(`std::nothrow`)选项，则返回`nullptr`，不会产生异常。
- 为什么用`delete[]`释放数组的时候，不需要指定数组的大小，因为系统会自动跟踪已分配数组的内存。

分配大内存失败，异常程序终止
```cpp
// 尝试分配极大内存（可能失败）
int* arr = new int[1000000000000];  // 默认new
delete[] arr;
```
使用 std::nothrow
```cpp
#include <iostream>
#include <new>  // 必须包含以使用 std::nothrow
  // 尝试分配极大内存（可能失败）
  int* arr = new(std::nothrow) int[1000000000000];  // 使用 nothrow
  if (arr == nullptr) {
      std::cerr << "内存分配失败，返回 nullptr" << std::endl;
  } else {
      delete[] arr;
  }
  return 0;
```

# 15、[C++字符串](https://en.cppreference.com/w/cpp/string)

C++中的字符串（`std::string`）与C语言的字符串（以空字符'\0'结尾的字符数组）既有继承关系，又在设计和使用上存在显著差异

C++的`std::string`可以兼容C风格字符串。例如，可以用C字符串初始化或赋值给`std::string`：
```cpp
std::string s = "Hello"; // "Hello"是C风格字符串
```
通过c_str()或data()方法，std::string可转换为C风格字符串，以便与C函数交互：
```cpp
const char* c_str = s.c_str(); // 返回以'\0'结尾的字符数组
```
`std::string`的内部存储通常仍使用字符数组，但封装了内存管理，隐藏了结尾的空字符（尽管c_str()会显式添加'\0'）

C++字符和C语言字符串比较：

| **特性**               | **C风格字符串**                                     | **C++的`std::string`**                              |
|------------------------|---------------------------------------------------|---------------------------------------------------|
| **类型**               | 字符数组（`char[]`或`char*`），无内置类型          | 类类型（`std::string`），属于标准库                |
| **内存管理**           | 手动管理（需显式分配/释放内存）                    | 自动管理（动态分配，超出作用域自动释放）            |
| **结尾标识**           | 以`'\0'`结尾                                       | 不依赖`'\0'`，但`c_str()`返回的字符串会包含`'\0'`  |
| **操作方式**           | 使用库函数（如`strcpy`, `strcat`, `strlen`）       | 成员函数（如`append`, `find`）和运算符重载（如`+`, `==`） |
| **安全性**             | 易出错（缓冲区溢出、内存泄漏）                     | 更安全（自动调整大小，避免越界）                    |
| **功能扩展**           | 功能有限，依赖第三方库                             | 支持迭代器、STL算法、动态扩容等                     |
| **性能**               | 更底层，可能更快（无额外开销）                     | 优化良好，但可能有轻微开销（如动态内存分配）        |

内存管理
- C字符串：需手动分配内存（如`malloc`或静态数组），并确保足够空间。例如：
  ```c
  char str[10];
  strcpy(str, "hello"); // 需保证目标数组足够大
  ```
- C++字符串：自动管理内存，无需预定义大小：
  ```cpp
  std::string s;
  s = "This is a very long string..."; // 自动分配足够内存
  ```
安全性
- C字符串易因越界或未终止符导致未定义行为（如`strlen`遍历越界）。
- C++字符串通过封装避免了多数问题，例如`substr`会检查边界。

功能扩展：`std::string`支持迭代器、STL算法、动态扩容等，而C字符串需自行实现类似功能。

> 在C++中优先使用`std::string`，因其安全、便捷且功能强大。仅在需要与C代码交互或极端性能优化时使用C风格字符串。

# 16、二维数组

一维数组的数学概念是线性表，二维数组的数学概念是矩阵

## 16.1、基础使用

**创建二维数组**

声明二维数组的语法：`数据类型 数组名[行数][列数];`
```cpp
int bh[2][3] = { {11,12,13},{21,22,23} }; 
```

注意：数组长度必须是整数，可以是常量，也可以是变量和表达式

**访问二维数组**

可以通过行下标和列下标访问二维数组中元素，下标从0开始。二维数组中每个元素的特征和使用方法与单个变量完全相同。

语法：`数组名[行下标][列下标]`

注意：
- 二维数组下标也必须是整数，可以是常量，也可以是变量。
- 合法的行下标取值是：0~(行数-1)。
- 合法的列下标取值是：0~(列数-1)。

**二维数组占用内存的情况**

用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。

二维数组在内存中占用的空间是连续的。

**声明的时候初始化**

- `数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 },...... };`
- `数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4, ......};`
- `数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};`
- `数据类型 数组名[行数][列数] = { 0 };`  // 把全部的元素初始化为0。
- `数据类型 数组名[行数][列数] = { }; `   // 把全部的元素初始化为0。

> 注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值


## 16.2、数组指针

```cpp
int* p;      // 整型指针。
int* p[3];   // 一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。
int* p();    // 函数p的返回值类型是整型的地址。
int (*p)(int ,int);   // p是函数指针，函数的返回值是整型。
```
一维数组名被解释为数组第0个元素的地址。对一维数组名取地址得到的是数组的地址，是行地址

二维数组名是行地址
```cpp
int bh[2][3] = { {11,12,13},{21,22,23} };
```
bh是二维数组名，该数组有2两元素，每一个元素本身又是一个数组长度为3的整型数组。

bh被解释为数组长度为3的整型数组类型的行地址。如果存放bh的值，要用数组长度为3的整型数组类型的行指针

## 16.3、数组指针与指针数组

### 16.3.1、基本概念

在 C++ 中，**数组指针**和**指针数组**是两种完全不同的概念，它们的定义、用途和语法均有显著差异。

**指针数组（Array of Pointers）**
- 定义：一个**数组**，其元素全部是**指针**。
- 语法：`数据类型* 数组名[大小];`
  ```cpp
  int* ptrArray[5];  // 指针数组：包含5个int类型指针的数组
  ```
- 本质：每个元素都是一个指针，可以指向不同类型或不同内存区域的数据。

**数组指针（Pointer to Array）**
- 定义：一个**指针**，指向一个**数组**。
- 语法：`数据类型 (*指针名)[数组大小];`
  ```cpp
  int (*arrayPtr)[5];  // 数组指针：指向一个包含5个int元素的数组的指针
  ```
- 本质：指针本身存储的是整个数组的首地址，可以通过指针操作整个数组。

### 16.3.2、内存模型对比

**指针数组**
- 内存布局：
  ```cpp
  int* ptrArray[3] = {&a, &b, &c}; 
  // 内存中存储3个指针，每个指针指向独立的内存地址
  ```
  ```
  +-------+-------+-------+
  | ptr0  | ptr1  | ptr2  |  指针数组元素
  +---|---+---|---+---|---+
      |       |       |
      v       v       v
     [a]     [b]     [c]     指向的独立数据
  ```

**数组指针**
- 内存布局：
  ```cpp
  int arr[5] = {1,2,3,4,5};
  int (*arrayPtr)[5] = &arr; // 指向整个数组的指针
  ```
  ```
  +-----------+
  | arrayPtr  | → 指向整个数组的首地址
  +-----------+
       |
       v
  +---------------------+
  | [0]  [1]  [2]  [3]  [4] |  数组元素连续存储
  +---------------------+
  ```

### 16.3.3、使用场景与示例

**指针数组的典型用法**
- **存储多个独立指针**：
  ```cpp
  const char* names[] = {"Alice", "Bob", "Charlie"}; // 字符串数组（每个元素是char*）
  ```
  - 遍历：
    ```cpp
    for (int i = 0; i < 3; i++) {
        std::cout << names[i] << std::endl; // 输出每个字符串
    }
    ```
- **动态分配多维数组**：
  ```cpp
  int** matrix = new int*[3]; // 指针数组
  for (int i = 0; i < 3; i++) {
      matrix[i] = new int[4]; // 每个指针指向一个一维数组
  }
  ```

**数组指针的典型用法**
- **操作多维数组**：
  ```cpp
  int arr2D[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
  int (*ptr)[4] = arr2D; // 指向第一个一维数组的指针

  // 通过指针访问二维数组
  for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 4; j++) {
          std::cout << ptr[i][j] << " "; // 等效于arr2D[i][j]
      }
      std::cout << std::endl;
  }
  ```

- **函数参数传递多维数组**：
  ```cpp
  void printMatrix(int (*matrix)[4], int rows) {
      // 接收一个指向一维数组（长度4）的指针
      for (int i = 0; i < rows; i++) {
          for (int j = 0; j < 4; j++) {
              std::cout << matrix[i][j] << " ";
          }
          std::cout << std::endl;
      }
  }
  ```

### 16.3.4、区分方法

**语法优先级规则**
- **指针数组**：`[]` 的优先级高于 `*`，因此 `int* arr[5]` 表示**数组**，元素是 `int*`。
- **数组指针**：`()` 改变了优先级，`int (*arr)[5]` 表示**指针**，指向 `int[5]` 类型的数组。

**类型推导技巧**
- **指针数组**：
  ```cpp
  typedef int* IntPtr;
  IntPtr arr[5];  // 等价于 int* arr[5]
  ```
- **数组指针**：
  ```cpp
  typedef int IntArray5[5];
  IntArray5* arrPtr;  // 等价于 int (*arrPtr)[5]
  ```

---

### 16.3.5、常见错误与注意事项

**指针数组的陷阱**
- **未初始化的指针**：
  ```cpp
  int* ptrArray[3];
  *ptrArray[0] = 10; // 错误！指针未指向有效内存
  ```

**数组指针的陷阱**
- **错误的内存访问**：
  ```cpp
  int arr[3] = {1,2,3};
  int (*arrayPtr)[5] = (int(*)[5])&arr; // 强制类型转换
  // 访问 arrayPtr[0][4] 会导致越界！
  ```

### 16.3.6、总结

| **特性**       | **指针数组**                          | **数组指针**                          |
|----------------|-------------------------------------|-------------------------------------|
| **本质**       | 数组（元素是指针）                    | 指针（指向数组）                      |
| **语法**       | `int* arr[size]`                   | `int (*arr)[size]`                 |
| **内存模型**   | 存储多个指针                          | 存储单个指针（指向连续内存块）          |
| **典型用途**   | 动态多维数组、字符串数组              | 多维数组操作、函数参数传递多维数组      |
| **操作单位**   | 单个指针（元素级别）                  | 整个数组（块级别）                    |

**选择建议**：
- 需要管理多个独立指针时（如字符串数组），使用**指针数组**。
- 需要操作连续内存块（如二维数组）时，使用**数组指针**。

**终极区分技巧**：
- 若声明中有 `[]` 在变量名右侧，且无括号，则为**指针数组**（如 `int* arr[5]`）。
- 若声明中有 `*` 被括号包裹，则为**数组指针**（如 `int (*arr)[5]`）。