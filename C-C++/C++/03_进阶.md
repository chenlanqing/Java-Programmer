# 1、结构体

## 1.1、基本概念

结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。

使用结构体有两个步骤：1）定义结构体描述（类型）；2）创建结构体变量

## 1.2、定义

定义结构体描述的语法：
```cpp
struct 结构体名
{
    成员一的数据类型  成员名一;
    成员二的数据类型  成员名二;
    成员三的数据类型  成员名三;
    ......
    成员n的数据类型  成员名n;
};
```
注意：
- 结构体名是标识符。
- 结构体的成员可以是任意数据类型。
- 定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。
- 结构体成员可以用C++的类（如string），但是不提倡。
- 在C++中，结构体中可以有函数，但是不提倡。
- 在C++11中，定义结构体的时候可以指定缺省值。

```cpp
struct student {
    char name[20];
    int age;
    float score;
};
```

## 1.3、创建结构体变量

创建结构体变量的语法：`struct 结构体名 结构体变量名;`

也可以为结构体成员赋初始值。`struct 结构体名 结构体变量名={成员一的值, 成员二的值,......, 成员n的值};`

- C++11可以不写等于号。
- 如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0：`struct 结构体名 结构体变量名={0};`

注意：
- 在C++中，struct关键字可以不写。
- 可以在定义结构体的时候创建结构体变量。

```cpp
// 可以不写struct关键字
student s1;
```
定义结构体的时候创建结构体变量：
```cpp
struct student {
  char name[20];
  int age;
  float score;
} stu;
int main() {
  student s1 = {"张三", 18, 100};
  cout << s1.name << endl;
  stu = {"张三", 18, 100};
}
```

## 1.4、使用

在C++程序中，用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。

语法：`结构体变量名.结构体成员名;`
```cpp
int main() {
  student s1 = {"张三", 18, 100};
  cout << s1.name << endl;
  stu = {"张三", 18, 100};
}
```

## 1.5、内存占用

用`sizeof`运算符可以得到整个结构体占用内存的大小。

注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和。因为存在内存对齐

内存对齐：`#pragma pack(字节数)`

合理使用内存对齐规则，某些节省内存的做法可能毫无意义


## 1.6、结构体赋值

**清空结构体**

创建的结构体变量如果没有初始化，成员中有垃圾值。

用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）

bzero()函数也可以。

**结构体复制**

用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。

也可以直接用等于号（只适用于C++基本数据类型）。

# 2、结构体指针

在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：
```cpp
struct student stu;         // 声明结构体变量stu。
struct student *pst=&stu;  // 声明结构体指针，指向结构体变量stu。
```
通过结构体指针访问结构体成员，有两种方法：
```cpp
(*指针名).成员变量名    // (*pst).name和(*pst).age 
```
或者：
```cpp
指针名->成员变量名    // pst->name和*pst->age 
```
在第一种方法中，圆点`.`的优先级高于`*`，`(*指针名)`两边的括号不能少。如果去掉括号写成`(*指针名).成员变量名`，那么相当于`*(指针名.成员变量名)`，意义就完全不一样了。

在第二种方法中，`->`是一个新的运算符。

上面的两种方法是等效的，通常采用第二种方法，更直观

主要用途：
（1）用于函数的参数，如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针，如果不希望在函数中修改结构体变量的值，可以对形参加const约束；
```cpp
void func(const student* stu)
{
    stu -> age = 100; //报错：cannot assign to variable 'stu' with const-qualified type 'const student
}
```

（2）用于动态分配内存

# 3、结构体数组

结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。

声明结构体数组的语法：`struct 结构体类型 数组名[数组长度];`

初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。
```cpp
struct student stu[2]={{}, {}};
```
使用结构体数组可以用数组表示法，也可以用指针表示法
```cpp
struct student {
    int id;
    char name[20];
    float score;
};

int main() {
    // 定义一个有3个元素的结构体数组
    student stu[3];

    // 给每个学生赋值
    stu[0].id = 1;
    strcpy(stu[0].name, "Tom");
    stu[0].score = 90;

    stu[1].id = 2;
    strcpy(stu[1].name, "Jerry");
    stu[1].score = 80;

    stu[2].id = 3;
    strcpy(stu[2].name, "Bob");
    stu[2].score = 85;
    // 输出每个学生的信息
    for (int i = 0; i < 3; i++) {
        cout << "ID: " << stu[i].id << endl;
        cout << "Name: " << stu[i].name << endl;
        cout << "Score: " << stu[i].score << endl;
        cout << endl;
   }

   return 0;
}
```

# 4、结构体中的指针

如果结构体中的指针指向的是动态分配的内存地址：
- 对结构体用`sizeof`运算可能没有意义。
- 对结构体用`memset()`函数可能会造成内存泄露。
- C++的字符串`string`中有一个指针，指向了动态分配内存的地址。
```cpp
struct string
{
	char *ptr;   // 指向动态分配内存的地址。
	......
}
```

# 5、简单链表

如果结构体中有一个本结构体的指针，它就是链表。
```cpp
struct student
{
	int no;
	string name;
	struct student *next;
};
```
完整示例：
```cpp
struct student
{
    int no;
    char name[20];
    struct student *next;
};

int main()
{
    student *head, *tail, *tmp;

    tmp = new student{1, "张三", nullptr}; // 分配第一个节点。
    head = tail = tmp;

    tmp = new student{2, "李四", nullptr}; // 分配第二个节点。
    tail->next = tmp;                      // 把上一个节点的next指针指向新节点。
    tail = tmp;                            // 移动尾指针，让尾指针指向刚分配出来的新节点

    tmp = new student{3, "王五", nullptr}; // 分配第三个节点。
    tail->next = tmp;                      // 把上一个节点的next指针指向新节点。
    tail = tmp;                            // 移动尾指针，让尾指针指向刚分配出来的新节点。

    // 遍历链表
    tmp = head;
    while (tmp != nullptr)
    {
        cout << tmp->no << " " << tmp->name << endl;
        tmp = tmp->next; // 顺着next指向往后面找。
    }
    // 释放链表
    while (head != nullptr)
    {
        tmp = head;
        head = head->next;
        delete tmp;
    }
}
```

# 6、共同体

共同体（共用体、联合体）是一种数据格式，它能存储不同的数据类型，但是，在同一时间只能存储其中的一种类型。

声明共同体的语法：
```cpp
union 共同体名
{
成员一的数据类型  成员名一;
成员二的数据类型  成员名二;
成员三的数据类型  成员名三;
......
成员n的数据类型  成员名n;
};
```
注意：
- 共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐）。
- 全部的成员使用同一块内存。
- 共同体中的值为最后被赋值的那个成员的值。
- 匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中。

应用场景：
- 当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间（嵌入式系统）。
- 用于回调函数的参数（相当于支持多种数据类型）。

```cpp
#include <iostream>
using namespace std;
union u_data
{
    int a;
    double b;
    char c[25];
};
int main()
{
    u_data data;
    cout << "sizeof(data)=" << sizeof(data) << endl; // 内存是对齐的：32

	  cout << "data.a的地址是：" << (void*)&data.a << endl; // 0x4a7d1ffb60
	  cout << "data.b的地址是：" << (void*)&data.b << endl; // 0x4a7d1ffb60
	  cout << "data.c的地址是：" << (void*)&data.c << endl; // 0x4a7d1ffb60
}
```

# 7、枚举

枚举是一种创建符号常量的方法。枚举的语法：
```cpp
enum 枚举名 { 枚举量1 , 枚举量2 , 枚举量3, ......, 枚举量n };
```
例如：
```cpp
enum colors { red , yellow , blue };
```

这条语句完成了两项工作：
- 让colors成了一种新的枚举类型的名称，可以用它创建枚举变量。
- 将red、yellow、blue作为符号常量，默认值是整数的0、1、2。

注意：
- 用枚举创建的变量取值只能在枚举量范围之内。
- 枚举的作用域与变量的作用域相同。
- 可以显式的设置枚举量的值（必须是整数）：` enum status { ok=0, error=99999, warning};`，那么 warning 的整数值为：10000
- 可以只显式的指定某些枚举量的值（枚举量的值可以重复）：`enum colors {red=10,yellow,blue};`
- 可以将整数强制转换成枚举量，语法：枚举类型(整数)

```cpp
#include <iostream>         
using namespace std;        

int main()
{
	enum colors { red=0, yellow=1, blue=2, other=3 };    // 创建枚举类型colors。

	colors cc = yellow;           // 创建枚举变量，并赋初始值。
	cc = colors(1);           // 创建枚举变量，并赋初始值。
	
	cout << "red=" << red << ",yellow=" << yellow << ",blue=" << blue << ",other=" << other << endl;

	switch (cc)
	{
		case red:			cout << "红色。\n"; break;
		case yellow:	    cout << "黄色。\n"; break;
		case blue:		    cout << "蓝色。\n"; break;
		default:			cout << "未知。\n"; 
	}
}
```



