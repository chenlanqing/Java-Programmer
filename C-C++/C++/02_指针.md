# 1、基本概念

在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的，C++用运算符`&`获取变量在内存中的起始地址。

语法：`&变量名`

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。

语法：`数据类型 *变量名;`

数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。`*`与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
- 用整型指针存放整数型变量的地址；
- 用字符型指针存放字符型变量的地址；
- 用浮点型指针存放浮点型变量的地址
- 用自定义数据类型指针存放自定义数据类型变量的地址。

语法：`指针=&变量名;`

注意
- 对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
- 如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型

# 2、内存占用

指针也是变量，是变量就要占用内存空间。

在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。

在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，`int*`是整型指针类型，`int*`可以用于声明变量，可以用于`sizeof`运算符，可以用于数据类型的强制转换，总的来说，把`int*`当成一种数据类型就是了

# 3、指针引用

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。

指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

`*`运算符被称为**间接值**或**解除引用**（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，`*`也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
- 声明一个普通变量，声明时指出数据类型和变量名（符号名），系统在内部跟踪该内存单元。
- 声明一个指针变量，存储的值是地址，而不是值本身，程序直接访问该内存单元

```c++
int a = 10;
int *p = &a; // 声明指针变量
cout << "a = " << a << endl;
cout << "*p = " << *p << endl; 
```
上面的 `p` 是一个指针变量，那么 `*p` 就是解引用，跟 a 是一样的；

# 4、使用指针

如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。

值传递：函数的形参是普通变量。传地址的意义如下：
- 可以在函数中修改实参的值。
- 减少内存拷贝，提升性能。

```c++
void print(string *str, int *no) {
  cout << "no= " << *no << ", str = " << *str << endl;
  *str = "张三";
  *no = 20;
}
int main() {

  string str = "李四";
  int no = 10;
  print(&str, &no);
  cout << "no= " << no << ", str = " << str << endl;
  return 0;
}
```

# 5、const与指针

## 5.1、常量指针

语法：`const 数据类型 *变量名;`

不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。

注意：
- 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
- 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
- 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
- 如果形参的值不需要改变，建议加上const修饰，程序可读性更好

```c++
int main() {
  int a = 10;
  int b = 20;
  const int *p = &a;
  cout << "*p=" << *p << endl;
  // *p = 30; 编译报错 read-only variable is not assignable
  p = &b;
  cout << "*p=" << *p << endl;
  return 0;
}
```
上面代码中，`*p = 30` 编译会报错，即不能通过解引用的方式修改值；

`p = &b;` 表示可以指向变量 b

## 5.2、指针常量

语法：`数据类型 * const 变量名;`，指向的变量（对象）不可改变。

注意：
- 在定义的同时必须初始化，否则没有意义。
- 可以通过解引用的方法修改内存地址中的值。
- C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。
```c++
int main() {
  int a = 10;
  int b = 20;
  int *const p = &a;
  cout << "*p=" << *p << endl;
  // p = &b;
  *p = b;
  return 0;
}
```
上面 `p=&b;` 报错：cannot assign to variable 'p' with const-qualified type 'int *const'，但是可以通过 `*p = b;`，即解引用来给指针常量赋值；

## 5.3、常指针常量

语法：`const 数据类型 * const 变量名;`，指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值，即常引用
```c++
const int* const pp = &a;
*pp = b;
pp = &a;
```

## 5.4、比较

- 常量指针：指针指向可以改，指针指向的值不可以更改。
- 指针常量：指针指向不可以改，指针指向的值可以更改。
- 常指针常量：指针指向不可以改，指针指向的值不可以更改。

记忆秘诀：**`*`表示指针，指针在前先读指针；指针在前指针就不允许改变。**
- 常量指针：`const 数据类型 *变量名`
- 指针常量：`数据类型 * const 变量名`

# 6、void

在C++中，void表示为无类型，主要有三个用途：

（1）函数的返回值用void，表示函数没有返回值：
```c++
void func(int a,int b){
    // 函数体代码。
    return;
}
```
（2）函数的参数填void，表示函数不需要参数（或者让参数列表空着）
```c++
int func(void){
    // 函数体代码。
    return 0;
}
```
（3）形参用`void *`，表示接受任意数据类型的指针，是一种通用指针类型，可以指向任意类型的数据
```c++
// 只关心地址本身，不关心里面的内容，用void *可以存放任意类型的地址。
void func(string varname, void* p){
	cout << varname<< "的地址是：" << p << endl;
	cout << varname << "的值是：" << *(char *)p << endl;
}
int main(){
	int  a=89;
	char b='X';
	
	cout << "a的地址是：" <<  & a << endl;
	cout << "b的地址是：" <<  & b << endl;

	func("a", &a);
	func("b", & b);
}
```

注意点：
- 不能用`void`声明变量，它不能代表一个真实的变量，但是，用`void *`可以；
- 不能对`void *`指针直接解引用（需要转换成其它类型的指针）；
- 把其它类型的指针赋值给`void*`指针不需要转换；
- 把`void *`指针赋值给把其它类型的指针需要转换；

> 注意：在C++中应优先使用类型安全的替代方案（如new、模板或智能指针），仅在需要与C交互或处理底层内存时使用void*，并确保类型转换的安全性