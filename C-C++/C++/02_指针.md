# 1、基本概念

在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的，C++用运算符`&`获取变量在内存中的起始地址。

语法：`&变量名`

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。

语法：`数据类型 *变量名;`

数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。`*`与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
- 用整型指针存放整数型变量的地址；
- 用字符型指针存放字符型变量的地址；
- 用浮点型指针存放浮点型变量的地址
- 用自定义数据类型指针存放自定义数据类型变量的地址。

语法：`指针=&变量名;`

注意
- 对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
- 如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型

# 2、内存占用

指针也是变量，是变量就要占用内存空间。

在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。

在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，`int*`是整型指针类型，`int*`可以用于声明变量，可以用于`sizeof`运算符，可以用于数据类型的强制转换，总的来说，把`int*`当成一种数据类型就是了

# 3、指针引用

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。

指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

`*`运算符被称为**间接值**或**解除引用**（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，`*`也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
- 声明一个普通变量，声明时指出数据类型和变量名（符号名），系统在内部跟踪该内存单元。
- 声明一个指针变量，存储的值是地址，而不是值本身，程序直接访问该内存单元

```c++
int a = 10;
int *p = &a; // 声明指针变量
cout << "a = " << a << endl;
cout << "*p = " << *p << endl; 
```
上面的 `p` 是一个指针变量，那么 `*p` 就是解引用，跟 a 是一样的；

# 4、使用指针

如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。

值传递：函数的形参是普通变量。传地址的意义如下：
- 可以在函数中修改实参的值。
- 减少内存拷贝，提升性能。

```c++
void print(string *str, int *no) {
  cout << "no= " << *no << ", str = " << *str << endl;
  *str = "张三";
  *no = 20;
}
int main() {

  string str = "李四";
  int no = 10;
  print(&str, &no);
  cout << "no= " << no << ", str = " << str << endl;
  return 0;
}
```

# 5、const与指针

## 5.1、常量指针

语法：`const 数据类型 *变量名;`

不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。

注意：
- 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
- 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
- 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
- 如果形参的值不需要改变，建议加上const修饰，程序可读性更好

```c++
int main() {
  int a = 10;
  int b = 20;
  const int *p = &a;
  cout << "*p=" << *p << endl;
  // *p = 30; 编译报错 read-only variable is not assignable
  p = &b;
  cout << "*p=" << *p << endl;
  return 0;
}
```
上面代码中，`*p = 30` 编译会报错，即不能通过解引用的方式修改值；

`p = &b;` 表示可以指向变量 b