# 1、类

## 1.1、基本概念

对面向对象编程来说，一切都是对象，对象用类来描述。类把对象的数据和操作数据的方法作为一个整体考虑。

定义类的语法：
```cpp
class 类名
{
public:
    成员一的数据类型  成员名一;
    成员二的数据类型  成员名二;
    成员三的数据类型  成员名三;
    ......
    成员n的数据类型  成员名n;
private:
    成员n的数据类型  成员名n;
};
```
注意：
- 类的成员可以是变量，也可以是函数。
- 类的成员变量也叫属性。
- 类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。
- 用类定义一个类的变量叫创建（或实例化）一个对象。
- 对象的成员变量、成员函数的作用域和生命周期与对象的作用域和生命周期相同。

```cpp
class Person{
public:
    string name;                           // 姓名。
    int age;                               // 年龄。
    void setvalue(string name1, int age1); // 设置成员变量的值。
    void show(){
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
};
void Person::setvalue(string name1, int age1){ // 设置成员变量的值。
    name = name1;
    age = age1;
}
int main(){
    Person p1;
    p1.setvalue("张三", 20);
    p1.show();
}
```

## 1.2、类的访问权限

类的成员有三种访问权限：public、private和protected，分别表示公有的、私有的和受保护的。
- 在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。
- 在类的外部（定义类的代码之外），只能访问public成员，不能访问 private、protected成员。
- 在一个类体的定义中，private 和 public 可以出现多次。
- 结构体的成员缺省为public，类的成员缺省为private。
- private的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为public。

## 1.3、基本使用

- 类的成员函数可以直接访问该类其它的成员函数（可以递归）。
- 类的成员函数可以重载，可以使用默认参数。
- 类指针的用法与结构体指针用法相同。
- 类的成员可以是任意数据类型（类中枚举）。
- 可以为类的成员指定缺省值（C++11标准）。
- 类可以创建对象数组，就像结构体数组一样。
- 对象可以作为实参传递给函数，一般传引用。
- 可以用`new`动态创建对象，用`delete`释放对象。
- 在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。
- 对象一般不用`memset()`清空成员变量，可以写一个专用于清空成员变量的成员函数。
- 对类和对象用`sizeof`运算意义不大，一般不用。
- 用结构体描述纯粹的数据，用类描述对象。
- 在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。
- 为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。
- 类的分文件编写。

## 1.4、构造函数和析构函数

- 构造函数：在创建对象时，自动的进行初始化工作。
- 析构函数：在销毁对象前，自动的完成清理工作；

### 1.4.1、构造函数

语法：`类名(){......}`
- 访问权限必须是public。
- 函数名必须与类名相同。
- 没有返回值，不写void。
- 可以有参数，可以重载，可以有默认参数。
- 创建对象时只会自动调用一次，不能手工调用。

### 1.4.2、析构函数

语法：`~类名(){......}`
- 访问权限必须是`public`。
- 函数名必须在类名前加`~`。
- 没有返回值，也不写void。
- 没有参数，不能重载。
- 销毁对象前只会自动调用一次，但是可以手工调用。

### 1.4.3、基本示例

```cpp
class Person{
public:
    Person(){
        std::cout << "Person() constructor called" << std::endl;
    }
    Person(string name, int age){
        std::cout << "Person(string name, int age) constructor called" << std::endl;
        this->name = name;        this->age = age;
    }
    ~Person(){
        std::cout << "Destructor called" << std::endl;
    }
    void show() {
        std::cout << "name: " << name << ", age: " << age << std::endl;
    }
private:
    string name;
    int age;
};
int main(){
    Person p1 = Person("张无忌", 20);
}
```
上面代码的输出为：
```cpp
Person(string name, int age) constructor called
Destructor called
```
再比如说：
```cpp
Person p1; // 调用默认构造函数 ，输出 Person() constructor called
p1 = Person("周芷若", 20); // 临时对象创建 ：Person("周芷若", 20) 调用 带参数构造函数
// 临时对象销毁 ：临时对象被销毁，调用析构函数
// p1 对象销毁，调用析构函数
```
代码输出为：
```cpp
Person() constructor called
Person(string name, int age) constructor called
Destructor called
Destructor called
```

### 1.4.4、说明

- 如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。
- 如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。
- 创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。
- 创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数），兼容C语言 ：C语言中函数声明的语法为 `类型 名称(参数列表)`，C++继承了这一语法，导致与对象初始化存在歧义。
    ```cpp
    class Person {
        Person() {}  // 默认构造函数
    };
    // 错误：被解析为函数声明（返回Person，参数为空）
    Person p(); 
    // 正确：不带括号，直接调用默认构造函数
    Person p;
    // 正确：显式调用构造函数（带参数）
    Person p(10); 
    ```
- 在构造函数名后面加`括号和参数`不是调用构造函数，是创建匿名对象。
    ```cpp
    class MyClass {
        MyClass(int x) { /* 初始化逻辑 */ }
    };
    MyClass(10);  // 创建匿名对象，调用构造函数 MyClass(int)，但对象无名
    ```
- 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。
    ```cpp
    Person(string& name){
        std::cout << "Person(string name) constructor called" << std::endl;
        this->name = name;        this->age = 18;
    }
    Person(const char* name){
        std::cout << "Person(const char* name)constructor called" << std::endl;
        this->name = name;        this->age = 18;
    }
    string name = "张无忌";
    Person p1 = name; // 会调用上面的 Person(string& name) 构造函数
    Person p2 = "abcd"; // 会调用 Person(const char* name) 构造函数
    ```
- 用new/delete创建/销毁对象时，也会调用构造/析构函数
    ```cpp
    Person* p1 = new Person("张无忌", 20 );
    p1->show();
    delete p1;
    ```
- 不建议在构造/析构函数中写太多的代码，可以调用成员函数
- C++11支持使用统一初始化列表。
    ```cpp
    Person p1 = {"张无忌", 20};
    Person p2{"张无忌", 20};
    Person p3 = Person{"张无忌", 20};
    Person* p4 = new Person{"张无忌", 20};
    delete p4;
    ```
- 如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类
    ```cpp
        class B {
    public:
        B() { cout << "B constructor" << endl; }
        ~B() { cout << "B destructor" << endl; }
    };

    class C {
        B b;
    public:
        C() { cout << "C constructor" << endl; }
        ~C() { cout << "C destructor" << endl; }
    };

    class A {
        B b;  // 先声明B
        C c;  // 后声明C
    public:
        A() { cout << "A constructor" << endl; }
        ~A() { cout << "A destructor" << endl; }
    };
    int main() {
        A a;
        return 0;
    }
    B constructor
    B constructor
    C constructor
    A constructor
    A destructor
    C destructor
    B destructor
    B destructor
    ```

## 1.5、拷贝构造函数

用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。

如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。

用一个已存在的对象创建新的对象语法：
```
类名 新对象名(已存在的对象名);
类名 新对象名=已存在的对象名;
```
拷贝构造函数的语法：
```cpp
类名(const 类名& 对象名){......}
```

示例代码
```cpp
class Person{
public:
    Person(){
        std::cout << "Person() constructor called" << std::endl;
        this->p = nullptr;        this->name.clear();        this->age = 0;
    }
    Person(string name, int age, int *p){
        std::cout << "Person(string, int, int*) constructor called" << std::endl;
        this->name = name;        this->age = age;        this->p = p;
    }
    Person(const Person &p){
        std::cout << "Person(const Person&) copy constructor called" << std::endl;
        this->name = p.name;  this->age = p.age; this->p = p.p;
    }
    ~Person(){
        std::cout << "Destructor called: " << this << std::endl;
        delete p;
        p = nullptr;
    }
    void show(){
        std::cout << "name: " << name << ", age: " << age << ", p: " << p;
        if (p != nullptr){
            cout << ", *p=" << *p << endl;
        } else {
            cout << endl;
        }
    }
    string name;
    int age;
    int *p;
};
int main(){
    Person p1("John", 30, new int(100));    p1.show();
    Person p2(p1);  p2.show();
    *p2.p = 10;
    p1.show();  p2.show();
}
```
代码输出：
```cpp
Person(string, int, int*) constructor called
name: John, age: 30, p: 0x2147a741bc0, *p=100
Person(const Person&) copy constructor called
name: John, age: 30, p: 0x2147a741bc0, *p=100
name: John, age: 30, p: 0x2147a741bc0, *p=10
name: John, age: 30, p: 0x2147a741bc0, *p=10
Destructor called: 0x5769bffb70
Destructor called: 0x5769bffba0
```

重载拷贝构造函数：
```cpp
Person(const Person &p){
    std::cout << "Person(const Person&) copy constructor called" << std::endl;
    this->name = p.name; this->age = p.age; this->p = p.p;
}
Person(const Person &p, int *pp){
    std::cout << "Person(const Person&, int *pp) copy constructor called" << std::endl;
    this->name = p.name; this->age = p.age; this->p = pp;
}
Person p1("John", 30, new int(100));    p1.show();
Person p2(p1, new int(200));    p2.show();
*p2.p = 10;
p1.show();  p2.show();
// 输出结果
Person(string, int, int*) constructor called
name: John, age: 30, p: 0x2232fc278b0, *p=100
Person(const Person&, int *pp) copy constructor called
name: John, age: 30, p: 0x2232fc278d0, *p=200
name: John, age: 30, p: 0x2232fc278b0, *p=100
name: John, age: 30, p: 0x2232fc278d0, *p=10
Destructor called: 0x94b8bffca0
Destructor called: 0x94b8bffcd0
```

注意：
- 访问权限必须是public。
- 函数名必须与类名相同。
- 没有返回值，不写void。
- 如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。
- 以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。
    ```cpp
    void func(Person obj){} // 形参是值传递的对象
    void funcRef(Person &obj){} // 形参传递引用
    int main() {
        Person p("John", 30, new int(100));
        func(p); // 调用func时，实参p被拷贝到形参obj中，触发拷贝构造函数
        funcRef(p); // 调用funcRef时，不会触发拷贝构造函数
        return 0;
    }
    ```
- 当函数返回一个对象时，需要将局部对象（如临时对象）的值拷贝到调用处的变量中。此时，编译器可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）。
    ```cpp
    Person getPerson() {
        Person p("John", 30, new int(100));
        return p;  // 返回局部对象temp
    }
    int main() {
        Person p = getPerson(); // 返回值可能触发拷贝构造函数（若未优化）
        return 0;
    }
    ```
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。
- 拷贝构造函数可以重载，可以有默认参数，必须要要有`const 类名& 对象名`，否则就是一个普通的构造函数
    ```cpp
    类名(......,const 类名& 对象名,......){......}
    ```