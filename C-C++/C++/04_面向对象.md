# 1、类

## 1.1、基本概念

对面向对象编程来说，一切都是对象，对象用类来描述。类把对象的数据和操作数据的方法作为一个整体考虑。

定义类的语法：
```cpp
class 类名
{
public:
    成员一的数据类型  成员名一;
    成员二的数据类型  成员名二;
    成员三的数据类型  成员名三;
    ......
    成员n的数据类型  成员名n;
private:
    成员n的数据类型  成员名n;
};
```
注意：
- 类的成员可以是变量，也可以是函数。
- 类的成员变量也叫属性。
- 类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。
- 用类定义一个类的变量叫创建（或实例化）一个对象。
- 对象的成员变量、成员函数的作用域和生命周期与对象的作用域和生命周期相同。

```cpp
class Person{
public:
    string name;                           // 姓名。
    int age;                               // 年龄。
    void setvalue(string name1, int age1); // 设置成员变量的值。
    void show(){
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
};
void Person::setvalue(string name1, int age1){ // 设置成员变量的值。
    name = name1;
    age = age1;
}
int main(){
    Person p1;
    p1.setvalue("张三", 20);
    p1.show();
}
```

## 1.2、类的访问权限

类的成员有三种访问权限：public、private和protected，分别表示公有的、私有的和受保护的。
- 在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。
- 在类的外部（定义类的代码之外），只能访问public成员，不能访问 private、protected成员。
- 在一个类体的定义中，private 和 public 可以出现多次。
- 结构体的成员缺省为public，类的成员缺省为private。
- private的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为public。

## 1.3、基本使用

- 类的成员函数可以直接访问该类其它的成员函数（可以递归）。
- 类的成员函数可以重载，可以使用默认参数。
- 类指针的用法与结构体指针用法相同。
- 类的成员可以是任意数据类型（类中枚举）。
- 可以为类的成员指定缺省值（C++11标准）。
- 类可以创建对象数组，就像结构体数组一样。
- 对象可以作为实参传递给函数，一般传引用。
- 可以用`new`动态创建对象，用`delete`释放对象。
- 在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。
- 对象一般不用`memset()`清空成员变量，可以写一个专用于清空成员变量的成员函数。
- 对类和对象用`sizeof`运算意义不大，一般不用。
- 用结构体描述纯粹的数据，用类描述对象。
- 在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。
- 为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。
- 类的分文件编写。

## 1.4、构造函数和析构函数

- 构造函数：在创建对象时，自动的进行初始化工作。
- 析构函数：在销毁对象前，自动的完成清理工作；

### 1.4.1、构造函数

语法：`类名(){......}`
- 访问权限必须是public。
- 函数名必须与类名相同。
- 没有返回值，不写void。
- 可以有参数，可以重载，可以有默认参数。
- 创建对象时只会自动调用一次，不能手工调用。

### 1.4.2、析构函数

语法：`~类名(){......}`
- 访问权限必须是`public`。
- 函数名必须在类名前加`~`。
- 没有返回值，也不写void。
- 没有参数，不能重载。
- 销毁对象前只会自动调用一次，但是可以手工调用。

### 1.4.3、基本示例

```cpp
class Person{
public:
    Person(){
        std::cout << "Person() constructor called" << std::endl;
    }
    Person(string name, int age){
        std::cout << "Person(string name, int age) constructor called" << std::endl;
        this->name = name;        this->age = age;
    }
    ~Person(){
        std::cout << "Destructor called" << std::endl;
    }
    void show() {
        std::cout << "name: " << name << ", age: " << age << std::endl;
    }
private:
    string name;
    int age;
};
int main(){
    Person p1 = Person("张无忌", 20);
}
```
上面代码的输出为：
```cpp
Person(string name, int age) constructor called
Destructor called
```
再比如说：
```cpp
Person p1; // 调用默认构造函数 ，输出 Person() constructor called
p1 = Person("周芷若", 20); // 临时对象创建 ：Person("周芷若", 20) 调用 带参数构造函数
// 临时对象销毁 ：临时对象被销毁，调用析构函数
// p1 对象销毁，调用析构函数
```
代码输出为：
```cpp
Person() constructor called
Person(string name, int age) constructor called
Destructor called
Destructor called
```

### 1.4.4、说明

- 如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。
- 如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。
- 创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。
- 创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数），兼容C语言 ：C语言中函数声明的语法为 `类型 名称(参数列表)`，C++继承了这一语法，导致与对象初始化存在歧义。
    ```cpp
    class Person {
        Person() {}  // 默认构造函数
    };
    // 错误：被解析为函数声明（返回Person，参数为空）
    Person p(); 
    // 正确：不带括号，直接调用默认构造函数
    Person p;
    // 正确：显式调用构造函数（带参数）
    Person p(10); 
    ```
- 在构造函数名后面加`括号和参数`不是调用构造函数，是创建匿名对象。
    ```cpp
    class MyClass {
        MyClass(int x) { /* 初始化逻辑 */ }
    };
    MyClass(10);  // 创建匿名对象，调用构造函数 MyClass(int)，但对象无名
    ```
- 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。
    ```cpp
    Person(string& name){
        std::cout << "Person(string name) constructor called" << std::endl;
        this->name = name;        this->age = 18;
    }
    Person(const char* name){
        std::cout << "Person(const char* name)constructor called" << std::endl;
        this->name = name;        this->age = 18;
    }
    string name = "张无忌";
    Person p1 = name; // 会调用上面的 Person(string& name) 构造函数
    Person p2 = "abcd"; // 会调用 Person(const char* name) 构造函数
    ```
- 用new/delete创建/销毁对象时，也会调用构造/析构函数
    ```cpp
    Person* p1 = new Person("张无忌", 20 );
    p1->show();
    delete p1;
    ```
- 不建议在构造/析构函数中写太多的代码，可以调用成员函数
- C++11支持使用统一初始化列表。
    ```cpp
    Person p1 = {"张无忌", 20};
    Person p2{"张无忌", 20};
    Person p3 = Person{"张无忌", 20};
    Person* p4 = new Person{"张无忌", 20};
    delete p4;
    ```
- 如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类
    ```cpp
        class B {
    public:
        B() { cout << "B constructor" << endl; }
        ~B() { cout << "B destructor" << endl; }
    };

    class C {
        B b;
    public:
        C() { cout << "C constructor" << endl; }
        ~C() { cout << "C destructor" << endl; }
    };

    class A {
        B b;  // 先声明B
        C c;  // 后声明C
    public:
        A() { cout << "A constructor" << endl; }
        ~A() { cout << "A destructor" << endl; }
    };
    int main() {
        A a;
        return 0;
    }
    B constructor
    B constructor
    C constructor
    A constructor
    A destructor
    C destructor
    B destructor
    B destructor
    ```

## 1.5、拷贝构造函数

用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。

如果类中没有定义拷贝构造函数，编译器将提供一个拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。

用一个已存在的对象创建新的对象语法：
```
类名 新对象名(已存在的对象名);
类名 新对象名=已存在的对象名;
```
拷贝构造函数的语法：
```cpp
类名(const 类名& 对象名){......}
```

示例代码
```cpp
class Person{
public:
    Person(){
        std::cout << "Person() constructor called" << std::endl;
        this->p = nullptr;        this->name.clear();        this->age = 0;
    }
    Person(string name, int age, int *p){
        std::cout << "Person(string, int, int*) constructor called" << std::endl;
        this->name = name;        this->age = age;        this->p = p;
    }
    Person(const Person &p){
        std::cout << "Person(const Person&) copy constructor called" << std::endl;
        this->name = p.name;  this->age = p.age; this->p = p.p;
    }
    ~Person(){
        std::cout << "Destructor called: " << this << std::endl;
        delete p;
        p = nullptr;
    }
    void show(){
        std::cout << "name: " << name << ", age: " << age << ", p: " << p;
        if (p != nullptr){
            cout << ", *p=" << *p << endl;
        } else {
            cout << endl;
        }
    }
    string name;
    int age;
    int *p;
};
int main(){
    Person p1("John", 30, new int(100));    p1.show();
    Person p2(p1);  p2.show();
    *p2.p = 10;
    p1.show();  p2.show();
}
```
代码输出：
```cpp
Person(string, int, int*) constructor called
name: John, age: 30, p: 0x2147a741bc0, *p=100
Person(const Person&) copy constructor called
name: John, age: 30, p: 0x2147a741bc0, *p=100
name: John, age: 30, p: 0x2147a741bc0, *p=10
name: John, age: 30, p: 0x2147a741bc0, *p=10
Destructor called: 0x5769bffb70
Destructor called: 0x5769bffba0
```

重载拷贝构造函数：
```cpp
Person(const Person &p){
    std::cout << "Person(const Person&) copy constructor called" << std::endl;
    this->name = p.name; this->age = p.age; this->p = p.p;
}
Person(const Person &p, int *pp){
    std::cout << "Person(const Person&, int *pp) copy constructor called" << std::endl;
    this->name = p.name; this->age = p.age; this->p = pp;
}
Person p1("John", 30, new int(100));    p1.show();
Person p2(p1, new int(200));    p2.show();
*p2.p = 10;
p1.show();  p2.show();
// 输出结果
Person(string, int, int*) constructor called
name: John, age: 30, p: 0x2232fc278b0, *p=100
Person(const Person&, int *pp) copy constructor called
name: John, age: 30, p: 0x2232fc278d0, *p=200
name: John, age: 30, p: 0x2232fc278b0, *p=100
name: John, age: 30, p: 0x2232fc278d0, *p=10
Destructor called: 0x94b8bffca0
Destructor called: 0x94b8bffcd0
```

注意：
- 访问权限必须是public。
- 函数名必须与类名相同。
- 没有返回值，不写void。
- 如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。
- 以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。
    ```cpp
    void func(Person obj){} // 形参是值传递的对象
    void funcRef(Person &obj){} // 形参传递引用
    int main() {
        Person p("John", 30, new int(100));
        func(p); // 调用func时，实参p被拷贝到形参obj中，触发拷贝构造函数
        funcRef(p); // 调用funcRef时，不会触发拷贝构造函数
        return 0;
    }
    ```
- 当函数返回一个对象时，需要将局部对象（如临时对象）的值拷贝到调用处的变量中。此时，编译器可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）。
    ```cpp
    Person getPerson() {
        Person p("John", 30, new int(100));
        return p;  // 返回局部对象temp
    }
    int main() {
        Person p = getPerson(); // 返回值可能触发拷贝构造函数（若未优化）
        return 0;
    }
    ```
- 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。
- 拷贝构造函数可以重载，可以有默认参数，必须要要有`const 类名& 对象名`，否则就是一个普通的构造函数
    ```cpp
    类名(......,const 类名& 对象名,......){......}
    ```


## 1.6、初始化列表


构造函数的执行可以分成两个阶段：初始化阶段和计算阶段（初始化阶段先于计算阶段）。
- 初始化阶段：全部的成员都会在初始化阶段初始化。
- 计算阶段：一般是指用于执行构造函数体内的赋值操作。

构造函数除了参数列表和函数体之外，还可以有初始化列表。

初始化列表的语法：
```cpp
类名(形参列表):成员一(值一), 成员二(值二),..., 成员n(值n)
{......}
```

注意：
- 如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。
- 初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。
- 初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。
- 如果成员是类，初始化列表对性能略有提升。
- 如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。
- 如果成员是没有默认构造函数的类，则必须使用初始化列表。
- 拷贝构造函数也可以有初始化列表。
- 类的成员变量可以不出现在初始化列表中。
- 构造函数的形参先于成员变量初始化。

```cpp
Person(string name, int age, int *p): name(name), age(age), p(p) {
    std::cout << "Person(string, int, int*) constructor called" << std::endl;
}
```

## 1.7、const修饰成员函数

在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量
```cpp
void show() const{
    std::cout << "name: " << name << ", age: " << age << ", p: " << p;
    if (p != nullptr) {
      cout << ", *p=" << *p << endl;
    } else {
      cout << endl;
    }
}
```

说明：
- `mutable`可以突破`const`的限制，被`mutable`修饰的成员变量，将永远处于可变的状态，在`const`修饰的函数中，`mutable`成员也可以被修改。
- `非const`成员函数可以调用`const`成员函数和非`const`成员函数。
- `const`成员函数不能调用`非const`成员函数。
- `非const`对象可以调用`const`修饰的成员函数和`非const`修饰的成员函数。
- `const`对象只能调用`const`修饰的成员函数，不能调用`非const`修饰的成员函数。

```cpp
void show1() const{
    age = 10; // 报错
    std::cout << "name: " << name << ", age: " << age << ", p: " << p;
}
void show2() const{
    name = "Jane"; // 可以修改
    std::cout << "name: " << name << ", age: " << age << ", p: " << p;
}
mutable string name;
int age;
```

## 1.8、this指针

如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。

this指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。

每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）`*this`可以表示对象。

如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量；
```cpp
const Person &func(const Person &person) const {
    std::cout << "func(const Person&) called" << &person << std::endl;
    return *this;
}
```

## 1.9、静态成员


类的静态成员包括静态成员变量和静态成员函数。

用静态成员可以变量实现多个对象之间的数据共享，比全局变量更安全性。

用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。

静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符 `::`）。

静态成员使用类名加范围解析运算符 `::` 就可以访问，不需要创建对象。

如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。

静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。

- 在静态成员函数中，只能访问静态成员，不能访问非静态成员。静态成员函数中没有this指针。
- 在非静态成员函数中，可以访问静态成员。
- 私有静态成员在类外无法访问。
- const静态成员变量可以在定义类的时候初始化。

## 1.10、简单对象模型

在C语言中，数据和处理数据的操作（函数）是分开的。也就是说，C语言本身没有支持数据和函数之间的关联性。

C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了数据和函数，把数据和函数关联起来。

对象中维护了多个指针表，表中放了成员与地址的对应关系。

C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。
- 对象内存的大小包括：
    - 所有非静态数据成员的大小；
    - 由内存对齐而填补的内存大小；
    - 为了支持virtual成员而产生的额外负担。
- 静态成员变量属于类，不计算在对象的大小之内。
- 成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。
- 用空指针可以调用没有用到this指针的非静态成员函数。
- 对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。

## 1.11、友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：
- 友元全局函数：在友元全局函数中，可以访问另一个类的所有成员
- 友元类：在友元类所有成员函数中，都可以访问另一个类的所有成员，注意事项：
    - 友元关系不能被继承
    - 友元关系是单向的，不具备交换性

    若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明
- 友元成员函数：在友元成员函数中，可以访问另一个类的所有成员


